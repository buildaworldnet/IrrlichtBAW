\endcode  GCC compile Flags
-flto
-fuse-linker-plugin
-fno-omit-frame-pointer //for debug
-msse3
-mfpmath=sse
-ggdb3 //for debug
\code
\endcode  Linker Flags
-lIrrlicht
-lXrandr
-lGL
-lX11
-lpthread
-ldl

-fuse-ld=gold
-flto
-fuse-linker-plugin
-msse3
\code
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"

/**
This example just shows a screen which clears to red,
nothing fancy, just to show that Irrlicht links fine
**/
using namespace irr;


\endcode 
The start of the main function starts like in most other example. We ask the
user for the desired renderer and start it up.
\code
int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = core::dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	params.AuxGLContexts = 16;
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();
	scene::ISceneManager* smgr = device->getSceneManager();


	uint64_t lastFPSTime = 0;

	while(device->run())
	if (device->isWindowActive())
	{
		driver->beginScene(true, false, video::SColor(255,255,0,0) ); //this gets 11k FPS


		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
		    std::wostringstream str(L"Hello World - Irrlicht Engine [");
		    str.seekp(0,std::ios_base::end);
			str << driver->getName() << "] FPS:" << driver->getFPS();

			device->setWindowCaption(str.str());
			lastFPSTime = time;
		}
	}

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();

	device->drop();

	return 0;
}
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLBuffer.h"
#include "../source/Irrlicht/COpenGLExtensionHandler.h"

using namespace irr;
using namespace core;



#define BIG_PRIMORIAL 116396280

#include "irrpack.h"
template<size_t extraDataCnt = 1> // do not use more than 16
class ParticleStruct
{
    public:
        //Key is always guaranteed to be >=0.f
        float Key;
        uint32_t extraData[extraDataCnt];

        inline bool operator<(const ParticleStruct& other) const
        {
            return Key<other.Key;
        }
} PACK_STRUCT;
#include "irrunpack.h"

int main()
{

	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.

    video::IVideoDriver* driver = device->getVideoDriver();


    srand(69012345u);
#define EXTRA_DATA_AMOUNT 4 //valid amounts are [1,16]
    const size_t elementSize = sizeof(ParticleStruct<EXTRA_DATA_AMOUNT>);
    const size_t elementCount = BIG_PRIMORIAL/elementSize;

    ParticleStruct<EXTRA_DATA_AMOUNT>* randomData = reinterpret_cast<ParticleStruct<EXTRA_DATA_AMOUNT>*>(malloc(sizeof(uint32_t)*BIG_PRIMORIAL));
    assert(BIG_PRIMORIAL%elementSize==0);

    for (size_t i=0; i<elementCount; i++)
        randomData[i].Key = rand();

    //! GPU buffer allocated using ARB_buffer_storage, you can rewrite this part into pure OpenGL of your choosing
    video::COpenGLBuffer* buffer = dynamic_cast<video::COpenGLBuffer*>(driver->createGPUBuffer(elementCount*elementSize,randomData));
    // buffer will later be dropped

    //! sort on CPU to compare results
    std::sort(randomData,randomData+elementCount);

    //! Reset default OpenGL state
	video::COpenGLState defaultState;
    video::COpenGLStateDiff diff = defaultState.getStateDiff(video::COpenGLState::collectGLState());
    video::executeGLDiff(diff);

    \endcode

    You now have a valid OpenGL context and a window with default global state
    You can use any OpenGL function as long as you load it from the OpenGL
    Most functions like glUseProgram are already loaded and are available
    Try use OpenGL 4.5 with Direct State Access functions

    For compute shaders you'll need to look inside COpenGLExtensionHandler.cpp
    for how OpenGL function pointers are loaded for GL 1.2+ functions.
    \code
	//!=======================================START SETUP===========================================

	// create some shaders, texture buffer objects etc. etc.
	// bind UBOs, SSBOs or whatever

	//!========================================END SETUP============================================
    \endcode


    Below is the part that I will time, it will help to put it in a loop
    and sort 1000 times to get reliable timings for your own testing.
    \code
    video::IQueryObject* gpuElapsedTime = driver->createElapsedTimeQuery();
    driver->beginQuery(gpuElapsedTime);
	//!=======================================START SORT============================================

    // good luck
    // buffer->getOpenGLName() is the GLuint handle to an opengl buffer allocated through glBufferStorage

	//!========================================END SORT=============================================
	driver->endQuery(gpuElapsedTime);

	uint64_t timingResult;
	gpuElapsedTime->getQueryResult(&timingResult);
	printf("Elapsed GPU Time %d us\n",timingResult/1000ull);


	ParticleStruct<EXTRA_DATA_AMOUNT>* resultData = reinterpret_cast<ParticleStruct<EXTRA_DATA_AMOUNT>*>(malloc(sizeof(uint32_t)*BIG_PRIMORIAL));
	video::COpenGLExtensionHandler::extGlGetNamedBufferSubData(buffer->getOpenGLName(),0,elementCount*elementSize,resultData);
    buffer->drop();

	bool allGood = true;
    for (size_t i=0; i<elementCount; i++)
    {
        if (strcmp((const char*)randomData,(const char*)resultData))
        {
            allGood = false;
            break;
        }
    }
    printf(allGood ? "SUCCESS!\n":"FAIL!\n");

    free(resultData);
    free(randomData);

	device->drop();

	return 0;
}
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"
#include <iostream>
#include <cstdio>


using namespace irr;
using namespace core;


/**
We do cool stuff here, like make an event receiver to process input
**/
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                exit(0);
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t mvpUniformLocation;
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
public:
    SimpleCallBack() : mvpUniformLocation(-1), mvpUniformType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        //! Normally we'd iterate through the array and check our actual constant names before mapping them to locations but oh well
        mvpUniformLocation = constants[0].location;
        mvpUniformType = constants[0].type;
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);
    }

    virtual void OnUnsetMaterial() {}
};

#include "irrpack.h"
struct VertexStruct
{
    float Pos[3];
    uint8_t Col[2];
} PACK_STRUCT;
#include "irrunpack.h"

int main()
{
	printf("Please select the background:\n");
	printf(" (0 : default) Use SkyDome\n");
	printf(" (1) Use SkyBox\n");

	uint8_t c = 0;
	std::cin >> c;

	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();
    SimpleCallBack* callBack = new SimpleCallBack();

    //! First need to make a material other than default to be able to draw with custom shader
    video::SMaterial material;
    material.BackfaceCulling = false; //! Triangles will be visible from both sides
    material.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        callBack,
                                                        0); //! No custom user data
    callBack->drop();


	scene::ISceneManager* smgr = device->getSceneManager();




	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	driver->setTextureCreationFlag(video::ETCF_CREATE_MIP_MAPS, false);

	// create skybox and skydome
	switch (c)
	{
        case '1':
            smgr->addSkyBoxSceneNode(
                driver->getTexture("../../media/irrlicht2_up.jpg"),
                driver->getTexture("../../media/irrlicht2_dn.jpg"),
                driver->getTexture("../../media/irrlicht2_lf.jpg"),
                driver->getTexture("../../media/irrlicht2_rt.jpg"),
                driver->getTexture("../../media/irrlicht2_ft.jpg"),
                driver->getTexture("../../media/irrlicht2_bk.jpg"));
            break;
        default:
            smgr->addSkyDomeSceneNode(driver->getTexture("../../media/skydome.jpg"),16,8,0.95f,2.0f,10.f);
            break;
	}

	driver->setTextureCreationFlag(video::ETCF_CREATE_MIP_MAPS, true);


	//! we want to move around the scene and view it from different angles
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.001f);

	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(10.0f);

    smgr->setActiveCamera(camera);


	//! disable mouse cursor, since camera will force it to the middle
	//! and we don't want a jittery cursor in the middle distracting us
	device->getCursorControl()->setVisible(false);

	//! Since our cursor will be enslaved, there will be no way to close the window
	//! So we listen for the "Q" key being pressed and exit the application
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);

	uint64_t lastFPSTime = 0;
	printf("%d\n",sizeof(VertexStruct));

	while(device->run())
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,255,255,255) );

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();

        //! Stress test for memleaks aside from demo how to create meshes that live on the GPU RAM
        {
            scene::IGPUMeshBuffer* mb = new scene::IGPUMeshBuffer();
            scene::IGPUMeshDataFormatDesc* desc = driver->createGPUMeshDataFormatDesc();
            mb->setMeshDataAndFormat(desc);
            desc->drop();

            VertexStruct vertices[8];
            vertices[0].Pos[0] = -1.f;
            vertices[0].Pos[1] = -1.f;
            vertices[0].Pos[2] = -1.f;
            vertices[0].Col[0] = 0;
            vertices[0].Col[1] = 0;
            vertices[1].Pos[0] = 1.f;
            vertices[1].Pos[1] = -1.f;
            vertices[1].Pos[2] = -1.f;
            vertices[1].Col[0] = 127;
            vertices[1].Col[1] = 0;
            vertices[2].Pos[0] = -1.f;
            vertices[2].Pos[1] = 1.f;
            vertices[2].Pos[2] = -1.f;
            vertices[2].Col[0] = 255;
            vertices[2].Col[1] = 0;
            vertices[3].Pos[0] = 1.f;
            vertices[3].Pos[1] = 1.f;
            vertices[3].Pos[2] = -1.f;
            vertices[3].Col[0] = 0;
            vertices[3].Col[1] = 127;
            vertices[4].Pos[0] = -1.f;
            vertices[4].Pos[1] = -1.f;
            vertices[4].Pos[2] = 1.f;
            vertices[4].Col[0] = 127;
            vertices[4].Col[1] = 127;
            vertices[5].Pos[0] = 1.f;
            vertices[5].Pos[1] = -1.f;
            vertices[5].Pos[2] = 1.f;
            vertices[5].Col[0] = 255;
            vertices[5].Col[1] = 127;
            vertices[6].Pos[0] = -1.f;
            vertices[6].Pos[1] = 1.f;
            vertices[6].Pos[2] = 1.f;
            vertices[6].Col[0] = 0;
            vertices[6].Col[1] = 255;
            vertices[7].Pos[0] = 1.f;
            vertices[7].Pos[1] = 1.f;
            vertices[7].Pos[2] = 1.f;
            vertices[7].Col[0] = 127;
            vertices[7].Col[1] = 255;

            uint16_t indices_indexed16[] =
            {
                0,1,2,1,2,3,
                4,5,6,5,6,7,
                0,1,4,1,4,5,
                2,3,6,3,6,7,
                0,2,4,2,4,6,
                1,3,5,3,5,7
            };

            void* tmpMem = malloc(sizeof(vertices)+2+sizeof(indices_indexed16));
            memcpy(tmpMem,vertices,sizeof(vertices));
            memcpy(tmpMem+sizeof(vertices)+2,indices_indexed16,sizeof(indices_indexed16));
            video::IGPUBuffer* buff = driver->createGPUBuffer(sizeof(vertices)+sizeof(indices_indexed16)+2,tmpMem);
            free(tmpMem);

            desc->mapVertexAttrBuffer(buff,scene::EVAI_ATTR0,scene::ECPA_THREE,scene::ECT_FLOAT,sizeof(VertexStruct),0);
            desc->mapVertexAttrBuffer(buff,scene::EVAI_ATTR1,scene::ECPA_TWO,scene::ECT_NORMALIZED_UNSIGNED_BYTE,sizeof(VertexStruct),12);
            desc->mapIndexBuffer(buff);
            mb->setIndexBufferOffset(sizeof(vertices)+2);
            mb->setIndexType(video::EIT_16BIT);
            mb->setIndexCount(2*3*6);
            buff->drop();

            driver->setTransform(video::E4X3TS_WORLD,core::matrix4x3());
            driver->setMaterial(material);
            driver->drawMeshBuffer(mb);
            mb->drop();
        }

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream str;
			str << L"GPU Mesh Demo - Irrlicht Engine [" << driver->getName() << "] FPS:" << driver->getFPS() << " PrimitvesDrawn:" << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.str().c_str());
			lastFPSTime = time;
		}
	}

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();
	device->sleep(3000);

	device->drop();

	return 0;
}
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"

using namespace irr;
using namespace core;

//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                exit(0);
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t mvpUniformLocation;
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
public:
    SimpleCallBack() : mvpUniformLocation(-1), mvpUniformType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        //! Normally we'd iterate through the array and check our actual constant names before mapping them to locations but oh well
        mvpUniformLocation = constants[0].location;
        mvpUniformType = constants[0].type;
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);
    }

    virtual void OnUnsetMaterial() {}
};



int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();
    SimpleCallBack* callBack = new SimpleCallBack();

    //! First need to make a material other than default to be able to draw with custom shader
    video::SMaterial material;
    material.BackfaceCulling = false; //! Triangles will be visible from both sides
    material.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        callBack, //! No Shader Callback (we dont have any constants/uniforms to pass to the shader)
                                                        0); //! No custom user data
    callBack->drop();


	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(100.0f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);


	//! Test Creation Of Builtin
	scene::IMeshSceneNode* cube = dynamic_cast<scene::IMeshSceneNode*>(smgr->addCubeSceneNode(1.f,0,-1));
    cube->setRotation(core::vector3df(45,20,15));
    cube->getMaterial(0).setTexture(0,driver->getTexture("../../media/irrlicht2_dn.jpg"));

	scene::IMeshSceneNode* sphere = dynamic_cast<scene::IMeshSceneNode*>(smgr->addSphereSceneNode(2,128));
    sphere->getMaterial(0).setTexture(0,driver->getTexture("../../media/skydome.jpg"));
    sphere->getMaterial(0).MaterialType = material.MaterialType;
    sphere->setPosition(core::vector3df(4,0,0));

	scene::ISceneNode* billboard = smgr->addBillboardSceneNode(0,core::dimension2df(1.f,1.f),core::vector3df(-4,0,0));
    billboard->getMaterial(0).setTexture(0,driver->getTexture("../../media/yellowflowers.dds")); //loads all mipmap levels

    //scene::CGeometryCreator* geom = new scene::CGeometryCreator();


	uint64_t lastFPSTime = 0;

	while(device->run())
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();

        //! Stress test for memleaks aside from demo how to create meshes that live on the GPU RAM
        {\endcode 
            scene::IGPUMeshBuffer* mb = new scene::IGPUMeshBuffer();
            scene::IGPUMeshDataFormatDesc* desc = driver->createGPUMeshDataFormatDesc();
            mb->setMeshDataAndFormat(desc);
            desc->drop();

            uint16_t indices_indexed16[] = {
                0,1,2,1,2,3,
                4,5,6,5,6,7,
                0,1,4,1,4,5,
                2,3,6,3,6,7,
                0,2,4,2,4,6,
                1,3,5,3,5,7
            };
            video::IGPUBuffer* index = driver->createGPUBuffer(sizeof(indices_indexed16),indices_indexed16);
            desc->mapIndexBuffer(index);
            mb->setIndexType(video::EIT_16BIT);
            mb->setIndexCount(2*3*6);
            mb->setIndexRange(0,7);
            index->drop();

            float attrArr[] = {
                -1.f,-1.f,-1.f,0.f,0.f,
                 1.f,-1.f,-1.f,0.5f,0.f,
                -1.f, 1.f,-1.f,1.f,0.f,
                 1.f, 1.f,-1.f,0.f,0.5f,
                -1.f,-1.f, 1.f,0.5f,0.5f,
                 1.f,-1.f, 1.f,1.f,0.5f,
                -1.f, 1.f, 1.f,0.f,1.f,
                 1.f, 1.f, 1.f,0.5f,1.f
            };
            video::IGPUBuffer* attr0 = driver->createGPUBuffer(sizeof(attrArr),attrArr);
            desc->mapVertexAttrBuffer(attr0,scene::EVAI_ATTR0,scene::ECPA_THREE,scene::ECT_FLOAT,20,0);
            desc->mapVertexAttrBuffer(attr0,scene::EVAI_ATTR1,scene::ECPA_TWO,scene::ECT_FLOAT,20,3*4);
            attr0->drop();

            driver->setTransform(video::ETS_WORLD,core::matrix4());
            driver->setMaterial(material);
            driver->drawMeshBuffer(mb);
            mb->drop();\code
        }

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream str;
			str << L"Builtin Nodes Demo - Irrlicht Engine FPS:" << driver->getFPS() << " PrimitvesDrawn:" << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.str().c_str());
			lastFPSTime = time;
		}
	}

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();
	device->sleep(3000);

	device->drop();

	return 0;
}
\endcode  GCC compile Flags
-flto
-fuse-linker-plugin
-fno-omit-frame-pointer //for debug
-msse3
-mfpmath=sse
-ggdb3 //for debug
\code
\endcode  Linker Flags
-lIrrlicht
-lXrandr
-lGL
-lX11
-lpthread
-ldl

-fuse-ld=gold
-flto
-fuse-linker-plugin
-msse3
\code
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"

/**
This example shows how to:
1) Set up and Use a Simple Shader
2) render triangle buffers to screen in all the different ways
**/
using namespace irr;
using namespace core;



class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t mvpUniformLocation;
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
public:
    SimpleCallBack() : mvpUniformLocation(-1), mvpUniformType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        //! Normally we'd iterate through the array and check our actual constant names before mapping them to locations but oh well
        mvpUniformLocation = constants[0].location;
        mvpUniformType = constants[0].type;
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);
    }

    virtual void OnUnsetMaterial() {}
};


\endcode

The start of the main function starts like in most other example. We ask the
user for the desired renderer and start it up.
\code
int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1920, 1080);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();
	SimpleCallBack* callBack = new SimpleCallBack();

    //! First need to make a material other than default to be able to draw with custom shader
    video::SMaterial material;
    //material.BackfaceCulling = false; //! Triangles will be visible from both sides
    material.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../points.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../points.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        callBack, //! No Shader Callback (we dont have any constants/uniforms to pass to the shader)
                                                        0); //! No custom user data
    callBack->drop();



	scene::ISceneManager* smgr = device->getSceneManager();


    scene::IGPUMeshBuffer* mb = new scene::IGPUMeshBuffer();
    scene::IGPUMeshDataFormatDesc* desc = driver->createGPUMeshDataFormatDesc();
    mb->setMeshDataAndFormat(desc);
    desc->drop();

    size_t xComps = 0x1u<<9;
    size_t yComps = 0x1u<<9;
    size_t zComps = 0x1u<<9;
    size_t verts = xComps*yComps*zComps;
    size_t bufSize = verts;
    bufSize *= 4;
    uint32_t* mem = (uint32_t*)malloc(bufSize);
    for (size_t i=0; i<xComps; i++)
    for (size_t j=0; j<yComps; j++)
    for (size_t k=0; k<zComps; k++)
    {
        mem[i+xComps*(j+yComps*k)] = (i<<20)|(j<<10)|(k);
    }
    video::IGPUBuffer* positionBuf = driver->createGPUBuffer(bufSize,mem);
    free(mem);


    //! By mapping we increase/grab() ref counter of positionBuf, any previously mapped buffer will have it's reference dropped
    desc->mapVertexAttrBuffer(positionBuf,
                            scene::EVAI_ATTR0, //! we use first attribute slot (out of a minimum of 16)
                            scene::ECPA_FOUR, //! there are 3 components per vertex
                            scene::ECT_INT_2_10_10_10_REV); //! and they are floats

    /** Since we mapped the buffer, the MeshBuffers will be using it.
        If we drop it, it will be automatically deleted when MeshBuffers are done using it.
    **/
    positionBuf->drop();


    mb->setIndexCount(verts);
    mb->setPrimitiveType(scene::EPT_POINTS);

    scene::ICameraSceneNode* camera = smgr->addCameraSceneNodeFPS(0,80.f,0.001f);
    smgr->setActiveCamera(camera);
    camera->setNearValue(0.001f);
    camera->setFarValue(10.f);

	uint64_t lastFPSTime = 0;

	while(device->run())
	if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

        smgr->drawAll();

        driver->setTransform(video::E4X3TS_WORLD,core::matrix4x3());
        driver->setMaterial(material);
        //! draw back to front
        driver->drawMeshBuffer(mb);

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream str;
			str << L"Sphere Points - Irrlicht Engine  FPS:" << driver->getFPS() << " PrimitvesDrawn:" << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.str().c_str());
			lastFPSTime = time;
		}
	}
	mb->drop();

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();

	device->drop();

	return 0;
}
#define _IRR_STATIC_LIB_
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"

#include "../source/Irrlicht/CGeometryCreator.h"
#include "../source/Irrlicht/CBAWMeshWriter.h"

using namespace irr;
using namespace core;


//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                exit(0);
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t mvpUniformLocation;
    int32_t cameraDirUniformLocation;
    int32_t texUniformLocation[4];
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
    video::E_SHADER_CONSTANT_TYPE cameraDirUniformType;
    video::E_SHADER_CONSTANT_TYPE texUniformType[4];
public:
    SimpleCallBack() : cameraDirUniformLocation(-1), cameraDirUniformType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        for (size_t i=0; i<constants.size(); i++)
        {
            if (constants[i].name=="MVP")
            {
                mvpUniformLocation = constants[i].location;
                mvpUniformType = constants[i].type;
            }
            else if (constants[i].name=="cameraPos")
            {
                cameraDirUniformLocation = constants[i].location;
                cameraDirUniformType = constants[i].type;
            }
            else if (constants[i].name=="tex0")
            {
                texUniformLocation[0] = constants[i].location;
                texUniformType[0] = constants[i].type;
            }
            else if (constants[i].name=="tex3")
            {
                texUniformLocation[3] = constants[i].location;
                texUniformType[3] = constants[i].type;
            }
        }
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        core::vectorSIMDf modelSpaceCamPos;
        modelSpaceCamPos.set(services->getVideoDriver()->getTransform(video::E4X3TS_WORLD_VIEW_INVERSE).getTranslation());
        services->setShaderConstant(&modelSpaceCamPos,cameraDirUniformLocation,cameraDirUniformType,1);
        services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);
\endcode

        int32_t id[] = {0,1,2,3};
        services->setShaderTextures(id+0,texUniformLocation[0],texUniformType[0],1);
        services->setShaderTextures(id+3,texUniformLocation[3],texUniformType[3],1);\code
    }

    virtual void OnUnsetMaterial() {}
};


int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();

    SimpleCallBack* cb = new SimpleCallBack();
    video::E_MATERIAL_TYPE newMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        cb, //! Our Shader Callback
                                                        0); //! No custom user data
    cb->drop();



	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(100.0f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);

	io::IFileSystem* fs = device->getFileSystem();
	scene::IMeshWriter* writer = smgr->createMeshWriter(irr::scene::EMWT_BAW);

	//! Test Loading of Obj
    scene::ICPUMesh* cpumesh = smgr->getMesh("../../media/extrusionLogo_TEST_fixed.stl");
	// export mesh
	io::IWriteFile* file = fs->createAndWriteFile("extrusionLogo_TEST_fixed.baw");
	writer->writeMesh(file, cpumesh);
	file->drop();
	// end export
    if (cpumesh)
    {
        scene::IGPUMesh* gpumesh = driver->createGPUMeshFromCPU(dynamic_cast<scene::SCPUMesh*>(cpumesh));
        smgr->getMeshCache()->removeMesh(cpumesh);
        smgr->addMeshSceneNode(gpumesh)->setMaterialType(newMaterialType);
        gpumesh->drop();
    }

    cpumesh = smgr->getMesh("../../media/cow.obj");
	// export mesh
	file = fs->createAndWriteFile("cow.baw");
	writer->writeMesh(file, cpumesh);
	file->drop();
	writer->drop();
	// end export
    if (cpumesh)
    {
        scene::IGPUMesh* gpumesh = driver->createGPUMeshFromCPU(dynamic_cast<scene::SCPUMesh*>(cpumesh));
        smgr->getMeshCache()->removeMesh(cpumesh);
        smgr->addMeshSceneNode(gpumesh,0,-1,core::vector3df(3.f,1.f,0.f))->setMaterialType(newMaterialType);
        gpumesh->drop();
    }


	uint64_t lastFPSTime = 0;

	while(device->run())
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();

        //! Stress test for memleaks aside from demo how to create meshes that live on the GPU RAM
        {\endcode

            scene::IGPUMeshBuffer* mb = new scene::IGPUMeshBuffer();
            scene::IGPUMeshDataFormatDesc* desc = driver->createGPUMeshDataFormatDesc();
            mb->setMeshDataAndFormat(desc);
            desc->drop();

            uint16_t indices_indexed16[] = {
                0,1,2,1,2,3,
                4,5,6,5,6,7,
                0,1,4,1,4,5,
                2,3,6,3,6,7,
                0,2,4,2,4,6,
                1,3,5,3,5,7
            };
            video::IGPUBuffer* index = driver->createGPUBuffer(sizeof(indices_indexed16),indices_indexed16);
            desc->mapIndexBuffer(index);
            mb->setIndexType(video::EIT_16BIT);
            mb->setIndexCount(2*3*6);
            mb->setIndexRange(0,7);
            index->drop();

            float attrArr[] = {
                -1.f,-1.f,-1.f,0.f,0.f,
                 1.f,-1.f,-1.f,0.5f,0.f,
                -1.f, 1.f,-1.f,1.f,0.f,
                 1.f, 1.f,-1.f,0.f,0.5f,
                -1.f,-1.f, 1.f,0.5f,0.5f,
                 1.f,-1.f, 1.f,1.f,0.5f,
                -1.f, 1.f, 1.f,0.f,1.f,
                 1.f, 1.f, 1.f,0.5f,1.f
            };
            video::IGPUBuffer* attr0 = driver->createGPUBuffer(sizeof(attrArr),attrArr);
            desc->mapVertexAttrBuffer(attr0,scene::EVAI_ATTR0,scene::ECPA_THREE,scene::ECT_FLOAT,20,0);
            desc->mapVertexAttrBuffer(attr0,scene::EVAI_ATTR1,scene::ECPA_TWO,scene::ECT_FLOAT,20,3*4);
            attr0->drop();

            driver->setTransform(video::ETS_WORLD,core::matrix4());
            driver->setMaterial(material);
            driver->drawMeshBuffer(mb);
            mb->drop();\code
        }

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream sstr;
			sstr << L"Builtin Nodes Demo - Irrlicht Engine FPS:" << driver->getFPS() << " PrimitvesDrawn:" << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(sstr.str().c_str());
			lastFPSTime = time;
		}
	}

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();
	device->sleep(3000);

	device->drop();

	return 0;
}
#define _IRR_STATIC_LIB_
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"


using namespace irr;
using namespace core;

bool quit = false;

//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                quit = true;
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t mvpUniformLocation;
    int32_t cameraDirUniformLocation;
    int32_t texUniformLocation[4];
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
    video::E_SHADER_CONSTANT_TYPE cameraDirUniformType;
    video::E_SHADER_CONSTANT_TYPE texUniformType[4];
public:
    SimpleCallBack() : cameraDirUniformLocation(-1), cameraDirUniformType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        for (size_t i=0; i<constants.size(); i++)
        {
            if (constants[i].name=="MVP")
            {
                mvpUniformLocation = constants[i].location;
                mvpUniformType = constants[i].type;
            }
            else if (constants[i].name=="cameraPos")
            {
                cameraDirUniformLocation = constants[i].location;
                cameraDirUniformType = constants[i].type;
            }
            else if (constants[i].name=="tex0")
            {
                texUniformLocation[0] = constants[i].location;
                texUniformType[0] = constants[i].type;
            }
            else if (constants[i].name=="tex3")
            {
                texUniformLocation[3] = constants[i].location;
                texUniformType[3] = constants[i].type;
            }
        }
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        core::vectorSIMDf modelSpaceCamPos;
        modelSpaceCamPos.set(services->getVideoDriver()->getTransform(video::E4X3TS_WORLD_VIEW_INVERSE).getTranslation());
        if (cameraDirUniformLocation!=-1)
            services->setShaderConstant(&modelSpaceCamPos,cameraDirUniformLocation,cameraDirUniformType,1);
        if (mvpUniformLocation!=-1)
            services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);

        int32_t id[] = {0,1,2,3};
        if (texUniformLocation[0]!=-1)
            services->setShaderTextures(id+0,texUniformLocation[0],texUniformType[0],1);
        if (texUniformLocation[3]!=-1)
            services->setShaderTextures(id+3,texUniformLocation[3],texUniformType[3],1);
    }

    virtual void OnUnsetMaterial() {}
};


int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();

    SimpleCallBack* cb = new SimpleCallBack();
    video::E_MATERIAL_TYPE newMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        cb, //! Our Shader Callback
                                                        0); //! No custom user data
    cb->drop();



	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(250.0f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);

        #define kInstanceSquareSize 10
	scene::ISceneNode* instancesToRemove[kInstanceSquareSize*kInstanceSquareSize] = {0};

	//! Test Loading of Obj
    scene::ICPUMesh* cpumesh = smgr->getMesh("../../media/dwarf.x");
    if (cpumesh&&cpumesh->getMeshType()==scene::EMT_ANIMATED_SKINNED)
    {
        scene::ISkinnedMeshSceneNode* anode = 0;
        scene::ICPUSkinnedMesh* animMesh = dynamic_cast<scene::ICPUSkinnedMesh*>(cpumesh);
        scene::IGPUMesh* gpumesh = driver->createGPUMeshFromCPU(cpumesh);
        smgr->getMeshCache()->removeMesh(cpumesh); //drops hierarchy

        for (size_t x=0; x<kInstanceSquareSize; x++)
        for (size_t z=0; z<kInstanceSquareSize; z++)
        {
            instancesToRemove[x+kInstanceSquareSize*z] = anode = smgr->addSkinnedMeshSceneNode(static_cast<scene::IGPUSkinnedMesh*>(gpumesh));
            anode->setScale(core::vector3df(0.05f));
            anode->setPosition(core::vector3df(x,0.f,z)*4.f);
            anode->setAnimationSpeed(18.f*float(x+1+(z+1)*kInstanceSquareSize)/float(kInstanceSquareSize*kInstanceSquareSize));
            anode->setMaterialType(newMaterialType);
            anode->setMaterialTexture(3,anode->getBonePoseTBO());
        }

        gpumesh->drop();
    }


	uint64_t lastFPSTime = 0;

	while(device->run()&&(!quit))
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream str;
			str << L"Builtin Nodes Demo - Irrlicht Engine [" << driver->getName() << "] FPS:" << driver->getFPS() << " PrimitvesDrawn:" << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.str());
			lastFPSTime = time;
		}
	}

    for (size_t x=0; x<kInstanceSquareSize; x++)
    for (size_t z=0; z<kInstanceSquareSize; z++)
        instancesToRemove[x+kInstanceSquareSize*z]->remove();

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();

	device->drop();

	return 0;
}
#define _IRR_STATIC_LIB_
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"

using namespace irr;
using namespace core;
using namespace scene;


#define kNumHardwareInstancesX 10
#define kNumHardwareInstancesY 20
#define kNumHardwareInstancesZ 30

#define kHardwareInstancesTOTAL (kNumHardwareInstancesX*kNumHardwareInstancesY*kNumHardwareInstancesZ)


const float instanceLoDDistances[] = {8.f,50.f};

bool quit = false;


//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                quit = true;
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};

const char* uniformNames[] =
{
    "ProjViewWorldMat",
    "WorldMat",
    "ViewWorldMat",
    "eyePos",
    "LoDInvariantMinEdge",
    "LoDInvariantBBoxCenter",
    "LoDInvariantMaxEdge",
    "instanceLoDDistancesSQ"
};

enum E_UNIFORM
{
    EU_PROJ_VIEW_WORLD_MAT = 0,
    EU_WORLD_MAT,
    EU_VIEW_WORLD_MAT,
    EU_EYE_POS,
    EU_LOD_INVARIANT_MIN_EDGE,
    EU_LOD_INVARIANT_BBOX_CENTER,
    EU_LOD_INVARIANT_MAX_EDGE,
    EU_INSTANCE_LOD_DISTANCE_SQ,
    EU_COUNT
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    video::E_MATERIAL_TYPE currentMat;
    int32_t uniformLocation[video::EMT_COUNT+2][EU_COUNT];
    video::E_SHADER_CONSTANT_TYPE uniformType[video::EMT_COUNT+2][EU_COUNT];
    float currentLodPass;
public:
    core::aabbox3df instanceLoDInvariantBBox;

    SimpleCallBack()
    {
        for (size_t i=0; i<EU_COUNT; i++)
        for (size_t j=0; j<video::EMT_COUNT+2; j++)
            uniformLocation[j][i] = -1;
    }

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        for (size_t i=0; i<constants.size(); i++)
        for (size_t j=0; j<EU_COUNT; j++)
        {
            if (constants[i].name==uniformNames[j])
            {
                uniformLocation[materialType][j] = constants[i].location;
                uniformType[materialType][j] = constants[i].type;
                break;
            }
        }
    }

    virtual void OnSetMaterial(video::IMaterialRendererServices* services, const video::SMaterial& material, const video::SMaterial& lastMaterial)
    {
        currentMat = material.MaterialType;
        currentLodPass = material.MaterialTypeParam;
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        if (uniformLocation[currentMat][EU_PROJ_VIEW_WORLD_MAT]>=0)
            services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),uniformLocation[currentMat][EU_PROJ_VIEW_WORLD_MAT],uniformType[currentMat][EU_PROJ_VIEW_WORLD_MAT],1);
        if (uniformLocation[currentMat][EU_VIEW_WORLD_MAT]>=0)
            services->setShaderConstant(services->getVideoDriver()->getTransform(video::E4X3TS_WORLD_VIEW).pointer(),uniformLocation[currentMat][EU_VIEW_WORLD_MAT],uniformType[currentMat][EU_VIEW_WORLD_MAT],1);
        if (uniformLocation[currentMat][EU_WORLD_MAT]>=0)
            services->setShaderConstant(services->getVideoDriver()->getTransform(video::E4X3TS_WORLD).pointer(),uniformLocation[currentMat][EU_WORLD_MAT],uniformType[currentMat][EU_WORLD_MAT],1);

        if (uniformLocation[currentMat][EU_EYE_POS]>=0)
        {
            core::vectorSIMDf eyePos;
            eyePos.set(services->getVideoDriver()->getTransform(video::E4X3TS_VIEW_INVERSE).getTranslation());
            services->setShaderConstant(eyePos.pointer,uniformLocation[currentMat][EU_EYE_POS],uniformType[currentMat][EU_EYE_POS],1);
        }

        if (uniformLocation[currentMat][EU_LOD_INVARIANT_BBOX_CENTER]>=0)
        {
            services->setShaderConstant(&instanceLoDInvariantBBox.MinEdge,uniformLocation[currentMat][EU_LOD_INVARIANT_MIN_EDGE],uniformType[currentMat][EU_LOD_INVARIANT_MIN_EDGE],1);
            core::vector3df centre = instanceLoDInvariantBBox.getCenter();
            services->setShaderConstant(&centre,uniformLocation[currentMat][EU_LOD_INVARIANT_BBOX_CENTER],uniformType[currentMat][EU_LOD_INVARIANT_BBOX_CENTER],1);
            services->setShaderConstant(&instanceLoDInvariantBBox.MaxEdge,uniformLocation[currentMat][EU_LOD_INVARIANT_MAX_EDGE],uniformType[currentMat][EU_LOD_INVARIANT_MAX_EDGE],1);
        }


        if (uniformLocation[currentMat][EU_INSTANCE_LOD_DISTANCE_SQ]>=0)
        {
            float distancesSQ[2];
            distancesSQ[0] = instanceLoDDistances[0]*instanceLoDDistances[0];
            distancesSQ[1] = instanceLoDDistances[1]*instanceLoDDistances[1];
            services->setShaderConstant(distancesSQ,uniformLocation[currentMat][EU_INSTANCE_LOD_DISTANCE_SQ],uniformType[currentMat][EU_INSTANCE_LOD_DISTANCE_SQ],1);
        }
    }

    virtual void OnUnsetMaterial() {}
};


 IGPUMeshDataFormatDesc* vaoSetupOverride(ISceneManager* smgr, video::IGPUBuffer* instanceDataBuffer, const size_t& dataSizePerInstanceOutput, const scene::IGPUMeshDataFormatDesc* oldVAO, void* userData)
 {
    video::IVideoDriver* driver = smgr->getVideoDriver();
    scene::IGPUMeshDataFormatDesc* vao = driver->createGPUMeshDataFormatDesc();

    //
    for (size_t k=0; k<EVAI_COUNT; k++)
    {
        E_VERTEX_ATTRIBUTE_ID attrId = (E_VERTEX_ATTRIBUTE_ID)k;
        if (!oldVAO->getMappedBuffer(attrId))
            continue;

        vao->mapVertexAttrBuffer(const_cast<video::IGPUBuffer*>(oldVAO->getMappedBuffer(attrId)),attrId,oldVAO->getAttribComponentCount(attrId),oldVAO->getAttribType(attrId),
                                 oldVAO->getMappedBufferStride(attrId),oldVAO->getMappedBufferOffset(attrId),oldVAO->getAttribDivisor(attrId));
    }

    // I know what attributes are unused in my mesh and I've set up the shader to use thse as instance data
    vao->mapVertexAttrBuffer(instanceDataBuffer,EVAI_ATTR4,ECPA_FOUR,ECT_FLOAT,28*sizeof(float),0,1);
    vao->mapVertexAttrBuffer(instanceDataBuffer,EVAI_ATTR5,ECPA_FOUR,ECT_FLOAT,28*sizeof(float),4*sizeof(float),1);
    vao->mapVertexAttrBuffer(instanceDataBuffer,EVAI_ATTR6,ECPA_FOUR,ECT_FLOAT,28*sizeof(float),8*sizeof(float),1);
    vao->mapVertexAttrBuffer(instanceDataBuffer,EVAI_ATTR2,ECPA_FOUR,ECT_FLOAT,28*sizeof(float),12*sizeof(float),1);

    vao->mapVertexAttrBuffer(instanceDataBuffer,EVAI_ATTR7,ECPA_THREE,ECT_FLOAT,28*sizeof(float),16*sizeof(float),1);
    vao->mapVertexAttrBuffer(instanceDataBuffer,EVAI_ATTR8,ECPA_THREE,ECT_FLOAT,28*sizeof(float),19*sizeof(float),1);
    vao->mapVertexAttrBuffer(instanceDataBuffer,EVAI_ATTR9,ECPA_THREE,ECT_FLOAT,28*sizeof(float),22*sizeof(float),1);
    vao->mapVertexAttrBuffer(instanceDataBuffer,EVAI_ATTR10,ECPA_THREE,ECT_FLOAT,28*sizeof(float),25*sizeof(float),1);


    if (oldVAO->getIndexBuffer())
        vao->mapIndexBuffer(const_cast<video::IGPUBuffer*>(oldVAO->getIndexBuffer()));

    return vao;
 }



void CPUCullingFunc(uint8_t** outputPtrs, const size_t& outputDataStride, const core::aabbox3df& LoDInvariantBBox, const size_t& instanceCount,
                    const core::matrix4x3& AbsoluteTransformation, const uint8_t* instanceData, const size_t& instanceDataStride, scene::ISceneManager* SceneManager, void* userData)
{
    video::IVideoDriver* driver = SceneManager->getVideoDriver();

    core::matrix4x3 ViewWorldMat = concatenateBFollowedByA(driver->getTransform(irr::video::E4X3TS_VIEW),AbsoluteTransformation);
    core::matrix4 ProjViewWorldMat = concatenateBFollowedByA(driver->getTransform(irr::video::EPTS_PROJ_VIEW),AbsoluteTransformation);
    float ViewNormalMat[9];
    ViewWorldMat.getSub3x3InverseTranspose(ViewNormalMat);
    core::vectorSIMDf eyePos;
    eyePos.set(driver->getTransform(video::E4X3TS_VIEW_INVERSE).getTranslation());

    core::vectorSIMDf LoDInvariantBBoxCenter;
    LoDInvariantBBoxCenter.set(LoDInvariantBBox.getCenter());


    for (size_t i=0; i<instanceCount; i++)
    {
        core::matrix4x3 instanceTform = *reinterpret_cast<const core::matrix4x3*>(instanceData+instanceDataStride*i);

        core::vectorSIMDf instancePos;
        instanceTform.transformVect(instancePos.pointer,LoDInvariantBBoxCenter.pointer);
        AbsoluteTransformation.transformVect(instancePos.pointer);

        core::vectorSIMDf eyeToInstance = instancePos-eyePos;
        float distanceToInstanceSQ = dot(eyeToInstance,eyeToInstance).X;

        uint32_t instanceLoD;
        if (distanceToInstanceSQ<instanceLoDDistances[0]*instanceLoDDistances[0])
            instanceLoD = 0;
        else if (distanceToInstanceSQ<instanceLoDDistances[1]*instanceLoDDistances[1])
            instanceLoD = 1;
        else
            continue;

        core::matrix4 instanceWorldViewProjMat = concatenateBFollowedByA(ProjViewWorldMat,instanceTform);

        ///Do frustum Culling
        if (!instanceWorldViewProjMat.isBoxInsideFrustum(LoDInvariantBBox))
            continue;


        *reinterpret_cast<core::matrix4*>(outputPtrs[instanceLoD]) = instanceWorldViewProjMat;
\endcode  OLD EXAMPLE LEFTOVER, just to show normal matrix is still there
        const float* gNormalMat = reinterpret_cast<const float*>(instanceData+instanceDataStride*i+48);
        *reinterpret_cast<core::vector3df*>(outputPtrs[instanceLoD]+64+ 0) = reinterpret_cast<core::vector3df*>(ViewNormalMat)[0]*gNormalMat[0]+reinterpret_cast<core::vector3df*>(ViewNormalMat)[1]*gNormalMat[1]+reinterpret_cast<core::vector3df*>(ViewNormalMat)[2]*gNormalMat[2];
        *reinterpret_cast<core::vector3df*>(outputPtrs[instanceLoD]+64+12) = reinterpret_cast<core::vector3df*>(ViewNormalMat)[0]*gNormalMat[3]+reinterpret_cast<core::vector3df*>(ViewNormalMat)[1]*gNormalMat[4]+reinterpret_cast<core::vector3df*>(ViewNormalMat)[2]*gNormalMat[5];
        *reinterpret_cast<core::vector3df*>(outputPtrs[instanceLoD]+64+24) = reinterpret_cast<core::vector3df*>(ViewNormalMat)[0]*gNormalMat[6]+reinterpret_cast<core::vector3df*>(ViewNormalMat)[1]*gNormalMat[7]+reinterpret_cast<core::vector3df*>(ViewNormalMat)[2]*gNormalMat[8];
\code
        *reinterpret_cast<core::matrix4x3*>(outputPtrs[instanceLoD]+64) = concatenateBFollowedByA(ViewWorldMat,instanceTform);

        outputPtrs[instanceLoD] += outputDataStride;
    }
}

int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();

    SimpleCallBack* cb = new SimpleCallBack();
    video::E_MATERIAL_TYPE newMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        cb, //! Our Shader Callback
                                                        0); //! No custom user data
    cb->drop();



	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(100.0f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);

	//! Test Loading of Obj
    scene::ICPUMesh* cpumesh = smgr->getMesh("../../media/cow.obj");
    scene::ICPUMesh* cpumesh2 = smgr->getMesh("../../media/yellowflower.obj");
    if (!cpumesh||!cpumesh2)
        return 0;

    scene::IGPUMesh* gpumesh = driver->createGPUMeshFromCPU(dynamic_cast<scene::SCPUMesh*>(cpumesh));
    scene::IGPUMesh* gpumesh2 = driver->createGPUMeshFromCPU(dynamic_cast<scene::SCPUMesh*>(cpumesh2));
    smgr->getMeshCache()->removeMesh(cpumesh);
    smgr->getMeshCache()->removeMesh(cpumesh2);
    for (size_t i=0; i<gpumesh->getMeshBufferCount(); i++)
        gpumesh->getMeshBuffer(i)->getMaterial().MaterialType = (video::E_MATERIAL_TYPE)newMaterialType;
    for (size_t i=0; i<gpumesh2->getMeshBufferCount(); i++)
        gpumesh2->getMeshBuffer(i)->getMaterial().MaterialType = (video::E_MATERIAL_TYPE)newMaterialType;


    video::SMaterial cullingXFormFeedbackShader;
    const char* xformFeedbackOutputs[] =
    {
        "outLoD0_worldViewProjMatCol0",
        "outLoD0_worldViewProjMatCol1",
        "outLoD0_worldViewProjMatCol2",
        "outLoD0_worldViewProjMatCol3",
        "outLoD0_worldViewMatCol0",
        "outLoD0_worldViewMatCol1",
        "outLoD0_worldViewMatCol2",
        "outLoD0_worldViewMatCol3",
        "gl_NextBuffer",
        "outLoD1_worldViewProjMatCol0",
        "outLoD1_worldViewProjMatCol1",
        "outLoD1_worldViewProjMatCol2",
        "outLoD1_worldViewProjMatCol3",
        "outLoD1_worldViewMatCol0",
        "outLoD1_worldViewMatCol1",
        "outLoD1_worldViewMatCol2",
        "outLoD1_worldViewMatCol3"
    };
    cullingXFormFeedbackShader.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../culling.vert","","","../culling.geom","",3,video::EMT_SOLID,cb,xformFeedbackOutputs,17);
    cullingXFormFeedbackShader.RasterizerDiscard = true;


    //! The inside of the loop resets and recreates the instancedNode and instances many times to stress-test for GPU-Memory leaks

	uint64_t lastFPSTime = 0;
\endcode 
	while(device->run())
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

        IMeshSceneNodeInstanced* node = smgr->addMeshSceneNodeInstanced(smgr->getRootSceneNode());
        node->setBBoxUpdateEnabled();
        node->setAutomaticCulling(scene::EAC_FRUSTUM_BOX);
        {
            std::vector<scene::IMeshSceneNodeInstanced::MeshLoD> LevelsOfDetail;
            LevelsOfDetail.resize(2);
            LevelsOfDetail[0].mesh = gpumesh;
            LevelsOfDetail[0].lodDistance = instanceLoDDistances[0];
            LevelsOfDetail[1].mesh = gpumesh2;
            LevelsOfDetail[1].lodDistance = instanceLoDDistances[1];

            node->setLoDMeshes(LevelsOfDetail,37*sizeof(float),cullingXFormFeedbackShader,vaoSetupOverride,NULL,0,CPUCullingFunc);
            cb->instanceLoDInvariantBBox = node->getLoDInvariantBBox();
        }

        //! Special Juice for INSTANCING
        for (size_t z=0; z<kNumHardwareInstancesZ; z++)
        for (size_t y=0; y<kNumHardwareInstancesY; y++)
        for (size_t x=0; x<kNumHardwareInstancesX; x++)
        {
            core::matrix4x3 mat;
            mat.setTranslation(core::vector3df(x,y,z)*2.f);
            node->addInstance(mat);
        }

        srand(6945);

        bool alreadyKilled[kHardwareInstancesTOTAL];
        memset(alreadyKilled,0,kHardwareInstancesTOTAL*sizeof(bool));
        uint32_t* instancesToRemove = new uint32_t[kHardwareInstancesTOTAL];
        size_t j=0;
        for (size_t i=0; i<600; i++)
        {
            uint32_t instanceID = rand()%kHardwareInstancesTOTAL;
            if (alreadyKilled[instanceID])
                continue;

            instancesToRemove[j++] = instanceID;
            alreadyKilled[instanceID] = true;
        }
        node->removeInstances(j,instancesToRemove);

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();

        j=0;
        for (size_t i=0; i<kHardwareInstancesTOTAL; i++)
        {
            if (alreadyKilled[i])
                continue;

            instancesToRemove[j++] = i;
            alreadyKilled[i] = true;
        }
        node->removeInstances(j,instancesToRemove);
        delete [] instancesToRemove;
        node->remove();

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			stringw str = L"Builtin Nodes Demo - Irrlicht Engine [";
			str += driver->getName();
			str += "] FPS:";
			str += driver->getFPS();
			str += " PrimitvesDrawn:";
			str += driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.c_str());
			lastFPSTime = time;
		}
	}
	\code

        IMeshSceneNodeInstanced* node = smgr->addMeshSceneNodeInstanced(smgr->getRootSceneNode());
        node->setBBoxUpdateEnabled();
        node->setAutomaticCulling(scene::EAC_FRUSTUM_BOX);
        {
            std::vector<scene::IMeshSceneNodeInstanced::MeshLoD> LevelsOfDetail;
            LevelsOfDetail.resize(2);
            LevelsOfDetail[0].mesh = gpumesh;
            LevelsOfDetail[0].lodDistance = instanceLoDDistances[0];
            LevelsOfDetail[1].mesh = gpumesh2;
            LevelsOfDetail[1].lodDistance = instanceLoDDistances[1];

            bool success = node->setLoDMeshes(LevelsOfDetail,28*sizeof(float),cullingXFormFeedbackShader,vaoSetupOverride,2,NULL,0,CPUCullingFunc);
            assert(success);
            node->setGPUCullingThresholdMultiplier(0.25f);
            cb->instanceLoDInvariantBBox = node->getLoDInvariantBBox();
        }

        //! Special Juice for INSTANCING
        for (size_t z=0; z<kNumHardwareInstancesZ; z++)
        for (size_t y=0; y<kNumHardwareInstancesY; y++)
        for (size_t x=0; x<kNumHardwareInstancesX; x++)
        {
            core::matrix4x3 mat;
            mat.setTranslation(core::vector3df(x,y,z)*2.f);
            node->addInstance(mat);
        }

        srand(6945);

        bool alreadyKilled[kHardwareInstancesTOTAL];
        memset(alreadyKilled,0,kHardwareInstancesTOTAL*sizeof(bool));
        uint32_t* instancesToRemove = new uint32_t[kHardwareInstancesTOTAL];
        size_t j=0;
        for (size_t i=0; i<600; i++)
        {
            uint32_t instanceID = rand()%kHardwareInstancesTOTAL;
            if (alreadyKilled[instanceID])
                continue;

            instancesToRemove[j++] = instanceID;
            alreadyKilled[instanceID] = true;
        }
        node->removeInstances(j,instancesToRemove);


        j=0;
        for (size_t i=0; i<kHardwareInstancesTOTAL; i++)
        {
            if (alreadyKilled[i])
                continue;

            instancesToRemove[j++] = i;
            alreadyKilled[i] = true;
        }

	while(device->run()&&(!quit))
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream str;
			str << L"Builtin Nodes Demo - Irrlicht Engine [" << driver->getName() << "] FPS:" << driver->getFPS() << " PrimitvesDrawn:" << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.str());
			lastFPSTime = time;
		}
	}

        node->removeInstances(j,instancesToRemove);
        delete [] instancesToRemove;
        node->remove();

    gpumesh->drop();
    gpumesh2->drop();

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();


	device->drop();

	return 0;
}
#include <irrlicht.h>
#include "driverChoice.h"

#include "../source/Irrlicht/CGeometryCreator.h"
#include "../source/Irrlicht/COpenGLExtensionHandler.h"
#include "../source/Irrlicht/COpenGLBuffer.h"

using namespace irr;
using namespace core;
using namespace video;


#define kNumHardwareInstancesX 30
#define kNumHardwareInstancesY 40
#define kNumHardwareInstancesZ 50

#define kHardwareInstancesTOTAL (kNumHardwareInstancesX*kNumHardwareInstancesY*kNumHardwareInstancesZ)




//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                exit(0);
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t cameraDirUniformLocation;
    video::E_SHADER_CONSTANT_TYPE cameraDirUniformType;
public:
    SimpleCallBack() : cameraDirUniformLocation(-1), cameraDirUniformType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        //! Normally we'd iterate through the array and check our actual constant names before mapping them to locations but oh well
        cameraDirUniformLocation = constants[0].location;
        cameraDirUniformType = constants[0].type;
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),cameraDirUniformLocation,cameraDirUniformType,1);
    }

    virtual void OnUnsetMaterial() {}
};


void APIENTRY openGLCBFunc(GLenum source, GLenum type, GLuint id, GLenum severity,
                           GLsizei length, const GLchar* message, const void* userParam)
{
    core::stringc outStr;
    switch (severity)
    {
        //case GL_DEBUG_SEVERITY_HIGH:
        case GL_DEBUG_SEVERITY_HIGH_ARB:
            outStr = "[H.I.G.H]";
            break;
        //case GL_DEBUG_SEVERITY_MEDIUM:
        case GL_DEBUG_SEVERITY_MEDIUM_ARB:
            outStr = "[MEDIUM]";
            break;
        //case GL_DEBUG_SEVERITY_LOW:
        case GL_DEBUG_SEVERITY_LOW_ARB:
            outStr = "[  LOW  ]";
            break;
        case GL_DEBUG_SEVERITY_NOTIFICATION:
            outStr = "[  LOW  ]";
            break;
        default:
            outStr = "[UNKNOWN]";
            break;
    }
    switch (source)
    {
        //case GL_DEBUG_SOURCE_API:
        case GL_DEBUG_SOURCE_API_ARB:
            switch (type)
            {
                //case GL_DEBUG_TYPE_ERROR:
                case GL_DEBUG_TYPE_ERROR_ARB:
                    outStr += "[OPENGL  API ERROR]\t\t";
                    break;
                //case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:
                case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB:
                    outStr += "[OPENGL  DEPRECATED]\t\t";
                    break;
                //case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:
                case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB:
                    outStr += "[OPENGL   UNDEFINED]\t\t";
                    break;
                //case GL_DEBUG_TYPE_PORTABILITY:
                case GL_DEBUG_TYPE_PORTABILITY_ARB:
                    outStr += "[OPENGL PORTABILITY]\t\t";
                    break;
                //case GL_DEBUG_TYPE_PERFORMANCE:
                case GL_DEBUG_TYPE_PERFORMANCE_ARB:
                    outStr += "[OPENGL PERFORMANCE]\t\t";
                    break;
                default:
                    outStr += "[OPENGL       OTHER]\t\t";
                    ///return;
                    break;
            }
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_SHADER_COMPILER:
        case GL_DEBUG_SOURCE_SHADER_COMPILER_ARB:
            outStr += "[SHADER]\t\t";
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_WINDOW_SYSTEM:
        case GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB:
            outStr += "[WINDOW SYS]\t\t";
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_THIRD_PARTY:
        case GL_DEBUG_SOURCE_THIRD_PARTY_ARB:
            outStr += "[3RDPARTY]\t\t";
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_APPLICATION:
        case GL_DEBUG_SOURCE_APPLICATION_ARB:
            outStr += "[APP]\t\t";
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_OTHER:
        case GL_DEBUG_SOURCE_OTHER_ARB:
            outStr += "[OTHER]\t\t";
            outStr += message;
            break;
        default:
            break;
    }
    outStr += "\n";
    printf("%s",outStr.c_str());
}

int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();
    if (COpenGLExtensionHandler::FeatureAvailable[COpenGLExtensionHandler::IRR_KHR_debug])
    {
        glEnable(GL_DEBUG_OUTPUT);
        //glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
        COpenGLExtensionHandler::pGlDebugMessageControl(GL_DONT_CARE,GL_DONT_CARE,GL_DONT_CARE,0,NULL,true);

        COpenGLExtensionHandler::pGlDebugMessageCallback(openGLCBFunc,NULL);
    }
    else
    {
        //glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB);
        COpenGLExtensionHandler::pGlDebugMessageControlARB(GL_DONT_CARE,GL_DONT_CARE,GL_DONT_CARE,0,NULL,true);

        COpenGLExtensionHandler::pGlDebugMessageCallbackARB(openGLCBFunc,NULL);
    }

    SimpleCallBack* cb = new SimpleCallBack();
    video::E_MATERIAL_TYPE newMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        cb, //! Our Shader Callback
                                                        0); //! No custom user data
    cb->drop();



	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(100.0f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);


    core::vectorSIMDf instanceAngularSpeed[kNumHardwareInstancesZ][kNumHardwareInstancesY][kNumHardwareInstancesX];
    core::vector3df instancePositions[kNumHardwareInstancesZ][kNumHardwareInstancesY][kNumHardwareInstancesX];
    core::vector3df instanceNewPositions[kNumHardwareInstancesZ][kNumHardwareInstancesY][kNumHardwareInstancesX];

    video::IGPUBuffer* instancePosBuf;
    scene::IGPUMesh* gpumesh = smgr->getGeometryCreator()->createCubeMeshGPU(driver,core::vector3df(1.f));

        smgr->addMeshSceneNode(gpumesh,0,-1)->setMaterialType(newMaterialType);
        gpumesh->drop();

        //! Special Juice for INSTANCING
        for (size_t z=0; z<kNumHardwareInstancesZ; z++)
        for (size_t y=0; y<kNumHardwareInstancesY; y++)
        {
            srand(device->getTimer()->getRealTime64());
            for (size_t x=0; x<kNumHardwareInstancesX; x++)
            {
                instancePositions[z][y][x].set(x,y,z);
                instancePositions[z][y][x] *= 2.f;
                instanceAngularSpeed[z][y][x].set(rand()%16741,rand()%16741,rand()%16741);
                instanceAngularSpeed[z][y][x] /= 16741.f;
            }
        }

        //instancePosBuf = driver->createGPUBuffer(sizeof(core::vector3df)*kHardwareInstancesTOTAL,instancePositions,true);
        instancePosBuf = driver->createPersistentlyMappedBuffer(sizeof(core::vector3df)*kHardwareInstancesTOTAL,instancePositions,EGBA_WRITE,false,false);
        void* ptr;
        GLuint handle;
        {
            COpenGLBuffer* bufGL = dynamic_cast<COpenGLBuffer*>(instancePosBuf);
            handle = bufGL->getOpenGLName();
            COpenGLExtensionHandler::extGlUnmapNamedBuffer(handle);

            ptr = COpenGLExtensionHandler::extGlMapNamedBufferRange(handle,0,instancePosBuf->getSize(),GL_MAP_WRITE_BIT|GL_MAP_PERSISTENT_BIT|GL_MAP_FLUSH_EXPLICIT_BIT);
        }
        gpumesh->getMeshBuffer(0)->getMeshDataAndFormat()->mapVertexAttrBuffer(instancePosBuf,scene::EVAI_ATTR2,scene::ECPA_THREE,scene::ECT_FLOAT,12,0,1);
        instancePosBuf->drop();

        //set instance count on mesh
        gpumesh->getMeshBuffer(0)->setInstanceCount(kHardwareInstancesTOTAL);

        //new bbox is necessary
        core::aabbox3df newBBox = gpumesh->getMeshBuffer(0)->getBoundingBox();
        newBBox.MaxEdge += vector3df(kNumHardwareInstancesX,kNumHardwareInstancesY,kNumHardwareInstancesZ)*2.f;
        newBBox.MaxEdge -= 2.f;
        gpumesh->getMeshBuffer(0)->setBoundingBox(newBBox);
        gpumesh->setBoundingBox(newBBox);



	uint64_t lastFPSTime = 0;

	while(device->run())
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

		float timeLocal = device->getTimer()->getTime();
        for (size_t z=0; z<kNumHardwareInstancesZ; z++)
        for (size_t y=0; y<kNumHardwareInstancesY; y++)
        for (size_t x=0; x<kNumHardwareInstancesX; x++)
		{
		    core::vectorSIMDf rot = instanceAngularSpeed[z][y][x]*timeLocal;
		    rot /= 1000.f;
		    instanceNewPositions[z][y][x] = instancePositions[z][y][x]+core::vector3df(cosf(rot.X),cosf(rot.Y),cosf(rot.Z));
		}
		///case 0:
		//instancePosBuf->updateSubRange(0,instancePosBuf->getSize(),instanceNewPositions);
		///case 1:
        memcpy(ptr,instanceNewPositions,instancePosBuf->getSize());
        COpenGLExtensionHandler::extGlFlushMappedNamedBufferRange(handle,0,instancePosBuf->getSize());

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			stringw str;/**
			str = L"Builtin Nodes Demo - Irrlicht Engine [";
			str += driver->getName();
			str += "] FPS:";
			str += driver->getFPS();
			str += " PrimitvesDrawn:";
			str += driver->getPrimitiveCountDrawn();\code

			device->setWindowCaption(str.c_str());
			lastFPSTime = time;
		}
	}
    COpenGLExtensionHandler::extGlUnmapNamedBuffer(handle);

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();
	device->sleep(3000);

	device->drop();

	return 0;
}
#include <irrlicht.h>
#include "driverChoice.h"

#include "IGPUTransientBuffer.h"

using namespace irr;
using namespace core;


#define kNumHardwareInstancesX 10
#define kNumHardwareInstancesY 20
#define kNumHardwareInstancesZ 30

#define kHardwareInstancesTOTAL (kNumHardwareInstancesX*kNumHardwareInstancesY*kNumHardwareInstancesZ)




//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                exit(0);
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};



int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
    params.AntiAlias = 0; //No AA, yet
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();

    size_t allocsPerFrame = 10000;
    size_t allocSize = 128;



	scene::ISceneManager* smgr = device->getSceneManager();
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);


    video::IGPUTransientBuffer* buffer = video::IGPUTransientBuffer::createMappedTransientBuffer(driver,0x1000000u,video::EGBA_WRITE,false,true,true,false);


	uint64_t lastFPSTime = 0;

	while(device->run())
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

		uint64_t startTime = device->getTimer()->getRealTime();
        for (size_t i=0; i<allocsPerFrame; i++)
        {
            size_t offset;
            #define ALIGNMENT 32
            if (buffer->Alloc(offset,allocSize,ALIGNMENT,video::IGPUTransientBuffer::EWP_DONT_WAIT,true)==video::IGPUTransientBuffer::EARS_SUCCESS)
            {
                buffer->Commit(offset,offset+allocSize);
                buffer->fenceRangeUsedByGPU(offset,offset+allocSize);
                buffer->Free(offset,offset+allocSize);
            }
        }

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			stringw str = L"Builtin Nodes Demo - Irrlicht Engine [";
			str += driver->getName();
			str += "] FPS:";
			str += driver->getFPS();

			device->setWindowCaption(str.c_str());
			lastFPSTime = time;
		}
	}
	buffer->drop();

	device->drop();

	return 0;
}
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"

using namespace irr;
using namespace core;

//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                exit(0);
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};



int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();

    //! First need to make a material other than default to be able to draw with custom shader
    video::SMaterial material;
    material.BackfaceCulling = false; //! Triangles will be visible from both sides



	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(100.0f);
    smgr->setActiveCamera(camera);
	//device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);


    core::SCollisionEngine* gCollEng = new core::SCollisionEngine();

	//! Test Creation Of Builtin
	scene::IMeshSceneNode* cube = dynamic_cast<scene::IMeshSceneNode*>(smgr->addCubeSceneNode(1.f,0,-1));
    cube->setRotation(core::vector3df(45,20,15));
    cube->setMaterialFlag(video::EMF_BACK_FACE_CULLING,false);
    cube->getMaterial(0).setTexture(0,driver->getTexture("../../media/irrlicht2_dn.jpg"));
	core::SCompoundCollider* compound = new core::SCompoundCollider();
	compound->AddBox(core::SAABoxCollider(cube->getBoundingBox()));
	core::SColliderData collData;
	collData.attachedNode = cube;
	compound->setColliderData(collData);
    gCollEng->addCompoundCollider(compound);
    compound->drop();

	scene::IMeshSceneNode* sphere = dynamic_cast<scene::IMeshSceneNode*>(smgr->addSphereSceneNode(2,32));
    sphere->setMaterialFlag(video::EMF_BACK_FACE_CULLING,false);
    sphere->getMaterial(0).setTexture(0,driver->getTexture("../../media/skydome.jpg"));
    sphere->getMaterial(0).MaterialType = material.MaterialType;
    sphere->setPosition(core::vector3df(4,0,0));
	compound = new core::SCompoundCollider();
	compound->AddEllipsoid(core::vectorSIMDf(),core::vectorSIMDf(2.f));
	collData.attachedNode = sphere;
	compound->setColliderData(collData);
    gCollEng->addCompoundCollider(compound);
    compound->drop();

	uint64_t lastFPSTime = 0;

    core::SColliderData hitPointData;
	while(device->run())
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();

		driver->endScene();

        cube->setMaterialFlag(video::EMF_WIREFRAME,false);
        sphere->setMaterialFlag(video::EMF_WIREFRAME,false);
        core::vectorSIMDf origin,dir;
        origin.set(camera->getAbsolutePosition());
        dir.set(camera->getTarget());
        dir -= origin;
        dir = core::normalize(dir);
        float outLen;
        if (gCollEng->FastCollide(hitPointData,outLen,origin,dir,10.f))
        {
            if (hitPointData.attachedNode)
                hitPointData.attachedNode->setMaterialFlag(video::EMF_WIREFRAME,true);
        }

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			stringw str;
		    /**
			stringw str = L"Builtin Nodes Demo - Irrlicht Engine [";
			str += driver->getName();
			str += "] FPS:";
			str += driver->getFPS();
			str += " PrimitvesDrawn:";
			str += driver->getPrimitiveCountDrawn();
**/
			device->setWindowCaption(str.c_str());
			lastFPSTime = time;
		}
	}

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();
	device->sleep(3000);

	device->drop();

	return 0;
}
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"

using namespace irr;
using namespace core;

vector3df camPos;
array<vectorSIMDf> controlPts;
ISpline* spline = NULL;

//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver() : wasLeftPressedBefore(false)
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
                case irr::KEY_KEY_Q: // switch wire frame mode
                    exit(0);
                    return true;
                    break;
                case KEY_KEY_T:
                    {
                        if (spline)
                            delete spline;
                        spline = NULL;
                        if (controlPts.size())
                            spline = new CLinearSpline(controlPts.pointer(),controlPts.size());

                        return true;
                    }
                    break;
                case KEY_KEY_Y:
                    {
                        if (spline)
                            delete spline;
                        spline = NULL;
                        if (controlPts.size())
                            spline = new CLinearSpline(controlPts.pointer(),controlPts.size(),true); //make it loop

                        return true;
                    }
                    break;
                case KEY_KEY_U:
                    {
                        if (spline)
                            delete spline;
                        spline = NULL;
                        if (controlPts.size())
                        {
                            spline = new irr::core::CQuadraticBSpline(controlPts.pointer(),controlPts.size(),false);
                            printf("Total Len %f\n",spline->getSplineLength());
                            for (size_t i=0; i<spline->getSegmentCount(); i++)
                                printf("Seg: %d \t\t %f\n",i,spline->getSegmentLength(i));
                        }

                        return true;
                    }
                    break;
                case KEY_KEY_I:
                    {
                        if (spline)
                            delete spline;
                        spline = NULL;
                        if (controlPts.size())
                        {
                            spline = new CQuadraticBSpline(controlPts.pointer(),controlPts.size(),true); //make it a loop
                            printf("Total Len %f\n",spline->getSplineLength());
                            for (size_t i=0; i<spline->getSegmentCount(); i++)
                                printf("Seg: %d \t\t %f\n",i,spline->getSegmentLength(i));
                        }

                        return true;
                    }
                case KEY_KEY_O:
                    {
                        return true;
                    }
                    break;
                case KEY_KEY_C:
                    {
                        controlPts.clear();
                        return true;
                    }
                    break;
                default:
                    break;
            }
        }
        else if (event.EventType == EET_MOUSE_INPUT_EVENT)
        {
            bool pressed = event.MouseInput.isLeftPressed();
            if (pressed && !wasLeftPressedBefore)
            {
                controlPts.push_back(core::vectorSIMDf(camPos.X,camPos.Y,camPos.Z));
            }
            wasLeftPressedBefore = pressed;
        }

		return false;
	}

private:
    bool wasLeftPressedBefore;
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t mvpUniformLocation;
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
public:
    SimpleCallBack() : mvpUniformLocation(-1), mvpUniformType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        //! Normally we'd iterate through the array and check our actual constant names before mapping them to locations but oh well
        mvpUniformLocation = constants[0].location;
        mvpUniformType = constants[0].type;
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);
    }

    virtual void OnUnsetMaterial() {}
};



int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();
    SimpleCallBack* callBack = new SimpleCallBack();

    //! First need to make a material other than default to be able to draw with custom shader
    video::SMaterial material;
    material.BackfaceCulling = false; //! Triangles will be visible from both sides
    material.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        callBack, //! No Shader Callback (we dont have any constants/uniforms to pass to the shader)
                                                        0); //! No custom user data
    callBack->drop();


	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(100.0f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);


	//! Test Creation Of Builtin
	scene::IMeshSceneNode* cube = dynamic_cast<scene::IMeshSceneNode*>(smgr->addCubeSceneNode(1.f,0,-1));
    cube->setRotation(core::vector3df(45,20,15));
    cube->getMaterial(0).setTexture(0,driver->getTexture("../../media/irrlicht2_dn.jpg"));

	scene::ISceneNode* billboard = smgr->addCubeSceneNode(2.f,0,-1,core::vector3df(0,0,0));
    billboard->getMaterial(0).setTexture(0,driver->getTexture("../../media/wall.jpg"));

    float cubeDistance = 0.f;
    float cubeParameterHint = 0.f;
    uint32_t cubeSegment = 0;

    #define kCircleControlPts 3
    for (size_t i=0; i<kCircleControlPts; i++)
    {
        float x = float(i)*core::PI*2.f/float(kCircleControlPts);
        controlPts.push_back(vectorSIMDf(sin(x),0,-cos(x))*4.f);
    }


	uint64_t lastFPSTime = 0;

	uint64_t lastTime = device->getTimer()->getRealTime();
    uint64_t timeDelta = 0;

	while(device->run())
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,255) );

        uint64_t nowTime = device->getTimer()->getRealTime();
        timeDelta = nowTime-lastTime;
        lastTime = nowTime;

		if (spline)
        {
            vectorSIMDf newPos;
            cubeDistance += float(timeDelta)*0.001f; //1 unit per second
            cubeSegment = spline->getPos(newPos,cubeDistance,cubeSegment,&cubeParameterHint);
            if (cubeSegment>=0xdeadbeefu) //reached end of non-loop, or spline changed
            {
                cubeDistance = 0;
                cubeParameterHint = 0;
                cubeSegment = 0;
                cubeSegment = spline->getPos(newPos,cubeDistance,cubeSegment,&cubeParameterHint);
            }

            vectorSIMDf forwardDir;
            assert(spline->getUnnormDirection_fromParameter(forwardDir,cubeSegment,cubeParameterHint)); //must be TRUE
            forwardDir = normalize(forwardDir); //must normalize after
            vectorSIMDf sideDir = normalize(cross(forwardDir,vectorSIMDf(0,1,0))); // predefined up vector
            vectorSIMDf pseudoUp = cross(sideDir,forwardDir);



            matrix4x3 mat;
            mat.getColumn(0) = reinterpret_cast<vector3df&>(forwardDir);
            mat.getColumn(1) = reinterpret_cast<vector3df&>(pseudoUp);
            mat.getColumn(2) = reinterpret_cast<vector3df&>(sideDir);
            mat.setTranslation(reinterpret_cast<const vector3df&>(newPos));
            cube->setRelativeTransformationMatrix(mat);
        }

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();
        camPos = camera->getAbsolutePosition();

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream str;
			str << L"Builtin Nodes Demo - Irrlicht Engine FPS:" << driver->getFPS() << " PrimitvesDrawn:";
			str << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.str());
			lastFPSTime = time;
		}
	}

    if (spline)
        delete spline;

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();
	device->sleep(3000);

	device->drop();

	return 0;
}
#include <irrlicht.h>
#include "driverChoice.h"
#include "SilverLining.h"
#include "ResourceLoader.h"

#include "../source/Irrlicht/COpenGLDriver.h"

using namespace irr;
using namespace core;
using namespace video;

void APIENTRY openGLCBFunc(GLenum source, GLenum type, GLuint id, GLenum severity,
                           GLsizei length, const GLchar* message, const void* userParam)
{
    core::stringc outStr;
    switch (severity)
    {
        //case GL_DEBUG_SEVERITY_HIGH:
        case GL_DEBUG_SEVERITY_HIGH_ARB:
            outStr = "[H.I.G.H]";
            break;
        //case GL_DEBUG_SEVERITY_MEDIUM:
        case GL_DEBUG_SEVERITY_MEDIUM_ARB:
            outStr = "[MEDIUM]";
            break;
        //case GL_DEBUG_SEVERITY_LOW:
        case GL_DEBUG_SEVERITY_LOW_ARB:
            return;
            outStr = "[  LOW  ]";
            break;
        case GL_DEBUG_SEVERITY_NOTIFICATION:
            return;
            outStr = "[  LOW  ]";
            break;
        default:
            outStr = "[UNKNOWN]";
            break;
    }
    switch (source)
    {
        //case GL_DEBUG_SOURCE_API:
        case GL_DEBUG_SOURCE_API_ARB:
            switch (type)
            {
                //case GL_DEBUG_TYPE_ERROR:
                case GL_DEBUG_TYPE_ERROR_ARB:
                    outStr += "[OPENGL  API ERROR]\t\t";
                    break;
                //case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:
                case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB:
                    outStr += "[OPENGL  DEPRECATED]\t\t";
                    break;
                //case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:
                case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB:
                    outStr += "[OPENGL   UNDEFINED]\t\t";
                    break;
                //case GL_DEBUG_TYPE_PORTABILITY:
                case GL_DEBUG_TYPE_PORTABILITY_ARB:
                    outStr += "[OPENGL PORTABILITY]\t\t";
                    break;
                //case GL_DEBUG_TYPE_PERFORMANCE:
                case GL_DEBUG_TYPE_PERFORMANCE_ARB:
                    outStr += "[OPENGL PERFORMANCE]\t\t";
                    break;
                default:
                    outStr += "[OPENGL       OTHER]\t\t";
                    ///return;
                    break;
            }
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_SHADER_COMPILER:
        case GL_DEBUG_SOURCE_SHADER_COMPILER_ARB:
            outStr += "[SHADER]\t\t";
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_WINDOW_SYSTEM:
        case GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB:
            outStr += "[WINDOW SYS]\t\t";
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_THIRD_PARTY:
        case GL_DEBUG_SOURCE_THIRD_PARTY_ARB:
            outStr += "[3RDPARTY]\t\t";
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_APPLICATION:
        case GL_DEBUG_SOURCE_APPLICATION_ARB:
            outStr += "[APP]\t\t";
            outStr += message;
            break;
        //case GL_DEBUG_SOURCE_OTHER:
        case GL_DEBUG_SOURCE_OTHER_ARB:
            outStr += "[OTHER]\t\t";
            outStr += message;
            break;
        default:
            break;
    }
    outStr += "\n";
    printf("%s",outStr.c_str());
}


IrrlichtDevice* device = NULL;


vector3df camPos;
array<vectorSIMDf> controlPts;
ISpline* spline = NULL;

//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver() : wasLeftPressedBefore(false)
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
                case irr::KEY_KEY_Q: // switch wire frame mode
                    device->closeDevice();
                    return true;
                    break;
                case KEY_KEY_T:
                    {
                        if (spline)
                            delete spline;
                        spline = NULL;
                        if (controlPts.size())
                            spline = new CLinearSpline(controlPts.pointer(),controlPts.size());

                        return true;
                    }
                    break;
                case KEY_KEY_Y:
                    {
                        if (spline)
                            delete spline;
                        spline = NULL;
                        if (controlPts.size())
                            spline = new CLinearSpline(controlPts.pointer(),controlPts.size(),true); //make it loop

                        return true;
                    }
                    break;
                case KEY_KEY_U:
                    {
                        if (spline)
                            delete spline;
                        spline = NULL;
                        if (controlPts.size())
                        {
                            spline = new irr::core::CQuadraticBSpline(controlPts.pointer(),controlPts.size(),false);
                            printf("Total Len %f\n",spline->getSplineLength());
                            for (size_t i=0; i<spline->getSegmentCount(); i++)
                                printf("Seg: %d \t\t %f\n",i,spline->getSegmentLength(i));
                        }

                        return true;
                    }
                    break;
                case KEY_KEY_I:
                    {
                        if (spline)
                            delete spline;
                        spline = NULL;
                        if (controlPts.size())
                        {
                            spline = new CQuadraticBSpline(controlPts.pointer(),controlPts.size(),true); //make it a loop
                            printf("Total Len %f\n",spline->getSplineLength());
                            for (size_t i=0; i<spline->getSegmentCount(); i++)
                                printf("Seg: %d \t\t %f\n",i,spline->getSegmentLength(i));
                        }

                        return true;
                    }
                case KEY_KEY_O:
                    {
                        return true;
                    }
                    break;
                case KEY_KEY_C:
                    {
                        controlPts.clear();
                        return true;
                    }
                    break;
                default:
                    break;
            }
        }
        else if (event.EventType == EET_MOUSE_INPUT_EVENT)
        {
            bool pressed = event.MouseInput.isLeftPressed();
            if (pressed && !wasLeftPressedBefore)
            {
                controlPts.push_back(core::vectorSIMDf(camPos.X,camPos.Y,camPos.Z));
            }
            wasLeftPressedBefore = pressed;
        }

		return false;
	}

private:
    bool wasLeftPressedBefore;
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t mvpUniformLocation;
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
public:
    SimpleCallBack() : mvpUniformLocation(-1), mvpUniformType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        //! Normally we'd iterate through the array and check our actual constant names before mapping them to locations but oh well
        mvpUniformLocation = constants[0].location;
        mvpUniformType = constants[0].type;
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);
    }

    virtual void OnUnsetMaterial() {}
};


// All SilverLining objects are in the SilverLining namespace.
using namespace SilverLining;

class SilverLoader : public ResourceLoader
{
    public:
        SilverLoader(io::IFileSystem* fileSystem, const std::string& archivePath) : fSys(fileSystem), resourceArch(NULL)
        {
            fSys->addFileArchive(archivePath.c_str(),false,false,io::EFAT_ZIP,"",&resourceArch);
        }
        virtual                        ~SilverLoader()
        {
            fSys->removeFileArchive(resourceArch);
        }
    /// Sets the path to the SilverLining resources folder, which will be pre-pended to all resource filenames
    /// passed into LoadResource(). This path is also used to locate the renderer DLL's inside the SilverLining
    /// resources folder. It should be called after constructing the ResourceLoader and before calling LoadResource().
        void SILVERLINING_API           SetResourceDirPath(const char *path)
        {
            resDir = path;
        }

    /// Retrieves the path set by SetResourceDirPath().
        const char* SILVERLINING_API    GetResourceDirPath() const
        {
            return resDir.c_str();
        }

    /** Load a resource from mass storage; the default implementation uses the POSIX functions fopen(), fread(), and fclose()
       to do this, but you may override this method to load resources however you wish. The caller is responsible for calling
       FreeResource() when it's done consuming the resource data in order to free its memory.

       \param pathName The path to the desired resource, relative to the location of the resources folder previously specified
       in SetResourceDirPath().
       \param data A reference to a char * that will return the resource's data upon a successful load.
       \param dataLen A reference to an unsigned int that will return the number of bytes loaded upon a successful load.
       \param text True if the resource is a text file, such as a shader. If true, a terminating null character will be appended
       to the resulting data and the file will be opened in text mode.
       \return True if the resource was located and loaded successfully, false otherwise.

       \sa SetResourceDirPath
     \code
        virtual bool SILVERLINING_API   LoadResource(const char *pathName, char*& data, unsigned int& dataLen, bool text)
        {
            if (!resourceArch)
                return false;

            io::IReadFile* file = resourceArch->createAndOpenFile(pathName);
            if (!file)
                return false;

            dataLen = file->getSize();
            if (text)
            {
                data = (char*)malloc(dataLen+1);
                file->read(data,dataLen);
                data[dataLen] = 0;
            }
            else
            {
                data = (char*)malloc(dataLen);
                file->read(data,dataLen);
            }

            file->drop();
            return true;
        }

    /** Frees the resource data memory that was returned from LoadResource(). The data pointer will be invalid following
       this call. \code
        virtual void SILVERLINING_API   FreeResource(char *data)
        {
            free(data);
        }

    /** Retrieves a list of file names within the directory path specified (relative to the resource path specified
       with SetResourceDirPath().
       \param pathName The path to the directory underneath the resources directory. The path to the resources directory will
       be pre-pended to this path.
       \param dirContents A reference that will receive a vector of strings of the file names found inside this path, if any.
       \return True if the path was found and scanned successfully, false otherwise.
     \code
        virtual bool SILVERLINING_API   GetFilesInDirectory(const char *pathName, SL_VECTOR(SL_STRING)& dirContents)
        {
            return false;
        }

    private:
        io::IFileSystem* fSys;
        io::IFileArchive* resourceArch;
        std::string resDir;
};

// Statics and defines for a simple, self-contained demo application
static Atmosphere *atm = 0; // The Atmosphere object is the main interface to SilverLining.
static SilverLoader* silverLoader = 0;
static float aspectRatio, yaw = 0;

// Simulated visibility in meters, for fog effects.
#define kVisibility  20000.0f
// Configure high cirrus clouds.
static void SetupCirrusClouds()
{
    CloudLayer *cirrusCloudLayer;

    cirrusCloudLayer = CloudLayerFactory::Create(CIRRUS_FIBRATUS);
    cirrusCloudLayer->SetBaseAltitude(6000);
    cirrusCloudLayer->SetThickness(0);
    cirrusCloudLayer->SetBaseLength(100000);
    cirrusCloudLayer->SetBaseWidth(100000);
    cirrusCloudLayer->SetLayerPosition(0, 0);
    cirrusCloudLayer->SeedClouds(*atm);

    atm->GetConditions()->AddCloudLayer(cirrusCloudLayer);
}

// Add a cumulus congestus deck with 80% sky coverage.
static void SetupCumulusCongestusClouds()
{
    CloudLayer *cumulusCongestusLayer;

    cumulusCongestusLayer = CloudLayerFactory::Create(CUMULUS_CONGESTUS_HI_RES);
    cumulusCongestusLayer->SetIsInfinite(true);
    cumulusCongestusLayer->SetBaseAltitude(1500);
    cumulusCongestusLayer->SetThickness(100);
    cumulusCongestusLayer->SetBaseLength(30000);
    cumulusCongestusLayer->SetBaseWidth(30000);
    cumulusCongestusLayer->SetDensity(0.8);
    cumulusCongestusLayer->SetLayerPosition(0, 0);
    cumulusCongestusLayer->SetCloudAnimationEffects(0.1, false);
    cumulusCongestusLayer->SeedClouds(*atm);
    cumulusCongestusLayer->SetAlpha(0.5);
    cumulusCongestusLayer->SetFadeTowardEdges(true);

    atm->GetConditions()->AddCloudLayer(cumulusCongestusLayer);
}

// Sets up a solid stratus deck.
static void SetupStratusClouds()
{
    CloudLayer *stratusLayer;

    stratusLayer = CloudLayerFactory::Create(STRATUS);
    stratusLayer->SetIsInfinite(true);
    stratusLayer->SetBaseAltitude(1000);
    stratusLayer->SetThickness(600);
    stratusLayer->SetDensity(0.5);
    stratusLayer->SetLayerPosition(0, 0);
    stratusLayer->SeedClouds(*atm);

    atm->GetConditions()->AddCloudLayer(stratusLayer);
}

// A thunderhead; note a Cumulonimbus cloud layer contains a single cloud.
static void SetupCumulonimbusClouds()
{
    CloudLayer *cumulonimbusLayer;

    cumulonimbusLayer = CloudLayerFactory::Create(CUMULONIMBUS_CAPPILATUS);
    cumulonimbusLayer->SetBaseAltitude(1000);
    cumulonimbusLayer->SetThickness(3000);
    cumulonimbusLayer->SetBaseLength(3000);
    cumulonimbusLayer->SetBaseWidth(5000);
    cumulonimbusLayer->SetLayerPosition(0, -5000);
    cumulonimbusLayer->SeedClouds(*atm);

    atm->GetConditions()->AddCloudLayer(cumulonimbusLayer);
}

// Cumulus mediocris are little, puffy clouds. Keep the density low for realism, otherwise
// you'll have a LOT of clouds because they are small.
static void SetupCumulusMediocrisClouds()
{
    CloudLayer *cumulusMediocrisLayer;

    cumulusMediocrisLayer = CloudLayerFactory::Create(CUMULUS_MEDIOCRIS);
    cumulusMediocrisLayer->SetIsInfinite(true);
    cumulusMediocrisLayer->SetBaseAltitude(1000);
    cumulusMediocrisLayer->SetThickness(200);
    cumulusMediocrisLayer->SetBaseLength(20000);
    cumulusMediocrisLayer->SetBaseWidth(20000);
    cumulusMediocrisLayer->SetDensity(0.9);
    cumulusMediocrisLayer->SetLayerPosition(0, 0);
    cumulusMediocrisLayer->SeedClouds(*atm);

    atm->GetConditions()->AddCloudLayer(cumulusMediocrisLayer);
}

// Stratocumulus clouds are rendered with GPU ray-casting. On systems that can support it
// (Shader model 3.0+) this enables very dense cloud layers with per-fragment lighting.
static void SetupStratocumulusClouds()
{
    CloudLayer *stratocumulusLayer;

    stratocumulusLayer = CloudLayerFactory::Create(STRATOCUMULUS);
    stratocumulusLayer->SetBaseAltitude(1000);
    stratocumulusLayer->SetThickness(3000);
    stratocumulusLayer->SetBaseLength(kVisibility);
    stratocumulusLayer->SetBaseWidth(kVisibility);
    stratocumulusLayer->SetDensity(0.5);
    stratocumulusLayer->SetIsInfinite(true);
    stratocumulusLayer->SetAlpha(1.0);
    stratocumulusLayer->SetFadeTowardEdges(true);
    stratocumulusLayer->SetLayerPosition(0, 0);
    stratocumulusLayer->SeedClouds(*atm);

    atm->GetConditions()->AddCloudLayer(stratocumulusLayer);
}

// Sandstorms should be positioned at ground level. There is no need to set their
// density or thickness.
static void SetupSandstorm()
{
    CloudLayer *sandstormLayer;

    sandstormLayer = CloudLayerFactory::Create(SANDSTORM);
    sandstormLayer->SetIsInfinite(false);
    sandstormLayer->SetLayerPosition(0, -24000);
    sandstormLayer->SetBaseAltitude(0);
    sandstormLayer->SetBaseLength(50000);
    sandstormLayer->SetBaseWidth(50000);
    sandstormLayer->SeedClouds(*atm);

    atm->GetConditions()->AddCloudLayer(sandstormLayer);
}

// Configure SilverLining for the desired wind, clouds, and visibility.
static void SetupAtmosphericConditions()
{
    assert(atm);

    // Set up the desired cloud types.
    SetupCirrusClouds();
    //SetupCumulusCongestusClouds();
    //SetupStratusClouds();
    //SetupCumulonimbusClouds();
    //SetupCumulusMediocrisClouds();
    SetupStratocumulusClouds();
    //SetupSandstorm();

    // Set up wind blowing northeast at 50 meters/sec
    WindVolume wv;
    wv.SetDirection(225);
    wv.SetMinAltitude(0);
    wv.SetMaxAltitude(10000);
    wv.SetWindSpeed(50);
    atm->GetConditions()->SetWind(wv);

    // Set visibility
    atm->GetConditions()->SetVisibility(kVisibility);
}

// Sets the simulated location and local time.
// Note, it's important that your longitude in the Location agrees with
// the time zone in the LocalTime.
void SetTimeAndLocation()
{
    Location loc;
    loc.SetLatitude(45);
    loc.SetLongitude(-122);

    LocalTime tm;
    tm.SetYear(1971);
    tm.SetMonth(8);
    tm.SetDay(7);
    tm.SetHour(12);
    tm.SetMinutes(30);
    tm.SetSeconds(0);
    tm.SetObservingDaylightSavingsTime(true);
    tm.SetTimeZone(PST);

    atm->GetConditions()->SetTime(tm);
    atm->GetConditions()->SetLocation(loc);
}



int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 32; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	///params.HandleSRGB = true;
	device = createDeviceEx(params);


	if (device == 0)
		return 1; // could not create selected driver.


	video::COpenGLDriver* driver = dynamic_cast<COpenGLDriver*>(device->getVideoDriver());

#define OPENGL_SUPERLOG
    if (COpenGLExtensionHandler::FeatureAvailable[COpenGLExtensionHandler::IRR_KHR_debug])
    {
        glEnable(GL_DEBUG_OUTPUT);
        glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
        COpenGLExtensionHandler::pGlDebugMessageControl(GL_DONT_CARE,GL_DONT_CARE,GL_DONT_CARE,0,NULL,true);
#ifndef OPENGL_SUPERLOG
        COpenGLExtensionHandler::pGlDebugMessageControl(GL_DONT_CARE,GL_DONT_CARE,GL_DEBUG_SEVERITY_LOW,0,NULL,false);
        COpenGLExtensionHandler::pGlDebugMessageControl(GL_DONT_CARE,GL_DEBUG_TYPE_OTHER,GL_DONT_CARE,0,NULL,false);
        COpenGLExtensionHandler::pGlDebugMessageControl(GL_DONT_CARE,GL_DONT_CARE,GL_DEBUG_SEVERITY_NOTIFICATION,0,NULL,false);
#endif // OPENGL_SUPERLOG
        COpenGLExtensionHandler::pGlDebugMessageCallback(openGLCBFunc,NULL);
    }
    else
    {
        //glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB);
        COpenGLExtensionHandler::pGlDebugMessageControlARB(GL_DONT_CARE,GL_DONT_CARE,GL_DONT_CARE,0,NULL,true);
#ifndef OPENGL_SUPERLOG
        COpenGLExtensionHandler::pGlDebugMessageControlARB(GL_DONT_CARE,GL_DONT_CARE,GL_DEBUG_SEVERITY_LOW_ARB,0,NULL,false);
        COpenGLExtensionHandler::pGlDebugMessageControlARB(GL_DONT_CARE,GL_DEBUG_TYPE_OTHER_ARB,GL_DONT_CARE,0,NULL,false);
#endif // OPENGL_SUPERLOG
        COpenGLExtensionHandler::pGlDebugMessageCallbackARB(openGLCBFunc,NULL);
    }

    SimpleCallBack* callBack = new SimpleCallBack();

    //! First need to make a material other than default to be able to draw with custom shader
    video::SMaterial material;
    material.BackfaceCulling = false; //! Triangles will be visible from both sides
    material.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        callBack, //! No Shader Callback (we dont have any constants/uniforms to pass to the shader)
                                                        0); //! No custom user data
    callBack->drop();


	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.55f);
	camera->setPosition(core::vector3df(-4,50.f,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.05f);
	camera->setFarValue(20000.f);
	camera->setFOV(core::PI/3.f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);


	//! Test Creation Of Builtin
	scene::IMeshSceneNode* cube = dynamic_cast<scene::IMeshSceneNode*>(smgr->addCubeSceneNode(1.f,0,-1));
    cube->setRotation(core::vector3df(45,20,15));
    cube->getMaterial(0).setTexture(0,driver->getTexture("../../media/irrlicht2_dn.jpg"));

	scene::ISceneNode* billboard = smgr->addCubeSceneNode(kVisibility,0,-1,core::vector3df(0,0,0),core::vector3df(0,0,0),core::vector3df(1.f,1.f/kVisibility,1.f));
    billboard->getMaterial(0).setTexture(0,driver->getTexture("../../media/wall.jpg"));

    float cubeDistance = 0.f;
    float cubeParameterHint = 0.f;
    uint32_t cubeSegment = 0;

    #define kCircleControlPts 3
    for (size_t i=0; i<kCircleControlPts; i++)
    {
        float x = float(i)*core::PI*2.f/float(kCircleControlPts);
        controlPts.push_back(vectorSIMDf(sin(x),12.5f,-cos(x))*4.f);
    }
    cube->setPosition(controlPts[0].getAsVector3df());

    {
            COpenGLState preState = COpenGLState::collectGLState();
        // Instantiate an Atmosphere object. Substitute your own purchased license name and code here.
        atm = new Atmosphere("Soren Gronbech", "031d13061a492413034e2316171a");

        silverLoader = new SilverLoader(device->getFileSystem(),"../../../../../client/silverlining.zip");
        ///atm->SetResourceLoader(silverLoader);

        int err;
        std::string relativeResourceDir = "../../../../../client/silverlining/";
    #ifdef WIN32
        std::replace(relativeResourceDir.begin(),relativeResourceDir.end(),'/','\\');
        err = atm->Initialize(Atmosphere::OPENGL32CORE, relativeResourceDir.c_str(), false, 0);
    #else
        err = atm->Initialize(Atmosphere::OPENGL32CORE, relativeResourceDir.c_str(), false, 0);
    #endif

        if (err == Atmosphere::E_NOERROR) {

            // If you want different clouds to be generated every time, remember to seed the
            // random number generator.
            atm->GetRandomNumberGenerator()->Seed(time(NULL));

            // Set your frame of reference (call this before setting up clouds!)
            atm->SetUpVector(0, 1, 0);
            atm->SetRightVector(1, 0, 0);

            //! can I call this shit only once?
            atm->SetWorldUnits(0.5);
            atm->SetDepthRange(1.f,0.f);
            atm->SetViewport(0,0,params.WindowSize.Width,params.WindowSize.Height);

            ///atm->SetHaze(0.784f/0.04f,0.707f/0.04f,0.543f/0.04f,600.f,0.0005f);

            if (true)
            {
                atm->SetOutputScale(0.04f);
                atm->EnableHDR(true);
            }
            else
                atm->EnableHDR(false);

            atm->DisableFarCulling(true);

            std::ifstream ifs("savedsky7.atm", std::ifstream::in);
            if (ifs.is_open())
                atm->Unserialize(ifs);
            else
            {
                // Set up all the clouds
                SetupAtmosphericConditions();

                // Configure where and when we want to be
                SetTimeAndLocation();
            }
        } else {
            printf("Error was %d\n", err);
        }

            executeGLDiff(preState^COpenGLState::collectGLState());
    }

    //! Little tutorial on Render Target Rendering
    uint32_t texSize[] = {params.WindowSize.Width/2,params.WindowSize.Height/2};
    video::IFrameBuffer* fbo = driver->addFrameBuffer();
    video::ITexture* tex = device->getVideoDriver()->addTexture(ITexture::ETT_2D,texSize,1,"depth_attach",ECF_DEPTH32F);
    fbo->attach(EFAP_DEPTH_ATTACHMENT,tex);
    tex = device->getVideoDriver()->addTexture(ITexture::ETT_2D,texSize,1,"color_attach",ECF_A16B16G16R16F);
    fbo->attach(EFAP_COLOR_ATTACHMENT0,tex);

    atm->SetViewport(0,0,tex->getSize()[0],tex->getSize()[1]);


	uint64_t lastFPSTime = 0;

	uint64_t lastTime = device->getTimer()->getRealTime();
    uint64_t timeDelta = 0;


	while (device->run())
	{
	    atm->UpdateEphemeris(); // to get new sun position

		driver->beginScene(false, false, video::SColor(0,0,0,0) );

        uint64_t nowTime = device->getTimer()->getRealTime();
        timeDelta = nowTime-lastTime;
        lastTime = nowTime;

		if (spline)
        {
            vectorSIMDf newPos;
            cubeDistance += float(timeDelta)*0.001f; //1 unit per second
            cubeSegment = spline->getPos(newPos,cubeDistance,cubeSegment,&cubeParameterHint);
            if (cubeSegment>=0xdeadbeefu) //reached end of non-loop, or spline changed
            {
                cubeDistance = 0;
                cubeParameterHint = 0;
                cubeSegment = 0;
                cubeSegment = spline->getPos(newPos,cubeDistance,cubeSegment,&cubeParameterHint);
            }

            vectorSIMDf forwardDir;
            assert(spline->getUnnormDirection_fromParameter(forwardDir,cubeSegment,cubeParameterHint)); //must be TRUE
            forwardDir = normalize(forwardDir); //must normalize after
            vectorSIMDf sideDir = normalize(cross(forwardDir,vectorSIMDf(0,1,0))); // predefined up vector
            vectorSIMDf pseudoUp = cross(sideDir,forwardDir);



            matrix4x3 mat;
            mat.getColumn(0) = reinterpret_cast<vector3df&>(forwardDir);
            mat.getColumn(1) = reinterpret_cast<vector3df&>(pseudoUp);
            mat.getColumn(2) = reinterpret_cast<vector3df&>(sideDir);
            mat.setTranslation(reinterpret_cast<const vector3df&>(newPos));
            cube->setRelativeTransformationMatrix(mat);
        }

        driver->setRenderTarget(fbo,true);
        driver->clearZBuffer();
        float color[4] = {0.f,0.f,0.f,0.f};
        driver->clearColorBuffer(EFAP_COLOR_ATTACHMENT0,color);

        atm->UpdateSkyAndClouds(); // do this inbetween queries!!

        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer
        smgr->drawAll();
        camPos = camera->getAbsolutePosition();
        {
            double mv[16];
            for (size_t i=0; i<4; i++)
            {
                for (size_t j=0; j<3; j++)
                    ((double*)mv)[i*4+j] = reinterpret_cast<const float*>(&camera->getViewMatrix().getColumn(i))[j];
                ((double*)mv)[i*4+3] = i!=3 ? 0.f:1.f;
            }
            double proj[16];
            for (size_t i=0; i<4; i++)
            for (size_t j=0; j<4; j++)
                proj[i*4+j] = camera->getProjectionMatrix().pointer()[i*4+j];

            //atm stuff after this get done twice for reflections
            atm->SetCameraMatrix((double*)mv);
            atm->SetProjectionMatrix((double*)proj);

            core::matrix4 mpv_irr(driver->getTransform(video::EPTS_PROJ_VIEW));
            double mvp[16];
            for (size_t i=0; i<4; i++)
            for (size_t j=0; j<4; j++)
                mvp[i+j*4] = mpv_irr.pointer()[i*4+j];

            SilverLining::Frustum f;
            SilverLining::Matrix4(mvp).GetFrustum(f);
            atm->CullObjects(f,false);


            COpenGLState preState = COpenGLState::collectGLState();
            COpenGLState silverState;
            {
                // set pixel store unpack align 4 (implicit)
                silverState.glBindProgramPipeline_val = 0;
                silverState.setGlEnableBit(EGEB_MULTISAMPLE,false);
                silverState.setGlEnableBit(EGEB_DEPTH_CLAMP,true);
                silverState.setGlEnableBit(EGEB_DEPTH_TEST,true);
                silverState.setGlEnableBit(EGEB_CULL_FACE,true);
                for (uint32_t i=0; i<driver->MaxMultipleRenderTargets; i++)
                    silverState.setGlEnableiBit(EGEIB_BLEND,i,false);

                silverState.glFrontFace_val = GL_CW;
                silverState.glDepthFunc_val = GL_GEQUAL;
                silverState.glDepthMask_val = false;
                silverState.boundVAO = 0;
            }
            executeGLDiff(silverState.getStateDiff(preState,
                                                    false,  //careAboutHints
                                                    false,  //careAboutFBOs
                                                    false,  //careAboutPolygonOffset
                                                    true,   //careAboutPixelXferOps
                                                    false,  //careAboutSSBOAndAtomicCounters
                                                    true,   //careAboutXFormFeedback
                                                    true,   //careAboutProgram
                                                    false,  //careAboutPipeline
                                                    false,  //careAboutTesellationParams
                                                    false,  //careAboutViewports
                                                    true,   //careAboutDrawIndirectBuffers
                                                    false,  //careAboutPointSize
                                                    false,  //careAboutLineWidth
                                                    false,  //careAboutLogicOp
                                                    false,  //careAboutMultisampling -- CAN CHANGE IN THE FUTURE
                                                    true,   //careAboutBlending
                                                    true,   //careAboutColorWriteMasks
                                                    false,  //careAboutStencilFunc
                                                    false,  //careAboutStencilOp
                                                    true,   //careAboutStencilMask
                                                    true,   //careAboutDepthFunc
                                                    true,   //careAboutDepthMask
                                                    false,  //careAboutImages
                                                    true,   //careAboutTextures
                                                    true,   //careAboutFaceOrientOrCull
                                                    true)); //careAboutVAO


            atm->DrawSky(true,false,0,true,false,true,0,-2.f,0);
            // When you're done, call Atmosphere::DrawObjects() to draw all the clouds from back to front.
            atm->DrawObjects(true,true,true,0.f,false);
            atm->DrawLensFlare();

            executeGLDiff(preState.getStateDiff(COpenGLState::collectGLState(),
                                                    false,  //careAboutHints
                                                    false,  //careAboutFBOs
                                                    false,  //careAboutPolygonOffset
                                                    true,   //careAboutPixelXferOps
                                                    false,  //careAboutSSBOAndAtomicCounters
                                                    false,   //careAboutXFormFeedback
                                                    true,   //careAboutProgram
                                                    false,  //careAboutPipeline
                                                    false,  //careAboutTesellationParams
                                                    false,  //careAboutViewports
                                                    false,   //careAboutDrawIndirectBuffers
                                                    false,  //careAboutPointSize
                                                    false,  //careAboutLineWidth
                                                    false,  //careAboutLogicOp
                                                    false,  //careAboutMultisampling -- CAN CHANGE IN THE FUTURE
                                                    true,   //careAboutBlending
                                                    true,   //careAboutColorWriteMasks
                                                    false,  //careAboutStencilFunc
                                                    false,  //careAboutStencilOp
                                                    true,   //careAboutStencilMask
                                                    true,   //careAboutDepthFunc
                                                    true,   //careAboutDepthMask
                                                    false,  //careAboutImages
                                                    true,   //careAboutTextures
                                                    true,   //careAboutFaceOrientOrCull
                                                    true)); //careAboutVAO
        }

        driver->setRenderTarget(0,true);

	///glEnable(GL_FRAMEBUFFER_SRGB);
        driver->blitRenderTargets(fbo,0,false,core::recti(0,0,0,0),core::recti(0,0,0,0),true);
	///glDisable(GL_FRAMEBUFFER_SRGB);

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream str;
			str << L"Silverlining Integration Demo - Irrlicht Engine FPS:" << driver->getFPS() << " PrimitvesDrawn:";
			str << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.str());
			lastFPSTime = time;
		}
	}

	driver->removeFrameBuffer(fbo);

    if (spline)
        delete spline;

    std::ofstream ofs("savedsky.atm", std::ofstream::out|std::ofstream::trunc);
    if (ofs.is_open())
    {
        atm->Serialize(ofs);
        ofs.close();
    }

    delete atm;
    delete silverLoader;

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();

	device->drop();

	return 0;
}
#define _IRR_STATIC_LIB_
#include <irrlicht.h>
#include <iostream>
#include <cstdio>

#include "../source/Irrlicht/COpenGLExtensionHandler.h"
#include "COpenGLStateManager.h"

using namespace irr;
using namespace core;

bool quit = false;

//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                quit = true;
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t mvpUniformLocation;
    int32_t cameraDirUniformLocation;
    int32_t texUniformLocation[4];
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
    video::E_SHADER_CONSTANT_TYPE cameraDirUniformType;
    video::E_SHADER_CONSTANT_TYPE texUniformType[4];
public:
    SimpleCallBack() : cameraDirUniformLocation(-1), cameraDirUniformType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        for (size_t i=0; i<constants.size(); i++)
        {
            if (constants[i].name=="MVP")
            {
                mvpUniformLocation = constants[i].location;
                mvpUniformType = constants[i].type;
            }
            else if (constants[i].name=="cameraPos")
            {
                cameraDirUniformLocation = constants[i].location;
                cameraDirUniformType = constants[i].type;
            }
            else if (constants[i].name=="tex0")
            {
                texUniformLocation[0] = constants[i].location;
                texUniformType[0] = constants[i].type;
            }
            else if (constants[i].name=="tex3")
            {
                texUniformLocation[3] = constants[i].location;
                texUniformType[3] = constants[i].type;
            }
        }
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        core::vectorSIMDf modelSpaceCamPos;
        modelSpaceCamPos.set(services->getVideoDriver()->getTransform(video::E4X3TS_WORLD_VIEW_INVERSE).getTranslation());
        if (cameraDirUniformLocation!=-1)
            services->setShaderConstant(&modelSpaceCamPos,cameraDirUniformLocation,cameraDirUniformType,1);
        if (mvpUniformLocation!=-1)
            services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);

        int32_t id[] = {0,1,2,3};
        if (texUniformLocation[0]!=-1)
            services->setShaderTextures(id+0,texUniformLocation[0],texUniformType[0],1);
        if (texUniformLocation[3]!=-1)
            services->setShaderTextures(id+3,texUniformLocation[3],texUniformType[3],1);
    }

    virtual void OnUnsetMaterial() {}
};

class PostProcCallBack : public video::IShaderConstantSetCallBack
{
    int32_t sampleCountUniformLocation;
    video::E_SHADER_CONSTANT_TYPE sampleCountUniformType;
public:
    PostProcCallBack() {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        /**
        Shader Unigorms get saved as Program (Shader state)
        So we can perma-assign texture slots to sampler uniforms
        **/
        int32_t id[] = {0,1,2,3};
        for (size_t i=0; i<constants.size(); i++)
        {
            if (constants[i].name=="tex0")
                services->setShaderTextures(id+0,constants[i].location,constants[i].type,1);
            else if (constants[i].name=="tex1")
                services->setShaderTextures(id+1,constants[i].location,constants[i].type,1);
            else if (constants[i].name=="sampleCount")
            {
                sampleCountUniformLocation = constants[i].location;
                sampleCountUniformType = constants[i].type;
            }
        }
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        if (sampleCountUniformLocation!=-1)
            services->setShaderConstant(&userData,sampleCountUniformLocation,sampleCountUniformType,1);
    }

    virtual void OnUnsetMaterial() {}
};


#include "irrpack.h"
struct ScreenQuadVertexStruct
{
    float Pos[3];
    uint8_t TexCoord[2];
} PACK_STRUCT;
#include "irrunpack.h"

int main()
{
	printf("Enter the number of samples to use for MSAA: ");

	uint32_t numberOfSamples = 8;
	std::cin >> numberOfSamples;
	// yeah yeah I'll add a query mechanism for the max in IVideoDriver
	if (numberOfSamples>64)
        numberOfSamples = 64;
    if (numberOfSamples<=1)
        numberOfSamples = 2;

	printf("\nPlease select the MSAA FBO attachment type to use:\n");
	printf(" (0 : default) Use Texture\n");
	printf(" (1) Use Renderbuffer\n");

	bool useRenderbuffer = false;
	uint32_t c;
	std::cin >> c;
	if (c==1)
        useRenderbuffer = true;

    //You may find while experimenting that you can only create a texture with 8 samples but renderbuffer with 32 !
    printf("\nUsing %s with %d samples.\n",useRenderbuffer ? "Renderbuffer":"Texture",numberOfSamples);

	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();

    SimpleCallBack* cb = new SimpleCallBack();
    video::E_MATERIAL_TYPE newMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        cb, //! Our Shader Callback
                                                        0); //! No custom user data
    cb->drop();



	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(250.0f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);

        #define kInstanceSquareSize 10
	scene::ISceneNode* instancesToRemove[kInstanceSquareSize*kInstanceSquareSize] = {0};

	//! Test Loading of Obj
    scene::ICPUMesh* cpumesh = smgr->getMesh("../../media/dwarf.x");
    if (cpumesh&&cpumesh->getMeshType()==scene::EMT_ANIMATED_SKINNED)
    {
        scene::ISkinnedMeshSceneNode* anode = 0;
        scene::ICPUSkinnedMesh* animMesh = dynamic_cast<scene::ICPUSkinnedMesh*>(cpumesh);
        scene::IGPUMesh* gpumesh = driver->createGPUMeshFromCPU(cpumesh);
        smgr->getMeshCache()->removeMesh(cpumesh); //drops hierarchy

        for (size_t x=0; x<kInstanceSquareSize; x++)
        for (size_t z=0; z<kInstanceSquareSize; z++)
        {
            instancesToRemove[x+kInstanceSquareSize*z] = anode = smgr->addSkinnedMeshSceneNode(static_cast<scene::IGPUSkinnedMesh*>(gpumesh));
            anode->setScale(core::vector3df(0.05f));
            anode->setPosition(core::vector3df(x,0.f,z)*4.f);
            anode->setAnimationSpeed(18.f*float(x+1+(z+1)*kInstanceSquareSize)/float(kInstanceSquareSize*kInstanceSquareSize));
            anode->setMaterialType(newMaterialType);
            anode->setMaterialTexture(3,anode->getBonePoseTBO());
        }

        gpumesh->drop();
    }

    //! We use a renderbuffer because we don't intend on reading from it
    video::IRenderBuffer* colorRB=NULL,* depthRB=NULL;
    video::IMultisampleTexture* colorMT=NULL,* depthMT=NULL;
    scene::IGPUMeshBuffer* screenQuadMeshBuffer=NULL;
    video::SMaterial postProcMaterial;
    video::IFrameBuffer* framebuffer = driver->addFrameBuffer();
    if (useRenderbuffer)
    {
        colorRB = driver->addMultisampleRenderBuffer(numberOfSamples,params.WindowSize,video::ECF_A8R8G8B8);
        depthRB = driver->addMultisampleRenderBuffer(numberOfSamples,params.WindowSize,video::ECF_DEPTH32F);
        framebuffer->attach(video::EFAP_COLOR_ATTACHMENT0,colorRB);
        framebuffer->attach(video::EFAP_DEPTH_ATTACHMENT,depthRB);
    }
    else
    {
        colorMT = driver->addMultisampleTexture(video::IMultisampleTexture::EMTT_2D,numberOfSamples,&params.WindowSize.Width,video::ECF_A8R8G8B8);
        depthMT = driver->addMultisampleTexture(video::IMultisampleTexture::EMTT_2D,numberOfSamples,&params.WindowSize.Width,video::ECF_DEPTH32F);
        framebuffer->attach(video::EFAP_COLOR_ATTACHMENT0,colorMT);
        framebuffer->attach(video::EFAP_DEPTH_ATTACHMENT,depthMT);

        /**
        This extra stuff is to show off programmable resolve with a shader.
        **/
        screenQuadMeshBuffer = new scene::IGPUMeshBuffer();
        scene::IGPUMeshDataFormatDesc* desc = driver->createGPUMeshDataFormatDesc();
        screenQuadMeshBuffer->setMeshDataAndFormat(desc);
        desc->drop();

        ScreenQuadVertexStruct vertices[4];
        vertices[0].Pos[0] = -1.f;
        vertices[0].Pos[1] = -1.f;
        vertices[0].Pos[2] = 0.5f;
        vertices[0].TexCoord[0] = 0;
        vertices[0].TexCoord[1] = 0;
        vertices[1].Pos[0] = 1.f;
        vertices[1].Pos[1] = -1.f;
        vertices[1].Pos[2] = 0.5f;
        vertices[1].TexCoord[0] = 1;
        vertices[1].TexCoord[1] = 0;
        vertices[2].Pos[0] = -1.f;
        vertices[2].Pos[1] = 1.f;
        vertices[2].Pos[2] = 0.5f;
        vertices[2].TexCoord[0] = 0;
        vertices[2].TexCoord[1] = 1;
        vertices[3].Pos[0] = 1.f;
        vertices[3].Pos[1] = 1.f;
        vertices[3].Pos[2] = 0.5f;
        vertices[3].TexCoord[0] = 1;
        vertices[3].TexCoord[1] = 1;

        uint16_t indices_indexed16[] = {0,1,2,2,1,3};

        void* tmpMem = malloc(sizeof(vertices)+sizeof(indices_indexed16));
        memcpy(tmpMem,vertices,sizeof(vertices));
        memcpy(tmpMem+sizeof(vertices),indices_indexed16,sizeof(indices_indexed16));
        video::IGPUBuffer* buff = driver->createGPUBuffer(sizeof(vertices)+sizeof(indices_indexed16),tmpMem);
        free(tmpMem);

        desc->mapVertexAttrBuffer(buff,scene::EVAI_ATTR0,scene::ECPA_THREE,scene::ECT_FLOAT,sizeof(ScreenQuadVertexStruct),0);
        desc->mapVertexAttrBuffer(buff,scene::EVAI_ATTR1,scene::ECPA_TWO,scene::ECT_UNSIGNED_BYTE,sizeof(ScreenQuadVertexStruct),12); //this time we used unnormalized
        desc->mapIndexBuffer(buff);
        screenQuadMeshBuffer->setIndexBufferOffset(sizeof(vertices));
        screenQuadMeshBuffer->setIndexType(video::EIT_16BIT);
        screenQuadMeshBuffer->setIndexCount(6);
        buff->drop();

        PostProcCallBack* callBack = new PostProcCallBack();
        //! First need to make a material other than default to be able to draw with custom shader
        postProcMaterial.BackfaceCulling = false; //! Triangles will be visible from both sides
        postProcMaterial.ZBuffer = video::ECFN_ALWAYS; //! Ignore Depth Test
        postProcMaterial.ZWriteEnable = false; //! Why even write depth?
        postProcMaterial.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../screenquad.vert",
                                                                            "","","", //! No Geometry or Tessellation Shaders
                                                                            "../postproc.frag",
                                                                            3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only)
                                                                            callBack,
                                                                            NULL,0, //! Xform feedback stuff, irrelevant here
                                                                            numberOfSamples); //! custom user data
        //! Need to bind our Multisample Textures to the correct texture units upon draw
        postProcMaterial.setTexture(0,colorMT);
        postProcMaterial.setTexture(1,depthMT);
        callBack->drop();
    }


	uint64_t lastFPSTime = 0;

	while(device->run()&&(!quit))
	//if (device->isWindowActive())
	{
		driver->beginScene( false,false );

		driver->setRenderTarget(framebuffer);
		vectorSIMDf clearColor(1.f,1.f,1.f,1.f);
        driver->clearColorBuffer(video::EFAP_COLOR_ATTACHMENT0,clearColor.pointer);
		driver->clearZBuffer();
        //! This animates (moves) the camera and sets the transforms
        //! Also draws the meshbuffer

        //yeah we dont have the state tracker yet
        glEnable(GL_MULTISAMPLE);
        smgr->drawAll();
        glDisable(GL_MULTISAMPLE);

        /**
        We could use the same codepath for MultisampleTextures as for Renderbuffers,
        since blit works on FBOs it would work here to as a resolve.

        But instead we show off programmable resolve with a shader.
        **/
        if (useRenderbuffer)
        {
            //notice how I dont even have to set the current FBO (render target) to 0 (the screen) for results to display
            const bool needToCopyDepth = false;
            driver->blitRenderTargets(framebuffer,0,needToCopyDepth);
        }
        else
        {
            driver->setRenderTarget(0);
            driver->setMaterial(postProcMaterial);
            driver->drawMeshBuffer(screenQuadMeshBuffer);
        }

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream str;
			str << L"Builtin Nodes Demo - Irrlicht Engine [" << driver->getName() << "] FPS:" << driver->getFPS() << " PrimitvesDrawn:" << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.str());
			lastFPSTime = time;
		}
	}

	driver->removeFrameBuffer(framebuffer);
	if (useRenderbuffer)
    {
        driver->removeRenderBuffer(colorRB);
        driver->removeRenderBuffer(depthRB);
    }
    else
    {
        driver->removeMultisampleTexture(colorMT);
        driver->removeMultisampleTexture(depthMT);

        screenQuadMeshBuffer->drop();
    }

    for (size_t x=0; x<kInstanceSquareSize; x++)
    for (size_t z=0; z<kInstanceSquareSize; z++)
        instancesToRemove[x+kInstanceSquareSize*z]->remove();

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
        video::COpenGLExtensionHandler::extGlNamedFramebufferReadBuffer(0,GL_FRONT_LEFT);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();

	device->drop();

	return 0;
}
#define _IRR_STATIC_LIB_
#include <irrlicht.h>
#include "../source/Irrlicht/COpenGLExtensionHandler.h"


using namespace irr;
using namespace core;

bool quit = false;

//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // so we can quit
                quit = true;
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};

core::vector3df absoluteLightPos;
core::matrix4 ViewProjCubeMatrices[6];

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t worldspaceLightPosUniformLocation;
    int32_t worldMatUniformLocation;
    int32_t normalMatUniformLocation;
    int32_t mvpUniformLocation;
    int32_t vpcmUniformLocation;
    video::E_SHADER_CONSTANT_TYPE worldspaceLightPosUniformType;
    video::E_SHADER_CONSTANT_TYPE worldMatUniformType;
    video::E_SHADER_CONSTANT_TYPE normalMatUniformType;
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
    video::E_SHADER_CONSTANT_TYPE vpcmUniformType;
public:
    SimpleCallBack() : worldspaceLightPosUniformLocation(-1), worldMatUniformLocation(-1), normalMatUniformLocation(-1), mvpUniformLocation(-1), vpcmUniformLocation(-1) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        int32_t id[] = {0,1,2,3};
        for (size_t i=0; i<constants.size(); i++)
        {
            if (constants[i].name=="worldSpaceLightPos")
            {
                worldspaceLightPosUniformLocation = constants[i].location;
                worldspaceLightPosUniformType = constants[i].type;
            }
            else if (constants[i].name=="worldMat")
            {
                worldMatUniformLocation = constants[i].location;
                worldMatUniformType = constants[i].type;
            }
            else if (constants[i].name=="normalMat")
            {
                normalMatUniformLocation = constants[i].location;
                normalMatUniformType = constants[i].type;
            }
            else if (constants[i].name=="MVP")
            {
                mvpUniformLocation = constants[i].location;
                mvpUniformType = constants[i].type;
            }
            else if (constants[i].name=="ViewProjCubeMatrices"||constants[i].name=="ViewProjCubeMatrices[0]") //nvidia intel and amd report names differently
            {
                vpcmUniformLocation = constants[i].location;
                vpcmUniformType = constants[i].type;
            } //! permabind texture slots
            else if (constants[i].name=="tex0")
                services->setShaderTextures(id+0,constants[i].location,constants[i].type,1);
            else if (constants[i].name=="tex1")
                services->setShaderTextures(id+1,constants[i].location,constants[i].type,1);
            else if (constants[i].name=="tex3")
                services->setShaderTextures(id+3,constants[i].location,constants[i].type,1);
        }
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        if (worldspaceLightPosUniformLocation!=-1)
        {
            services->setShaderConstant(&absoluteLightPos.X,worldspaceLightPosUniformLocation,worldspaceLightPosUniformType,1);
        }
        if (worldMatUniformLocation!=-1)
            services->setShaderConstant(services->getVideoDriver()->getTransform(video::E4X3TS_WORLD).pointer(),worldMatUniformLocation,worldMatUniformType,1);
        if (normalMatUniformLocation!=-1)
        {
            float worldSpaceNormalMatrix[9]; //no view space like gl_NormalMatrix or E4X3TS_NORMAL_MATRIX
            services->getVideoDriver()->getTransform(video::E4X3TS_WORLD).getSub3x3InverseTranspose(worldSpaceNormalMatrix);
            services->setShaderConstant(worldSpaceNormalMatrix,normalMatUniformLocation,normalMatUniformType,1);
        }
        if (mvpUniformLocation!=-1)
            services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);
        if (vpcmUniformLocation!=-1)
        {
            core::matrix4 ModelViewProjCubeMatrices[6];
            for (size_t i=0; i<6; i++)
                ModelViewProjCubeMatrices[i] = core::concatenateBFollowedByA(ViewProjCubeMatrices[i],services->getVideoDriver()->getTransform(video::E4X3TS_WORLD));
            services->setShaderConstant(ModelViewProjCubeMatrices,vpcmUniformLocation,vpcmUniformType,6);
        }
    }

    virtual void OnUnsetMaterial() {}
};


int main()
{
	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();

    SimpleCallBack* cb = new SimpleCallBack();
    video::E_MATERIAL_TYPE skinnedMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../skinnedMesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        cb); //! Our Shader Callback
    //! we could use the same shader callback for many materials, but then have to keep track of uniforms separately!
    cb->drop();
    cb = new SimpleCallBack();
    //! Oh the stuff we could do with this shader, output transform feedback for main-view drawing and saving the GPU skinning results.
    video::E_MATERIAL_TYPE skinnedShadowMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../skinnedMeshShadow.vert",
                                                        "","", //! Tessellation Shaders
                                                        "../cubeMapLayerDispatch.geom", //! Geometry Shader to amplify geometry and set gl_Layer
                                                        "../shadow.frag",
                                                        3,video::EMT_SOLID, //! 3 vertices per primitive (this is tessellation shader relevant only
                                                        cb); //! Our Shader Callback
    //! we could use the same shader callback for many materials, but then have to keep track of uniforms separately!
    cb->drop();
    cb = new SimpleCallBack();
    video::E_MATERIAL_TYPE litSolidMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                        "","","", //! No Geometry or Tessellation Shaders
                                                        "../mesh.frag",
                                                        3,video::EMT_SOLID,
                                                        cb);
    //! we could use the same shader callback for many materials, but then have to keep track of uniforms separately!
    cb->drop();
    cb = new SimpleCallBack();
    video::E_MATERIAL_TYPE shadowMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../meshShadow.vert",
                                                        "","", //! Tessellation Shaders
                                                        "../cubeMapLayerDispatch.geom", //! Geometry Shader to amplify geometry and set gl_Layer
                                                        "../shadow.frag",
                                                        3,video::EMT_SOLID,
                                                        cb);
    cb->drop();


    #define kInstanceSquareSize 10
	scene::ISceneManager* smgr = device->getSceneManager();


    //! Create our dummy scene-node signfying the light and lets get the view and projection matrices!
    scene::IDummyTransformationSceneNode* dummyLightNode = smgr->addDummyTransformationSceneNode();
    dummyLightNode->setPosition(core::vector3df(2.f,0.5f,2.f)*kInstanceSquareSize);
    scene::ISceneNodeAnimator* anim = smgr->createFlyCircleAnimator(dummyLightNode->getPosition(),10.f);
    dummyLightNode->addAnimator(anim);
    anim->drop();

    // could fish this proj matrix from the envMapCam, but I know better and that all of them would be equal
    // set near value to be as far as possible to increase our precision in Z-Buffer (definitely want it to be same size as the light-bulb)
    // set far value to be the range of the light (or farthest shadow caster away from the light)
    // aspect ratio and FOV must be 1 and 90 degrees to render a cube face
    core::matrix4 ProjMatrix;
    ProjMatrix = ProjMatrix.buildProjectionMatrixPerspectiveFovLH(core::PI*0.5f,1.f,0.1f,250.f);
    ProjMatrix[0] = 1.f;
    ProjMatrix[5] = -1.f;
    core::matrix4x3 ViewMatricesWithoutTranslation[6];
    for (size_t i=0; i<6; i++)
    {
        //preconfig stuff for camera orientations
        core::vector3df lookat[6] = {core::vector3df( 1, 0, 0),core::vector3df(-1, 0, 0),core::vector3df( 0, 1, 0),core::vector3df( 0,-1, 0),core::vector3df( 0, 0, 1),core::vector3df( 0, 0,-1)};
        core::vector3df up[6] = {core::vector3df( 0, 1, 0),core::vector3df( 0, 1, 0),core::vector3df( 0, 0, -1),core::vector3df( 0, 0, 1),core::vector3df( 0, 1, 0),core::vector3df( 0, 1, 0)};

        scene::ICameraSceneNode* envMapCam = smgr->addCameraSceneNode();
        envMapCam->setTarget(lookat[i]);
        envMapCam->setUpVector(up[i]);
        envMapCam->OnAnimate(0);
        envMapCam->render();
        ViewMatricesWithoutTranslation[i] = envMapCam->getViewMatrix();
        envMapCam->remove();
    }


    #define kCubeMapSize 2048
    uint32_t size[3] = {kCubeMapSize,kCubeMapSize,6};
    video::ITexture* cubeMap = driver->addTexture(video::ITexture::ETT_CUBE_MAP,size,1,"shadowmap",video::ECF_DEPTH32F); //dat ZBuffer Precision, may be excessive
    //notice this FBO only has a depth attachment, no colour!
    video::IFrameBuffer* fbo = driver->addFrameBuffer();
    fbo->attach(video::EFAP_DEPTH_ATTACHMENT,cubeMap,0); //attach all 6 faces at once
    //! REMEMBER THIS IS NOT THE END OF THE OPTIMIZATIONS, WE COULD ALWAYS USE TRANSFORM FEEDBACK TO SAVE GPU SKINNING AND NOT HAVE TO DO IT AGAIN (100% FASTER RENDER on second pass)


	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(250.0f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);

	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	//add a floor
	scene::ISceneNode* floor = smgr->addCubeSceneNode(kInstanceSquareSize*20.f,0,-1,core::vector3df(0,-0.75f,0),core::vector3df(0,0,0),core::vector3df(1.f,1.f/(kInstanceSquareSize*20.f),1.f));
	video::SMaterial& floorMaterial = floor->getMaterial(0);
	floorMaterial.setTexture(0,driver->getTexture("../../media/wall.jpg"));
	floorMaterial.setTexture(1,cubeMap);
	floorMaterial.MaterialType = litSolidMaterialType;

	scene::ISceneNode* anodes[kInstanceSquareSize*kInstanceSquareSize] = {0};

	//! For Shadow Optimization
	scene::ISkinnedMeshSceneNode* fastestNode = NULL;
	//
    scene::ICPUMesh* cpumesh = smgr->getMesh("../../media/dwarf.x");
    if (cpumesh&&cpumesh->getMeshType()==scene::EMT_ANIMATED_SKINNED)
    {
        scene::ISkinnedMeshSceneNode* anode = 0;
        scene::ICPUSkinnedMesh* animMesh = dynamic_cast<scene::ICPUSkinnedMesh*>(cpumesh);
        scene::IGPUMesh* gpumesh = driver->createGPUMeshFromCPU(cpumesh);
        smgr->getMeshCache()->removeMesh(cpumesh); //drops hierarchy

        for (size_t x=0; x<kInstanceSquareSize; x++)
        for (size_t z=0; z<kInstanceSquareSize; z++)
        {
            anodes[x+kInstanceSquareSize*z] = anode = smgr->addSkinnedMeshSceneNode(static_cast<scene::IGPUSkinnedMesh*>(gpumesh));
            anode->setScale(core::vector3df(0.05f));
            anode->setPosition((core::vector3df(x,0.f,z)+core::vector3df(0.5f,0.f,0.5f))*4.f);
            anode->setAnimationSpeed(18.f*float(x+1+(z+1)*kInstanceSquareSize)/float(kInstanceSquareSize*kInstanceSquareSize));
            anode->setMaterialType(skinnedMaterialType);
            anode->setMaterialTexture(1,cubeMap);
            anode->setMaterialTexture(3,anode->getBonePoseTBO());
        }
        fastestNode = anode;

        gpumesh->drop();
    }


	uint64_t lastFPSTime = 0;
	float lastFastestMeshFrameNr = -1.f;

	while(device->run()&&(!quit))
	//if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,0,0,0) );

		//! Animate first
		smgr->getRootSceneNode()->OnAnimate(os::Timer::getTime());

		// without this optimization FPS is 400 instead of 1000 FPS
		if (fastestNode->getFrameNr()!=lastFastestMeshFrameNr)
        {
            lastFastestMeshFrameNr = fastestNode->getFrameNr();
            //! its a bit stupid that I update light position only when animations update
            //! but in the internals of the engine animations only update every 120Hz (we can set this individually per mesh)
            //! so I'm just syncing everything up to the fastest mesh
            absoluteLightPos = dummyLightNode->getAbsolutePosition();

            //! draw shadows
            smgr->setActiveCamera(NULL);

            floor->setMaterialType(shadowMaterialType);
            for (size_t x=0; x<kInstanceSquareSize; x++)
            for (size_t z=0; z<kInstanceSquareSize; z++)
            {
                anodes[x+kInstanceSquareSize*z]->setMaterialType(skinnedShadowMaterialType);
                anodes[x+kInstanceSquareSize*z]->setMaterialFlag(video::EMF_BACK_FACE_CULLING,false);
            }

            driver->setRenderTarget(fbo,true);
            driver->clearZBuffer();
            for (size_t i=0; i<6; i++)
            {
                matrix4x3 viewMatModified(ViewMatricesWithoutTranslation[i]);

                //put the 'camera' position in
                ViewMatricesWithoutTranslation[i].mulSub3x3With3x1(&viewMatModified.getColumn(3).X,&absoluteLightPos.X);
                viewMatModified.getColumn(3) *= -1.f;

                //
                ViewProjCubeMatrices[i] = core::concatenateBFollowedByA(ProjMatrix,viewMatModified);
            }
            smgr->drawAll();

            floor->setMaterialType(litSolidMaterialType);
            for (size_t x=0; x<kInstanceSquareSize; x++)
            for (size_t z=0; z<kInstanceSquareSize; z++)
            {
                anodes[x+kInstanceSquareSize*z]->setMaterialType(skinnedMaterialType);
                anodes[x+kInstanceSquareSize*z]->setMaterialFlag(video::EMF_BACK_FACE_CULLING,true);
            }

            driver->setRenderTarget(0,true);

            smgr->setActiveCamera(camera);
        }

        //! Draw the view
        smgr->drawAll();

		driver->endScene();

		// display frames per second in window title
		uint64_t time = device->getTimer()->getRealTime();
		if (time-lastFPSTime > 1000)
		{
			std::wostringstream str;
			str << L"Builtin Nodes Demo - Irrlicht Engine [" << driver->getName() << "] FPS:" << driver->getFPS() << " PrimitvesDrawn:" << driver->getPrimitiveCountDrawn();

			device->setWindowCaption(str.str());
			lastFPSTime = time;
		}
	}

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	screenshot->drop();


    for (size_t x=0; x<kInstanceSquareSize; x++)
    for (size_t z=0; z<kInstanceSquareSize; z++)
        anodes[x+kInstanceSquareSize*z]->remove();

	device->drop();

	return 0;
}
#define _IRR_STATIC_LIB_
#include <irrlicht.h>
#include <iostream>
#include <cstdio>

#include "../source/Irrlicht/COpenGLExtensionHandler.h"
#include "COpenGLStateManager.h"

using namespace irr;
using namespace core;

bool quit = false;

//!Same As Last Example
class MyEventReceiver : public IEventReceiver
{
public:

	MyEventReceiver()
	{
	}

	bool OnEvent(const SEvent& event)
	{
        if (event.EventType == irr::EET_KEY_INPUT_EVENT && !event.KeyInput.PressedDown)
        {
            switch (event.KeyInput.Key)
            {
            case irr::KEY_KEY_Q: // switch wire frame mode
                quit = true;
                return true;
            default:
                break;
            }
        }

		return false;
	}

private:
};

class SimpleCallBack : public video::IShaderConstantSetCallBack
{
    int32_t mvpUniformLocation;
    int32_t selfPosLocation;
    int32_t texUniformLocation[4];
    video::E_SHADER_CONSTANT_TYPE mvpUniformType;
    video::E_SHADER_CONSTANT_TYPE selfPosType;
    video::E_SHADER_CONSTANT_TYPE texUniformType[4];
public:
    SimpleCallBack() : selfPosLocation(-1), selfPosType(video::ESCT_FLOAT_VEC3) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        for (size_t i=0; i<constants.size(); i++)
        {
            if (constants[i].name=="MVP")
            {
                mvpUniformLocation = constants[i].location;
                mvpUniformType = constants[i].type;
            }
            else if (constants[i].name=="selfPos")
            {
                selfPosLocation = constants[i].location;
                selfPosType = constants[i].type;
            }
            else if (constants[i].name=="tex0")
            {
                texUniformLocation[0] = constants[i].location;
                texUniformType[0] = constants[i].type;
            }
        }
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        core::vectorSIMDf selfPos(&services->getVideoDriver()->getTransform(video::E4X3TS_WORLD).getColumn(3).X);
        if (selfPosLocation!=-1)
            services->setShaderConstant(selfPos.pointer,selfPosLocation,selfPosType,1);
        if (mvpUniformLocation!=-1)
            services->setShaderConstant(services->getVideoDriver()->getTransform(video::EPTS_PROJ_VIEW_WORLD).pointer(),mvpUniformLocation,mvpUniformType,1);

        int32_t id[] = {0,1,2,3};
        if (texUniformLocation[0]!=-1)
            services->setShaderTextures(id+0,texUniformLocation[0],texUniformType[0],1);
    }

    virtual void OnUnsetMaterial() {}
};

class PostProcCallBack : public video::IShaderConstantSetCallBack
{
    int32_t sampleCountUniformLocation;
    video::E_SHADER_CONSTANT_TYPE sampleCountUniformType;
public:
    PostProcCallBack() : sampleCountUniformLocation(-1) {}

    virtual void PostLink(video::IMaterialRendererServices* services, const video::E_MATERIAL_TYPE& materialType, const core::array<video::SConstantLocationNamePair>& constants)
    {
        /**
        Shader Unigorms get saved as Program (Shader state)
        So we can perma-assign texture slots to sampler uniforms
        **/
        int32_t id[] = {0,1,2,3};
        for (size_t i=0; i<constants.size(); i++)
        {
            if (constants[i].name=="tex0")
                services->setShaderTextures(id+0,constants[i].location,constants[i].type,1);
            else if (constants[i].name=="tex1")
                services->setShaderTextures(id+1,constants[i].location,constants[i].type,1);
            else if (constants[i].name=="sampleCount")
            {
                sampleCountUniformLocation = constants[i].location;
                sampleCountUniformType = constants[i].type;
            }
        }
    }

    virtual void OnSetConstants(video::IMaterialRendererServices* services, int32_t userData)
    {
        if (sampleCountUniformLocation!=-1)
            services->setShaderConstant(&userData,sampleCountUniformLocation,sampleCountUniformType,1);
    }

    virtual void OnUnsetMaterial() {}
};


#include "irrpack.h"
struct ScreenQuadVertexStruct
{
    float Pos[3];
    uint8_t TexCoord[2];
} PACK_STRUCT;
#include "irrunpack.h"

int main()
{
	printf("\nChoose the Transparency Algorithm:\n");
	printf(" (0 : default) None\n");
	printf(" (1) Z-Sorted\n"); //would benefit from transmittance thresholding
	printf(" (2) Stencil Routed Original\n"); //records k-first fragments (needs sorting for depth complexity>k)
	printf(" (3) Stencil Routed A-la DevSH\n"); //records k nearest fragments from k disjoint sets
	printf(" (4) Stencil Routed Min-Transmission\n"); //records k most opaque fragments from k disjoint sets (by putting the alpha value into the Z-buffer)
	printf(" (5) Weighted Average\n"); //would benefit from transmittance thresholding
	printf(" (6) Weighted Blended\n"); //would benefit from transmittance thresholding
	printf(" (7) Bin Sorted\n");
	printf(" (X) XXX\n");
	/** TODO
	+ A-Buffer http://www.icare3d.org/codes-and-projects/codes/opengl-4-0-abuffer-v2-0-linked-lists-of-fragment-pages.html
	+ Linked List
	+ Offset List
	+ Atomic Loop 64
	+ Intel Method
	+ AMD DX11 Method
	+ k+ Buffer
	**/

	uint32_t method=3;
	std::cin >> method;
    printf("\nUsing method %d.\n",method);

	// create device with full flexibility over creation parameters
	// you can add more parameters if desired, check irr::SIrrlichtCreationParameters
	irr::SIrrlichtCreationParameters params;
	params.Bits = 24; //may have to set to 32bit for some platforms
	params.ZBufferBits = 24; //we'd like 32bit here
	params.DriverType = video::EDT_OPENGL; //! Only Well functioning driver, software renderer left for sake of 2D image drawing
	params.WindowSize = dimension2d<uint32_t>(1280, 720);
	params.Fullscreen = false;
	params.Vsync = true; //! If supported by target platform
	params.Doublebuffer = true;
	params.Stencilbuffer = false; //! This will not even be a choice soon
	IrrlichtDevice* device = createDeviceEx(params);

	if (device == 0)
		return 1; // could not create selected driver.


	video::IVideoDriver* driver = device->getVideoDriver();

	scene::ISceneManager* smgr = device->getSceneManager();
	driver->setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);
	scene::ICameraSceneNode* camera =
		smgr->addCameraSceneNodeFPS(0,100.0f,0.01f);
	camera->setPosition(core::vector3df(-4,0,0));
	camera->setTarget(core::vector3df(0,0,0));
	camera->setNearValue(0.01f);
	camera->setFarValue(250.0f);
    smgr->setActiveCamera(camera);
	device->getCursorControl()->setVisible(false);
	MyEventReceiver receiver;
	device->setEventReceiver(&receiver);

        #define kInstanceSquareSize 10
	core::matrix4x3 instancePositions[kInstanceSquareSize*kInstanceSquareSize];

	//! Test Loading of Obj
    scene::ICPUMesh* cpumesh = smgr->getMesh("../../media/dwarf.x");
    scene::IGPUMesh* gpumesh = NULL;
    if (cpumesh)
    {
        gpumesh = driver->createGPUMeshFromCPU(cpumesh);
        smgr->getMeshCache()->removeMesh(cpumesh); //drops hierarchy

        for (size_t z=0; z<kInstanceSquareSize; z++)
        for (size_t x=0; x<kInstanceSquareSize; x++)
        {
            core::matrix4x3& matrix = instancePositions[x+kInstanceSquareSize*z];
            matrix.setScale(core::vector3df(0.05f));
            matrix.setTranslation(core::vector3df(x,0.f,z)*4.f);
        }
    }

    //! Set up screenquad
    scene::IGPUMeshBuffer* screenQuadMeshBuffer = new scene::IGPUMeshBuffer();
    {
        ScreenQuadVertexStruct vertices[4];
        vertices[0].Pos[0] = -1.f;
        vertices[0].Pos[1] = -1.f;
        vertices[0].Pos[2] = 0.5f;
        vertices[0].TexCoord[0] = 0;
        vertices[0].TexCoord[1] = 0;
        vertices[1].Pos[0] = 1.f;
        vertices[1].Pos[1] = -1.f;
        vertices[1].Pos[2] = 0.5f;
        vertices[1].TexCoord[0] = 1;
        vertices[1].TexCoord[1] = 0;
        vertices[2].Pos[0] = -1.f;
        vertices[2].Pos[1] = 1.f;
        vertices[2].Pos[2] = 0.5f;
        vertices[2].TexCoord[0] = 0;
        vertices[2].TexCoord[1] = 1;
        vertices[3].Pos[0] = 1.f;
        vertices[3].Pos[1] = 1.f;
        vertices[3].Pos[2] = 0.5f;
        vertices[3].TexCoord[0] = 1;
        vertices[3].TexCoord[1] = 1;

        uint16_t indices_indexed16[] = {0,1,2,2,1,3};

        void* tmpMem = malloc(sizeof(vertices)+sizeof(indices_indexed16));
        memcpy(tmpMem,vertices,sizeof(vertices));
        memcpy(tmpMem+sizeof(vertices),indices_indexed16,sizeof(indices_indexed16));
        video::IGPUBuffer* buff = driver->createGPUBuffer(sizeof(vertices)+sizeof(indices_indexed16),tmpMem);
        free(tmpMem);

        scene::IGPUMeshDataFormatDesc* desc = driver->createGPUMeshDataFormatDesc();
        screenQuadMeshBuffer->setMeshDataAndFormat(desc);
        desc->drop();

        desc->mapVertexAttrBuffer(buff,scene::EVAI_ATTR0,scene::ECPA_THREE,scene::ECT_FLOAT,sizeof(ScreenQuadVertexStruct),0);
        desc->mapVertexAttrBuffer(buff,scene::EVAI_ATTR1,scene::ECPA_TWO,scene::ECT_UNSIGNED_BYTE,sizeof(ScreenQuadVertexStruct),12); //this time we used unnormalized
        desc->mapIndexBuffer(buff);
        screenQuadMeshBuffer->setIndexBufferOffset(sizeof(vertices));
        screenQuadMeshBuffer->setIndexType(video::EIT_16BIT);
        screenQuadMeshBuffer->setIndexCount(6);
        buff->drop();
    }


    //! Must be Power Of Two!
    const uint32_t transparencyLayers = 0x1u<<3;


    video::IFrameBuffer* framebuffer = driver->addFrameBuffer();
    video::IMultisampleTexture* colorMT=NULL,* depthMT=NULL;
    video::SMaterial initMaterial,resolveMaterial;
    switch (method)
    {
        case 0:
        case 1:
            {
                SimpleCallBack* cb = new SimpleCallBack();
                video::E_MATERIAL_TYPE newMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                                    "","","", //! No Geometry or Tessellation Shaders
                                                                    "../mesh.frag",
                                                                    3,irr::video::EMT_TRANSPARENT_ALPHA_CHANNEL,
                                                                    cb, //! Our Shader Callback
                                                                    0); //! No custom user data
                cb->drop();
                for (size_t i=0; i<gpumesh->getMeshBufferCount(); i++)
                {
                    video::SMaterial& mat = gpumesh->getMeshBuffer(i)->getMaterial();
                    mat.BlendOperation = video::EBO_ADD;
                    mat.ZWriteEnable = false;
                    mat.BackfaceCulling = false;
                    mat.MaterialType = (video::E_MATERIAL_TYPE)newMaterialType;
                }
            }
            break;
        case 2:
        case 3:
            {
                SimpleCallBack* cb = new SimpleCallBack();
                video::E_MATERIAL_TYPE newMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                                    "","","", //! No Geometry or Tessellation Shaders
                                                                    "../mesh.frag",
                                                                    3,irr::video::EMT_SOLID,
                                                                    cb, //! Our Shader Callback
                                                                    0); //! No custom user data
                cb->drop();
                for (size_t i=0; i<gpumesh->getMeshBufferCount(); i++)
                {
                    video::SMaterial& mat = gpumesh->getMeshBuffer(i)->getMaterial();
                    if (method==2)
                    {
                        mat.ZBuffer = video::ECFN_ALWAYS;
                        mat.ZWriteEnable = true; //original bavoil has this off
                    }
                    mat.BackfaceCulling = false;
                    mat.MaterialType = (video::E_MATERIAL_TYPE)newMaterialType;
                }

                {
                    const uint32_t numberOfSamples = transparencyLayers;
                    colorMT = driver->addMultisampleTexture(video::IMultisampleTexture::EMTT_2D,numberOfSamples,&params.WindowSize.Width,video::ECF_A8R8G8B8);
                    depthMT = driver->addMultisampleTexture(video::IMultisampleTexture::EMTT_2D,numberOfSamples,&params.WindowSize.Width,video::ECF_DEPTH32F_STENCIL8);
                    framebuffer->attach(video::EFAP_COLOR_ATTACHMENT0,colorMT);
                    framebuffer->attach(video::EFAP_DEPTH_STENCIL_ATTACHMENT,depthMT);


                    PostProcCallBack* callBack = new PostProcCallBack();


                    initMaterial.BackfaceCulling = false; //! Triangles will be visible from both sides
                    initMaterial.ZBuffer = video::ECFN_ALWAYS; //! Ignore Depth Test
                    initMaterial.ZWriteEnable = false; //! Why even write depth?
                    initMaterial.ColorMask = video::ECP_NONE; //! Why even write depth?
                    initMaterial.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../screenquad.vert",
                                                                                        "","","", //! No Geometry or Tessellation Shaders
                                                                                        "../stencilKClear.frag",
                                                                                        3,video::EMT_SOLID);

                    resolveMaterial.BackfaceCulling = false; //! Triangles will be visible from both sides
                    resolveMaterial.ZBuffer = video::ECFN_ALWAYS; //! Ignore Depth Test
                    resolveMaterial.ZWriteEnable = false; //! Why even write depth?
                    resolveMaterial.BlendOperation = video::EBO_ADD;
                    resolveMaterial.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../screenquad.vert",
                                                                                        "","","", //! No Geometry or Tessellation Shaders
                                                                                        "../stencilKResolve.frag",
                                                                                        3,video::EMT_TRANSPARENT_ALPHA_CHANNEL, //! 3 vertices per primitive (this is tessellation shader relevant only)
                                                                                        callBack,
                                                                                        NULL,0, //! Xform feedback stuff, irrelevant here
                                                                                        numberOfSamples); //! custom user data
                    //! Need to bind our Multisample Textures to the correct texture units upon draw
                    resolveMaterial.setTexture(0,colorMT);
                    resolveMaterial.setTexture(1,depthMT);


                    callBack->drop();
                }
            }
            break;
        case 4:
            {
                SimpleCallBack* cb = new SimpleCallBack();
                video::E_MATERIAL_TYPE newMaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../mesh.vert",
                                                                    "","","", //! No Geometry or Tessellation Shaders
                                                                    "../mesh_minTrans.frag",
                                                                    3,irr::video::EMT_SOLID,
                                                                    cb, //! Our Shader Callback
                                                                    0); //! No custom user data
                cb->drop();
                for (size_t i=0; i<gpumesh->getMeshBufferCount(); i++)
                {
                    video::SMaterial& mat = gpumesh->getMeshBuffer(i)->getMaterial();
                    mat.BackfaceCulling = false;
                    mat.ZBuffer = video::ECFN_GREATER;
                    mat.MaterialType = (video::E_MATERIAL_TYPE)newMaterialType;
                }

                {
                    const uint32_t numberOfSamples = transparencyLayers;
                    colorMT = driver->addMultisampleTexture(video::IMultisampleTexture::EMTT_2D,numberOfSamples,&params.WindowSize.Width,video::ECF_A8R8G8B8);
                    depthMT = driver->addMultisampleTexture(video::IMultisampleTexture::EMTT_2D,numberOfSamples,&params.WindowSize.Width,video::ECF_DEPTH32F_STENCIL8);
                    framebuffer->attach(video::EFAP_COLOR_ATTACHMENT0,colorMT);
                    framebuffer->attach(video::EFAP_DEPTH_STENCIL_ATTACHMENT,depthMT);


                    PostProcCallBack* callBack = new PostProcCallBack();


                    initMaterial.BackfaceCulling = false; //! Triangles will be visible from both sides
                    initMaterial.ZBuffer = video::ECFN_ALWAYS; //! Ignore Depth Test
                    initMaterial.ZWriteEnable = false; //! Why even write depth?
                    initMaterial.ColorMask = video::ECP_NONE; //! Why even write depth?
                    initMaterial.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../screenquad.vert",
                                                                                        "","","", //! No Geometry or Tessellation Shaders
                                                                                        "../stencilKClear.frag",
                                                                                        3,video::EMT_SOLID);

                    resolveMaterial.BackfaceCulling = false; //! Triangles will be visible from both sides
                    resolveMaterial.ZBuffer = video::ECFN_ALWAYS; //! Ignore Depth Test
                    resolveMaterial.ZWriteEnable = false; //! Why even write depth?
                    resolveMaterial.BlendOperation = video::EBO_ADD;
                    resolveMaterial.MaterialType = (video::E_MATERIAL_TYPE)driver->getGPUProgrammingServices()->addHighLevelShaderMaterialFromFiles("../screenquad.vert",
                                                                                        "","","", //! No Geometry or Tessellation Shaders
                                                                                        "../minTransResolve.frag",
                                                                                        3,video::EMT_TRANSPARENT_ALPHA_CHANNEL, //! 3 vertices per primitive (this is tessellation shader relevant only)
                                                                                        callBack,
                                                                                        NULL,0, //! Xform feedback stuff, irrelevant here
                                                                                        numberOfSamples); //! custom user data
                    //! Need to bind our Multisample Textures to the correct texture units upon draw
                    resolveMaterial.setTexture(0,colorMT);
                    resolveMaterial.setTexture(1,depthMT);


                    callBack->drop();
                }
            }
            break;
        default:
            break;
    }


    uint64_t lastFPSTime = 0;

    while(device->run()&&(!quit))
    //if (device->isWindowActive())
    {
        driver->beginScene( false,false );

        //! This animates (moves) the camera and sets the transforms
        smgr->drawAll();

        switch (method)
        {
            case 0:
                {
                    vectorSIMDf clearColor(1.f,1.f,1.f,1.f);
                    driver->clearColorBuffer(video::EFAP_COLOR_ATTACHMENT0,clearColor.pointer);
                    driver->clearZBuffer();

                    for (size_t z=0; z<kInstanceSquareSize; z++)
                    for (size_t x=0; x<kInstanceSquareSize; x++)
                    {
                        driver->setTransform(video::E4X3TS_WORLD,instancePositions[x+kInstanceSquareSize*z]);
                        for (size_t i=0; i<gpumesh->getMeshBufferCount(); i++)
                        {
                            driver->setMaterial(gpumesh->getMeshBuffer(i)->getMaterial());
                            driver->drawMeshBuffer(gpumesh->getMeshBuffer(i));
                        }
                    }
                }
                break;
            case 1:
                {
                    vectorSIMDf clearColor(1.f,1.f,1.f,1.f);
                    driver->clearColorBuffer(video::EFAP_COLOR_ATTACHMENT0,clearColor.pointer);
                    driver->clearZBuffer();


                    std::pair<float,const core::matrix4x3*> distanceSortedInstances[kInstanceSquareSize*kInstanceSquareSize];
                    for (size_t z=0; z<kInstanceSquareSize; z++)
                    for (size_t x=0; x<kInstanceSquareSize; x++)
                    {
                        size_t offset = x+kInstanceSquareSize*z;
                        const core::matrix4x3* matrix = instancePositions+offset;
                        float dist = (camera->getAbsolutePosition()-matrix->getColumn(3)).getLength();
                        distanceSortedInstances[offset] = std::pair<float,const core::matrix4x3*>(dist,matrix);
                    }
                    struct
                    {
                        bool operator()(const std::pair<float,const core::matrix4x3*>& a, const std::pair<float,const core::matrix4x3*>& b) const
                        {
                            return a.first > b.first;
                        }
                    } customLess;
                    std::stable_sort(distanceSortedInstances,distanceSortedInstances+kInstanceSquareSize*kInstanceSquareSize,customLess);


                    for (size_t ix=0; ix<kInstanceSquareSize*kInstanceSquareSize; ix++)
                    {
                        driver->setTransform(video::E4X3TS_WORLD,*distanceSortedInstances[ix].second);
                        for (size_t i=0; i<gpumesh->getMeshBufferCount(); i++)
                        {
                            driver->setMaterial(gpumesh->getMeshBuffer(i)->getMaterial());
                            driver->drawMeshBuffer(gpumesh->getMeshBuffer(i));
                        }
                    }
                }
                break;
            case 2:
                {
                    ///fix the shit between here
                    driver->setRenderTarget(framebuffer);
                    vectorSIMDf clearColor(0.f);
                    driver->clearColorBuffer(video::EFAP_COLOR_ATTACHMENT0,clearColor.pointer);
                    //to reset the depth mask, otherwise won't clear
                    glDepthMask(GL_TRUE);
                    driver->clearZStencilBuffers(0,2);

                    glEnable(GL_STENCIL_TEST);
                    glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);

                    //init the stencil buffer
                    glEnable(GL_MULTISAMPLE);
                    glEnable(GL_SAMPLE_MASK);
                    for (uint32_t i=1; i<transparencyLayers; i++)
                    {
                        glStencilFunc(GL_ALWAYS,i+2,transparencyLayers-1);
                        video::COpenGLExtensionHandler::extGlSampleMaski(0,0x1u<<i);
                        driver->setMaterial(initMaterial);
                        driver->drawMeshBuffer(screenQuadMeshBuffer);
                    }
                    video::COpenGLExtensionHandler::extGlSampleMaski(0,~0x0u);
                    glDisable(GL_SAMPLE_MASK);
                    glDisable(GL_MULTISAMPLE);

                    //draw our stuff
                    glStencilOp(GL_DECR,GL_DECR,GL_DECR);
                    glStencilFunc(GL_EQUAL,2,transparencyLayers-1);
                    for (size_t z=0; z<kInstanceSquareSize; z++)
                    for (size_t x=0; x<kInstanceSquareSize; x++)
                    {
                        driver->setTransform(video::E4X3TS_WORLD,instancePositions[x+kInstanceSquareSize*z]);
                        for (size_t i=0; i<gpumesh->getMeshBufferCount(); i++)
                        {
                            driver->setMaterial(gpumesh->getMeshBuffer(i)->getMaterial());
                            driver->drawMeshBuffer(gpumesh->getMeshBuffer(i));
                        }
                    }
                    glDisable(GL_STENCIL_TEST);

                    //! Resolve
                    {
                        driver->setRenderTarget(0);
                        clearColor = vectorSIMDf(1.f);
                        driver->clearColorBuffer(video::EFAP_COLOR_ATTACHMENT0,clearColor.pointer);

                        driver->setMaterial(resolveMaterial);
                        driver->drawMeshBuffer(screenQuadMeshBuffer);
                    }
                    //to reset the depth mask
                    ///driver->setMaterial(video::SMaterial());
                }
                break;
            case 3:
            case 4: //only resolve differs
                {
                    ///fix the shit between here
                    driver->setRenderTarget(framebuffer);
                    vectorSIMDf clearColor(0.f);
                    driver->clearColorBuffer(video::EFAP_COLOR_ATTACHMENT0,clearColor.pointer);
                    //to reset the depth mask, otherwise won't clear
                    glDepthMask(GL_TRUE);
                    driver->clearZStencilBuffers(0,0);

                    glEnable(GL_STENCIL_TEST);
                    glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);

                    //init the stencil buffer
                    glEnable(GL_MULTISAMPLE);
                    glEnable(GL_SAMPLE_MASK);
                    for (uint32_t i=1; i<transparencyLayers; i++)
                    {
                        glStencilFunc(GL_ALWAYS,i,transparencyLayers-1);
                        video::COpenGLExtensionHandler::extGlSampleMaski(0,0x1u<<i);
                        driver->setMaterial(initMaterial);
                        driver->drawMeshBuffer(screenQuadMeshBuffer);
                    }
                    video::COpenGLExtensionHandler::extGlSampleMaski(0,~0x0u);
                    glDisable(GL_SAMPLE_MASK);
                    glDisable(GL_MULTISAMPLE);

                    //draw our stuff
                    glStencilOp(GL_DECR_WRAP,GL_DECR_WRAP,GL_DECR_WRAP);
                    glStencilFunc(GL_EQUAL,0,transparencyLayers-1);
                    for (size_t z=0; z<kInstanceSquareSize; z++)
                    for (size_t x=0; x<kInstanceSquareSize; x++)
                    {
                        driver->setTransform(video::E4X3TS_WORLD,instancePositions[x+kInstanceSquareSize*z]);
                        for (size_t i=0; i<gpumesh->getMeshBufferCount(); i++)
                        {
                            driver->setMaterial(gpumesh->getMeshBuffer(i)->getMaterial());
                            driver->drawMeshBuffer(gpumesh->getMeshBuffer(i));
                        }
                    }
                    glDisable(GL_STENCIL_TEST);

                    //! Resolve
                    {
                        driver->setRenderTarget(0);
                        clearColor = vectorSIMDf(1.f);
                        driver->clearColorBuffer(video::EFAP_COLOR_ATTACHMENT0,clearColor.pointer);

                        driver->setMaterial(resolveMaterial);
                        driver->drawMeshBuffer(screenQuadMeshBuffer);
                    }
                    //to reset the depth mask
                    ///driver->setMaterial(video::SMaterial());
                }
                break;
            default:
                break;
        }


        driver->endScene();

        // display frames per second in window title
        uint64_t time = device->getTimer()->getRealTime();
        if (time-lastFPSTime > 1000)
        {
            std::wostringstream str;
            str << L"Builtin Nodes Demo - Irrlicht Engine [" << driver->getName() << "] FPS:" << driver->getFPS() << " PrimitvesDrawn:" << driver->getPrimitiveCountDrawn();

            device->setWindowCaption(str.str());
            lastFPSTime = time;
        }
    }


    //! Cleanup
    driver->removeAllFrameBuffers();
    driver->removeAllMultisampleTextures();
    driver->removeAllRenderBuffers();

    if (screenQuadMeshBuffer)
        screenQuadMeshBuffer->drop();


    gpumesh->drop();

    //create a screenshot
	video::IImage* screenshot = driver->createImage(video::ECF_A8R8G8B8,params.WindowSize);
        video::COpenGLExtensionHandler::extGlNamedFramebufferReadBuffer(0,GL_BACK);
    glReadPixels(0,0, params.WindowSize.Width,params.WindowSize.Height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, screenshot->getData());
    {
        // images are horizontally flipped, so we have to fix that here.
        uint8_t* pixels = (uint8_t*)screenshot->getData();

        const int32_t pitch=screenshot->getPitch();
        uint8_t* p2 = pixels + (params.WindowSize.Height - 1) * pitch;
        uint8_t* tmpBuffer = new uint8_t[pitch];
        for (uint32_t i=0; i < params.WindowSize.Height; i += 2)
        {
            memcpy(tmpBuffer, pixels, pitch);
            memcpy(pixels, p2, pitch);
            memcpy(p2, tmpBuffer, pitch);
            pixels += pitch;
            p2 -= pitch;
        }
        delete [] tmpBuffer;
    }
	driver->writeImageToFile(screenshot,"./screenshot.png");
	device->sleep(3000);
	screenshot->drop();

	device->drop();

	return 0;
}
