\hypertarget{classirr_1_1core_1_1vector3d}{}\section{irr\+:\+:core\+:\+:vector3d$<$ T $>$ Class Template Reference}
\label{classirr_1_1core_1_1vector3d}\index{irr\+::core\+::vector3d$<$ T $>$@{irr\+::core\+::vector3d$<$ T $>$}}


3d vector template class with lots of operators and methods.  




{\ttfamily \#include $<$vector3d.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classirr_1_1core_1_1vector3d_aed8875ec8b9653857ea87fdb8213daf1}{vector3d} ()\hypertarget{classirr_1_1core_1_1vector3d_aed8875ec8b9653857ea87fdb8213daf1}{}\label{classirr_1_1core_1_1vector3d_aed8875ec8b9653857ea87fdb8213daf1}

\begin{DoxyCompactList}\small\item\em Default constructor (null vector). \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d_a10687f6e33f8f795961a9b8f0a71c79b}{vector3d} (T nx, T ny, T nz)\hypertarget{classirr_1_1core_1_1vector3d_a10687f6e33f8f795961a9b8f0a71c79b}{}\label{classirr_1_1core_1_1vector3d_a10687f6e33f8f795961a9b8f0a71c79b}

\begin{DoxyCompactList}\small\item\em Constructor with three different values. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d_a08093c70044d66a5c3cdec2522b868f2}{vector3d} (T n)\hypertarget{classirr_1_1core_1_1vector3d_a08093c70044d66a5c3cdec2522b868f2}{}\label{classirr_1_1core_1_1vector3d_a08093c70044d66a5c3cdec2522b868f2}

\begin{DoxyCompactList}\small\item\em Constructor with the same value for all elements. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d_a039600f48ce75c9eca6c0899135e60d5}{vector3d} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other)\hypertarget{classirr_1_1core_1_1vector3d_a039600f48ce75c9eca6c0899135e60d5}{}\label{classirr_1_1core_1_1vector3d_a039600f48ce75c9eca6c0899135e60d5}

\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ {\bfseries operator-\/} () const \hypertarget{classirr_1_1core_1_1vector3d_acc66a64d3e7ee0b722d155c4e987ecbe}{}\label{classirr_1_1core_1_1vector3d_acc66a64d3e7ee0b722d155c4e987ecbe}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries operator=} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other)\hypertarget{classirr_1_1core_1_1vector3d_afaaaf1d22c44ac50d03026cbfc794c42}{}\label{classirr_1_1core_1_1vector3d_afaaaf1d22c44ac50d03026cbfc794c42}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ {\bfseries operator+} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_a19d8592169d08d461a80d0e3c5a27b7f}{}\label{classirr_1_1core_1_1vector3d_a19d8592169d08d461a80d0e3c5a27b7f}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries operator+=} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other)\hypertarget{classirr_1_1core_1_1vector3d_a37360dbe7e5542e1cd3cdb768f250922}{}\label{classirr_1_1core_1_1vector3d_a37360dbe7e5542e1cd3cdb768f250922}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ {\bfseries operator+} (const T val) const \hypertarget{classirr_1_1core_1_1vector3d_a676c089849a119d557e3fd32eb47d2a8}{}\label{classirr_1_1core_1_1vector3d_a676c089849a119d557e3fd32eb47d2a8}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries operator+=} (const T val)\hypertarget{classirr_1_1core_1_1vector3d_a90dd07738795890b90fbf4b133cd7930}{}\label{classirr_1_1core_1_1vector3d_a90dd07738795890b90fbf4b133cd7930}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ {\bfseries operator-\/} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_ae17fdfbc02988aff60dfde5456c9032d}{}\label{classirr_1_1core_1_1vector3d_ae17fdfbc02988aff60dfde5456c9032d}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries operator-\/=} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other)\hypertarget{classirr_1_1core_1_1vector3d_a91a4a39544340b3d02e81659f1a0b7d2}{}\label{classirr_1_1core_1_1vector3d_a91a4a39544340b3d02e81659f1a0b7d2}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ {\bfseries operator-\/} (const T val) const \hypertarget{classirr_1_1core_1_1vector3d_a4c9b7154c6d582cd49039bd4f61c48cb}{}\label{classirr_1_1core_1_1vector3d_a4c9b7154c6d582cd49039bd4f61c48cb}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries operator-\/=} (const T val)\hypertarget{classirr_1_1core_1_1vector3d_afe666e30d5e903d4d910f2544829233c}{}\label{classirr_1_1core_1_1vector3d_afe666e30d5e903d4d910f2544829233c}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ {\bfseries operator$\ast$} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_aab7ded0a282f23cdc75533873f41dee5}{}\label{classirr_1_1core_1_1vector3d_aab7ded0a282f23cdc75533873f41dee5}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries operator$\ast$=} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other)\hypertarget{classirr_1_1core_1_1vector3d_a04e89643ddbd6e17ffceffd64e740760}{}\label{classirr_1_1core_1_1vector3d_a04e89643ddbd6e17ffceffd64e740760}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ {\bfseries operator$\ast$} (const T v) const \hypertarget{classirr_1_1core_1_1vector3d_ae8ecbd713bd488d45eab406f34679c1c}{}\label{classirr_1_1core_1_1vector3d_ae8ecbd713bd488d45eab406f34679c1c}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries operator$\ast$=} (const T v)\hypertarget{classirr_1_1core_1_1vector3d_a588d293d4d3ebd95240a9d2b46072233}{}\label{classirr_1_1core_1_1vector3d_a588d293d4d3ebd95240a9d2b46072233}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ {\bfseries operator/} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_a82f734747a8d460a73482dc69a1d2ece}{}\label{classirr_1_1core_1_1vector3d_a82f734747a8d460a73482dc69a1d2ece}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries operator/=} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other)\hypertarget{classirr_1_1core_1_1vector3d_ab46c94558797997b369cfe0a38c57794}{}\label{classirr_1_1core_1_1vector3d_ab46c94558797997b369cfe0a38c57794}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ {\bfseries operator/} (const T v) const \hypertarget{classirr_1_1core_1_1vector3d_a783084cb15a1a395c54de649544de966}{}\label{classirr_1_1core_1_1vector3d_a783084cb15a1a395c54de649544de966}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries operator/=} (const T v)\hypertarget{classirr_1_1core_1_1vector3d_a6b1f864e2316167a8b5a65ca086c11ff}{}\label{classirr_1_1core_1_1vector3d_a6b1f864e2316167a8b5a65ca086c11ff}

\item 
bool \hyperlink{classirr_1_1core_1_1vector3d_ad567b75b65cd2ded2312d41f7a5263da}{operator$<$=} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_ad567b75b65cd2ded2312d41f7a5263da}{}\label{classirr_1_1core_1_1vector3d_ad567b75b65cd2ded2312d41f7a5263da}

\begin{DoxyCompactList}\small\item\em sort in order X, Y, Z. Equality with rounding tolerance. \end{DoxyCompactList}\item 
bool \hyperlink{classirr_1_1core_1_1vector3d_ab3c1da2da396a7f2ae336fda985cab6d}{operator$>$=} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_ab3c1da2da396a7f2ae336fda985cab6d}{}\label{classirr_1_1core_1_1vector3d_ab3c1da2da396a7f2ae336fda985cab6d}

\begin{DoxyCompactList}\small\item\em sort in order X, Y, Z. Equality with rounding tolerance. \end{DoxyCompactList}\item 
bool \hyperlink{classirr_1_1core_1_1vector3d_a9ce8b1cf82c64f0985cf668056698519}{operator$<$} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_a9ce8b1cf82c64f0985cf668056698519}{}\label{classirr_1_1core_1_1vector3d_a9ce8b1cf82c64f0985cf668056698519}

\begin{DoxyCompactList}\small\item\em sort in order X, Y, Z. Difference must be above rounding tolerance. \end{DoxyCompactList}\item 
bool \hyperlink{classirr_1_1core_1_1vector3d_aeabe64473259a894507360f399d7f816}{operator$>$} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_aeabe64473259a894507360f399d7f816}{}\label{classirr_1_1core_1_1vector3d_aeabe64473259a894507360f399d7f816}

\begin{DoxyCompactList}\small\item\em sort in order X, Y, Z. Difference must be above rounding tolerance. \end{DoxyCompactList}\item 
bool \hyperlink{classirr_1_1core_1_1vector3d_a3908b4e712fa753a0c88ca6dfce36e34}{operator==} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_a3908b4e712fa753a0c88ca6dfce36e34}{}\label{classirr_1_1core_1_1vector3d_a3908b4e712fa753a0c88ca6dfce36e34}

\begin{DoxyCompactList}\small\item\em use weak float compare \end{DoxyCompactList}\item 
bool {\bfseries operator!=} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_a125c9bfa0c551f3543f1466f1a670c51}{}\label{classirr_1_1core_1_1vector3d_a125c9bfa0c551f3543f1466f1a670c51}

\item 
bool \hyperlink{classirr_1_1core_1_1vector3d_a7aa9401191db377d67a6d5b160e4c38e}{equals} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other, const T tolerance=(T) R\+O\+U\+N\+D\+I\+N\+G\+\_\+\+E\+R\+R\+O\+R\+\_\+f32) const \hypertarget{classirr_1_1core_1_1vector3d_a7aa9401191db377d67a6d5b160e4c38e}{}\label{classirr_1_1core_1_1vector3d_a7aa9401191db377d67a6d5b160e4c38e}

\begin{DoxyCompactList}\small\item\em returns if this vector equals the other one, taking floating point rounding errors into account \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries set} (const T nx, const T ny, const T nz)\hypertarget{classirr_1_1core_1_1vector3d_a3e9048423e1176a7342759a290d55c96}{}\label{classirr_1_1core_1_1vector3d_a3e9048423e1176a7342759a290d55c96}

\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& {\bfseries set} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&p)\hypertarget{classirr_1_1core_1_1vector3d_aaa41e0e1f747d4d83af8ac6b621184da}{}\label{classirr_1_1core_1_1vector3d_aaa41e0e1f747d4d83af8ac6b621184da}

\item 
T \hyperlink{classirr_1_1core_1_1vector3d_ab0f95138bd31d82b5486237c8e49a2d5}{get\+Length} () const \hypertarget{classirr_1_1core_1_1vector3d_ab0f95138bd31d82b5486237c8e49a2d5}{}\label{classirr_1_1core_1_1vector3d_ab0f95138bd31d82b5486237c8e49a2d5}

\begin{DoxyCompactList}\small\item\em Get length of the vector. \end{DoxyCompactList}\item 
T \hyperlink{classirr_1_1core_1_1vector3d_ad72df96d0e280b0e6383be273f94f6ae}{get\+Length\+SQ} () const 
\begin{DoxyCompactList}\small\item\em Get squared length of the vector. \end{DoxyCompactList}\item 
T \hyperlink{classirr_1_1core_1_1vector3d_a0b247d39047c0e51ff16d0118bb396ab}{dot\+Product} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const \hypertarget{classirr_1_1core_1_1vector3d_a0b247d39047c0e51ff16d0118bb396ab}{}\label{classirr_1_1core_1_1vector3d_a0b247d39047c0e51ff16d0118bb396ab}

\begin{DoxyCompactList}\small\item\em Get the dot product with another vector. \end{DoxyCompactList}\item 
T \hyperlink{classirr_1_1core_1_1vector3d_afd81bdc7d165f0e2082155127c3005e2}{get\+Distance\+From} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const 
\begin{DoxyCompactList}\small\item\em Get distance from another point. \end{DoxyCompactList}\item 
T \hyperlink{classirr_1_1core_1_1vector3d_afe85829b53b8ea449a4b51a2fb14c7be}{get\+Distance\+From\+SQ} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other) const 
\begin{DoxyCompactList}\small\item\em Returns squared distance from another point. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \hyperlink{classirr_1_1core_1_1vector3d_aa2470a12e1ef53f440c95df6249e9aa4}{cross\+Product} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&p) const 
\begin{DoxyCompactList}\small\item\em Calculates the cross product with another vector. \end{DoxyCompactList}\item 
bool \hyperlink{classirr_1_1core_1_1vector3d_ace05ee3b68b47c2ec6baff0d9d64de98}{is\+Between\+Points} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&begin, const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&end) const 
\begin{DoxyCompactList}\small\item\em Returns if this vector interpreted as a point is on a line between two other points. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& \hyperlink{classirr_1_1core_1_1vector3d_a84a1861464ef70e6965c146732103c09}{normalize} ()
\begin{DoxyCompactList}\small\item\em Normalizes the vector. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& \hyperlink{classirr_1_1core_1_1vector3d_ae593448ac63803b3d254b0e6c7600f28}{set\+Length} (T newlength)\hypertarget{classirr_1_1core_1_1vector3d_ae593448ac63803b3d254b0e6c7600f28}{}\label{classirr_1_1core_1_1vector3d_ae593448ac63803b3d254b0e6c7600f28}

\begin{DoxyCompactList}\small\item\em Sets the length of the vector to a new value. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& \hyperlink{classirr_1_1core_1_1vector3d_a55a10e03bc09f87b95fc81ea0d508722}{invert} ()\hypertarget{classirr_1_1core_1_1vector3d_a55a10e03bc09f87b95fc81ea0d508722}{}\label{classirr_1_1core_1_1vector3d_a55a10e03bc09f87b95fc81ea0d508722}

\begin{DoxyCompactList}\small\item\em Inverts the vector. \end{DoxyCompactList}\item 
void \hyperlink{classirr_1_1core_1_1vector3d_a621fbddb42814edd3d14410252cf7b7a}{rotate\+X\+Z\+By} (\hyperlink{namespaceirr_a1325b02603ad449f92c68fc640af9b28}{f64} degrees, const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&center=\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$())
\begin{DoxyCompactList}\small\item\em Rotates the vector by a specified number of degrees around the Y axis and the specified center. \end{DoxyCompactList}\item 
void \hyperlink{classirr_1_1core_1_1vector3d_ac38b75735ec06716305fbb09ec71784d}{rotate\+X\+Y\+By} (\hyperlink{namespaceirr_a1325b02603ad449f92c68fc640af9b28}{f64} degrees, const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&center=\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$())
\begin{DoxyCompactList}\small\item\em Rotates the vector by a specified number of degrees around the Z axis and the specified center. \end{DoxyCompactList}\item 
void \hyperlink{classirr_1_1core_1_1vector3d_aaa048312f75f152861479cb48e2ddfe4}{rotate\+Y\+Z\+By} (\hyperlink{namespaceirr_a1325b02603ad449f92c68fc640af9b28}{f64} degrees, const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&center=\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$())
\begin{DoxyCompactList}\small\item\em Rotates the vector by a specified number of degrees around the X axis and the specified center. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \hyperlink{classirr_1_1core_1_1vector3d_ab0ad2c732121c2b6e36c2c2e9ed715fd}{get\+Interpolated} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&other, \hyperlink{namespaceirr_a1325b02603ad449f92c68fc640af9b28}{f64} d) const 
\begin{DoxyCompactList}\small\item\em Creates an interpolated vector between this vector and another vector. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \hyperlink{classirr_1_1core_1_1vector3d_adb749559ee0941687d4692941146a388}{get\+Interpolated\+\_\+quadratic} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&v2, const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&v3, \hyperlink{namespaceirr_a1325b02603ad449f92c68fc640af9b28}{f64} d) const 
\begin{DoxyCompactList}\small\item\em Creates a quadratically interpolated vector between this and two other vectors. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \& \hyperlink{classirr_1_1core_1_1vector3d_a32a888e0f608a20deee98c794a321c4c}{interpolate} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&a, const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&b, \hyperlink{namespaceirr_a1325b02603ad449f92c68fc640af9b28}{f64} d)
\begin{DoxyCompactList}\small\item\em Sets this vector to the linearly interpolated vector between a and b. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \hyperlink{classirr_1_1core_1_1vector3d_a9485549addf9967247d3431c7746fbda}{get\+Horizontal\+Angle} () const 
\begin{DoxyCompactList}\small\item\em Get the rotations that would make a (0,0,1) direction vector point in the same direction as this direction vector. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \hyperlink{classirr_1_1core_1_1vector3d_aab6d3c2dc082d8142c7ac4da8625f93a}{get\+Spherical\+Coordinate\+Angles} () const 
\begin{DoxyCompactList}\small\item\em Get the spherical coordinate angles. \end{DoxyCompactList}\item 
\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \hyperlink{classirr_1_1core_1_1vector3d_a4db5cfbb71995227e37334a19278474d}{rotation\+To\+Direction} (const \hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$ \&forwards=\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ T $>$(0, 0, 1)) const 
\begin{DoxyCompactList}\small\item\em Builds a direction vector from (this) rotation vector. \end{DoxyCompactList}\item 
void \hyperlink{classirr_1_1core_1_1vector3d_a357c8d00022e04a68fb20b24f9eb34ce}{get\+As4\+Values} (T $\ast$\hyperlink{classirr_1_1core_1_1array}{array}) const 
\begin{DoxyCompactList}\small\item\em Fills an array of 4 values with the vector data (usually floats). \end{DoxyCompactList}\item 
void \hyperlink{classirr_1_1core_1_1vector3d_a543aaa4376afd2b5321228fa71540329}{get\+As3\+Values} (T $\ast$\hyperlink{classirr_1_1core_1_1array}{array}) const 
\begin{DoxyCompactList}\small\item\em Fills an array of 3 values with the vector data (usually floats). \end{DoxyCompactList}\item 
{\footnotesize template$<$$>$ }\\\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \hyperlink{classirr_1_1core_1_1vector3d_a7597f07300c420146117f2e5854153c2}{operator/} (\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} val) const\hypertarget{classirr_1_1core_1_1vector3d_a7597f07300c420146117f2e5854153c2}{}\label{classirr_1_1core_1_1vector3d_a7597f07300c420146117f2e5854153c2}

\begin{DoxyCompactList}\small\item\em partial specialization for integer vectors \end{DoxyCompactList}\item 
{\footnotesize template$<$$>$ }\\\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \& {\bfseries operator/=} (\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} val)\hypertarget{classirr_1_1core_1_1vector3d_a1d153631bde79b7bf50c2ab453d2bc60}{}\label{classirr_1_1core_1_1vector3d_a1d153631bde79b7bf50c2ab453d2bc60}

\item 
{\footnotesize template$<$$>$ }\\\hyperlink{classirr_1_1core_1_1vector3d}{vector3d}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ {\bfseries get\+Spherical\+Coordinate\+Angles} () const\hypertarget{classirr_1_1core_1_1vector3d_aa11de50e7f575c6c282de66417279444}{}\label{classirr_1_1core_1_1vector3d_aa11de50e7f575c6c282de66417279444}

\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
T \hyperlink{classirr_1_1core_1_1vector3d_a8c9ed06774dc668112bcefacb6e7732b}{X}\hypertarget{classirr_1_1core_1_1vector3d_a8c9ed06774dc668112bcefacb6e7732b}{}\label{classirr_1_1core_1_1vector3d_a8c9ed06774dc668112bcefacb6e7732b}

\begin{DoxyCompactList}\small\item\em X coordinate of the vector. \end{DoxyCompactList}\item 
T \hyperlink{classirr_1_1core_1_1vector3d_af8f87c2fe0ce717ade7c3d7419302fbd}{Y}\hypertarget{classirr_1_1core_1_1vector3d_af8f87c2fe0ce717ade7c3d7419302fbd}{}\label{classirr_1_1core_1_1vector3d_af8f87c2fe0ce717ade7c3d7419302fbd}

\begin{DoxyCompactList}\small\item\em Y coordinate of the vector. \end{DoxyCompactList}\item 
T \hyperlink{classirr_1_1core_1_1vector3d_ac2beb702e718c3579971348981b220ed}{Z}\hypertarget{classirr_1_1core_1_1vector3d_ac2beb702e718c3579971348981b220ed}{}\label{classirr_1_1core_1_1vector3d_ac2beb702e718c3579971348981b220ed}

\begin{DoxyCompactList}\small\item\em Z coordinate of the vector. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class T$>$\\*
class irr\+::core\+::vector3d$<$ T $>$}

3d vector template class with lots of operators and methods. 

The \hyperlink{classirr_1_1core_1_1vector3d}{vector3d} class is used in Irrlicht for three main purposes\+: 1) As a direction vector (most of the methods assume this). 2) As a position in 3d space (which is synonymous with a direction vector from the origin to this position). 3) To hold three Euler rotations, where X is pitch, Y is yaw and Z is roll. 

\subsection{Member Function Documentation}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!cross\+Product@{cross\+Product}}
\index{cross\+Product@{cross\+Product}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{cross\+Product(const vector3d$<$ T $>$ \&p) const }{crossProduct(const vector3d< T > \&p) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf vector3d}$<$T$>$ {\bf irr\+::core\+::vector3d}$<$ T $>$\+::cross\+Product (
\begin{DoxyParamCaption}
\item[{const {\bf vector3d}$<$ T $>$ \&}]{p}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_aa2470a12e1ef53f440c95df6249e9aa4}{}\label{classirr_1_1core_1_1vector3d_aa2470a12e1ef53f440c95df6249e9aa4}


Calculates the cross product with another vector. 


\begin{DoxyParams}{Parameters}
{\em p} & Vector to multiply with. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Crossproduct of this vector with p. 
\end{DoxyReturn}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!get\+As3\+Values@{get\+As3\+Values}}
\index{get\+As3\+Values@{get\+As3\+Values}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{get\+As3\+Values(\+T $\ast$array) const }{getAs3Values(T *array) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::vector3d}$<$ T $>$\+::get\+As3\+Values (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{array}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_a543aaa4376afd2b5321228fa71540329}{}\label{classirr_1_1core_1_1vector3d_a543aaa4376afd2b5321228fa71540329}


Fills an array of 3 values with the vector data (usually floats). 

Useful for setting in shader constants for example. \index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!get\+As4\+Values@{get\+As4\+Values}}
\index{get\+As4\+Values@{get\+As4\+Values}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{get\+As4\+Values(\+T $\ast$array) const }{getAs4Values(T *array) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::vector3d}$<$ T $>$\+::get\+As4\+Values (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{array}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_a357c8d00022e04a68fb20b24f9eb34ce}{}\label{classirr_1_1core_1_1vector3d_a357c8d00022e04a68fb20b24f9eb34ce}


Fills an array of 4 values with the vector data (usually floats). 

Useful for setting in shader constants for example. The fourth value will always be 0. \index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!get\+Distance\+From@{get\+Distance\+From}}
\index{get\+Distance\+From@{get\+Distance\+From}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{get\+Distance\+From(const vector3d$<$ T $>$ \&other) const }{getDistanceFrom(const vector3d< T > \&other) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ T {\bf irr\+::core\+::vector3d}$<$ T $>$\+::get\+Distance\+From (
\begin{DoxyParamCaption}
\item[{const {\bf vector3d}$<$ T $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_afd81bdc7d165f0e2082155127c3005e2}{}\label{classirr_1_1core_1_1vector3d_afd81bdc7d165f0e2082155127c3005e2}


Get distance from another point. 

Here, the vector is interpreted as point in 3 dimensional space. \index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!get\+Distance\+From\+SQ@{get\+Distance\+From\+SQ}}
\index{get\+Distance\+From\+SQ@{get\+Distance\+From\+SQ}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{get\+Distance\+From\+S\+Q(const vector3d$<$ T $>$ \&other) const }{getDistanceFromSQ(const vector3d< T > \&other) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ T {\bf irr\+::core\+::vector3d}$<$ T $>$\+::get\+Distance\+From\+SQ (
\begin{DoxyParamCaption}
\item[{const {\bf vector3d}$<$ T $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_afe85829b53b8ea449a4b51a2fb14c7be}{}\label{classirr_1_1core_1_1vector3d_afe85829b53b8ea449a4b51a2fb14c7be}


Returns squared distance from another point. 

Here, the vector is interpreted as point in 3 dimensional space. \index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!get\+Horizontal\+Angle@{get\+Horizontal\+Angle}}
\index{get\+Horizontal\+Angle@{get\+Horizontal\+Angle}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{get\+Horizontal\+Angle() const }{getHorizontalAngle() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf vector3d}$<$T$>$ {\bf irr\+::core\+::vector3d}$<$ T $>$\+::get\+Horizontal\+Angle (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_a9485549addf9967247d3431c7746fbda}{}\label{classirr_1_1core_1_1vector3d_a9485549addf9967247d3431c7746fbda}


Get the rotations that would make a (0,0,1) direction vector point in the same direction as this direction vector. 

Thanks to Arras on the Irrlicht forums for this method. This utility method is very useful for orienting scene nodes towards specific targets. For example, if this vector represents the difference between two scene nodes, then applying the result of \hyperlink{classirr_1_1core_1_1vector3d_a9485549addf9967247d3431c7746fbda}{get\+Horizontal\+Angle()} to one scene node will point it at the other one. Example code\+: Where target and seeker are of type I\+Scene\+Node$\ast$ const vector3df to\+Target(target-\/$>$get\+Absolute\+Position() -\/ seeker-\/$>$get\+Absolute\+Position()); const vector3df required\+Rotation = to\+Target.\+get\+Horizontal\+Angle(); seeker-\/$>$set\+Rotation(required\+Rotation);

\begin{DoxyReturn}{Returns}
A rotation vector containing the X (pitch) and Y (raw) rotations (in degrees) that when applied to a +Z (e.\+g. 0, 0, 1) direction vector would make it point in the same direction as this vector. The Z (roll) rotation is always 0, since two Euler rotations are sufficient to point in any given direction. 
\end{DoxyReturn}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!get\+Interpolated@{get\+Interpolated}}
\index{get\+Interpolated@{get\+Interpolated}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{get\+Interpolated(const vector3d$<$ T $>$ \&other, f64 d) const }{getInterpolated(const vector3d< T > \&other, f64 d) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf vector3d}$<$T$>$ {\bf irr\+::core\+::vector3d}$<$ T $>$\+::get\+Interpolated (
\begin{DoxyParamCaption}
\item[{const {\bf vector3d}$<$ T $>$ \&}]{other, }
\item[{{\bf f64}}]{d}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_ab0ad2c732121c2b6e36c2c2e9ed715fd}{}\label{classirr_1_1core_1_1vector3d_ab0ad2c732121c2b6e36c2c2e9ed715fd}


Creates an interpolated vector between this vector and another vector. 


\begin{DoxyParams}{Parameters}
{\em other} & The other vector to interpolate with. \\
\hline
{\em d} & Interpolation value between 0.\+0f (all the other vector) and 1.\+0f (all this vector). Note that this is the opposite direction of interpolation to \hyperlink{classirr_1_1core_1_1vector3d_adb749559ee0941687d4692941146a388}{get\+Interpolated\+\_\+quadratic()} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An interpolated vector. This vector is not modified. 
\end{DoxyReturn}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!get\+Interpolated\+\_\+quadratic@{get\+Interpolated\+\_\+quadratic}}
\index{get\+Interpolated\+\_\+quadratic@{get\+Interpolated\+\_\+quadratic}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{get\+Interpolated\+\_\+quadratic(const vector3d$<$ T $>$ \&v2, const vector3d$<$ T $>$ \&v3, f64 d) const }{getInterpolated\_quadratic(const vector3d< T > \&v2, const vector3d< T > \&v3, f64 d) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf vector3d}$<$T$>$ {\bf irr\+::core\+::vector3d}$<$ T $>$\+::get\+Interpolated\+\_\+quadratic (
\begin{DoxyParamCaption}
\item[{const {\bf vector3d}$<$ T $>$ \&}]{v2, }
\item[{const {\bf vector3d}$<$ T $>$ \&}]{v3, }
\item[{{\bf f64}}]{d}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_adb749559ee0941687d4692941146a388}{}\label{classirr_1_1core_1_1vector3d_adb749559ee0941687d4692941146a388}


Creates a quadratically interpolated vector between this and two other vectors. 


\begin{DoxyParams}{Parameters}
{\em v2} & Second vector to interpolate with. \\
\hline
{\em v3} & Third vector to interpolate with (maximum at 1.\+0f) \\
\hline
{\em d} & Interpolation value between 0.\+0f (all this vector) and 1.\+0f (all the 3rd vector). Note that this is the opposite direction of interpolation to \hyperlink{classirr_1_1core_1_1vector3d_ab0ad2c732121c2b6e36c2c2e9ed715fd}{get\+Interpolated()} and \hyperlink{classirr_1_1core_1_1vector3d_a32a888e0f608a20deee98c794a321c4c}{interpolate()} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An interpolated vector. This vector is not modified. 
\end{DoxyReturn}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!get\+Length\+SQ@{get\+Length\+SQ}}
\index{get\+Length\+SQ@{get\+Length\+SQ}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{get\+Length\+S\+Q() const }{getLengthSQ() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ T {\bf irr\+::core\+::vector3d}$<$ T $>$\+::get\+Length\+SQ (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_ad72df96d0e280b0e6383be273f94f6ae}{}\label{classirr_1_1core_1_1vector3d_ad72df96d0e280b0e6383be273f94f6ae}


Get squared length of the vector. 

This is useful because it is much faster than \hyperlink{classirr_1_1core_1_1vector3d_ab0f95138bd31d82b5486237c8e49a2d5}{get\+Length()}. \begin{DoxyReturn}{Returns}
Squared length of the vector. 
\end{DoxyReturn}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!get\+Spherical\+Coordinate\+Angles@{get\+Spherical\+Coordinate\+Angles}}
\index{get\+Spherical\+Coordinate\+Angles@{get\+Spherical\+Coordinate\+Angles}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{get\+Spherical\+Coordinate\+Angles() const }{getSphericalCoordinateAngles() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf vector3d}$<$T$>$ {\bf irr\+::core\+::vector3d}$<$ T $>$\+::get\+Spherical\+Coordinate\+Angles (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_aab6d3c2dc082d8142c7ac4da8625f93a}{}\label{classirr_1_1core_1_1vector3d_aab6d3c2dc082d8142c7ac4da8625f93a}


Get the spherical coordinate angles. 

This returns Euler degrees for the point represented by this vector. The calculation assumes the pole at (0,1,0) and returns the angles in X and Y. \index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!interpolate@{interpolate}}
\index{interpolate@{interpolate}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{interpolate(const vector3d$<$ T $>$ \&a, const vector3d$<$ T $>$ \&b, f64 d)}{interpolate(const vector3d< T > \&a, const vector3d< T > \&b, f64 d)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf vector3d}$<$T$>$\& {\bf irr\+::core\+::vector3d}$<$ T $>$\+::interpolate (
\begin{DoxyParamCaption}
\item[{const {\bf vector3d}$<$ T $>$ \&}]{a, }
\item[{const {\bf vector3d}$<$ T $>$ \&}]{b, }
\item[{{\bf f64}}]{d}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_a32a888e0f608a20deee98c794a321c4c}{}\label{classirr_1_1core_1_1vector3d_a32a888e0f608a20deee98c794a321c4c}


Sets this vector to the linearly interpolated vector between a and b. 


\begin{DoxyParams}{Parameters}
{\em a} & first vector to interpolate with, maximum at 1.\+0f \\
\hline
{\em b} & second vector to interpolate with, maximum at 0.\+0f \\
\hline
{\em d} & Interpolation value between 0.\+0f (all vector b) and 1.\+0f (all vector a) Note that this is the opposite direction of interpolation to \hyperlink{classirr_1_1core_1_1vector3d_adb749559ee0941687d4692941146a388}{get\+Interpolated\+\_\+quadratic()} \\
\hline
\end{DoxyParams}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!is\+Between\+Points@{is\+Between\+Points}}
\index{is\+Between\+Points@{is\+Between\+Points}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{is\+Between\+Points(const vector3d$<$ T $>$ \&begin, const vector3d$<$ T $>$ \&end) const }{isBetweenPoints(const vector3d< T > \&begin, const vector3d< T > \&end) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ bool {\bf irr\+::core\+::vector3d}$<$ T $>$\+::is\+Between\+Points (
\begin{DoxyParamCaption}
\item[{const {\bf vector3d}$<$ T $>$ \&}]{begin, }
\item[{const {\bf vector3d}$<$ T $>$ \&}]{end}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_ace05ee3b68b47c2ec6baff0d9d64de98}{}\label{classirr_1_1core_1_1vector3d_ace05ee3b68b47c2ec6baff0d9d64de98}


Returns if this vector interpreted as a point is on a line between two other points. 

It is assumed that the point is on the line. 
\begin{DoxyParams}{Parameters}
{\em begin} & Beginning vector to compare between. \\
\hline
{\em end} & Ending vector to compare between. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if this vector is between begin and end, false if not. 
\end{DoxyReturn}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!normalize@{normalize}}
\index{normalize@{normalize}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{normalize()}{normalize()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf vector3d}$<$T$>$\& {\bf irr\+::core\+::vector3d}$<$ T $>$\+::normalize (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_a84a1861464ef70e6965c146732103c09}{}\label{classirr_1_1core_1_1vector3d_a84a1861464ef70e6965c146732103c09}


Normalizes the vector. 

In case of the 0 vector the result is still 0, otherwise the length of the vector will be 1. \begin{DoxyReturn}{Returns}
Reference to this vector after normalization. 
\end{DoxyReturn}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!rotate\+X\+Y\+By@{rotate\+X\+Y\+By}}
\index{rotate\+X\+Y\+By@{rotate\+X\+Y\+By}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{rotate\+X\+Y\+By(f64 degrees, const vector3d$<$ T $>$ \&center=vector3d$<$ T $>$())}{rotateXYBy(f64 degrees, const vector3d< T > \&center=vector3d< T >())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::vector3d}$<$ T $>$\+::rotate\+X\+Y\+By (
\begin{DoxyParamCaption}
\item[{{\bf f64}}]{degrees, }
\item[{const {\bf vector3d}$<$ T $>$ \&}]{center = {\ttfamily {\bf vector3d}$<$T$>$()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_ac38b75735ec06716305fbb09ec71784d}{}\label{classirr_1_1core_1_1vector3d_ac38b75735ec06716305fbb09ec71784d}


Rotates the vector by a specified number of degrees around the Z axis and the specified center. 


\begin{DoxyParams}{Parameters}
{\em degrees} & Number of degrees to rotate around the Z axis. \\
\hline
{\em center} & The center of the rotation. \\
\hline
\end{DoxyParams}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!rotate\+X\+Z\+By@{rotate\+X\+Z\+By}}
\index{rotate\+X\+Z\+By@{rotate\+X\+Z\+By}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{rotate\+X\+Z\+By(f64 degrees, const vector3d$<$ T $>$ \&center=vector3d$<$ T $>$())}{rotateXZBy(f64 degrees, const vector3d< T > \&center=vector3d< T >())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::vector3d}$<$ T $>$\+::rotate\+X\+Z\+By (
\begin{DoxyParamCaption}
\item[{{\bf f64}}]{degrees, }
\item[{const {\bf vector3d}$<$ T $>$ \&}]{center = {\ttfamily {\bf vector3d}$<$T$>$()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_a621fbddb42814edd3d14410252cf7b7a}{}\label{classirr_1_1core_1_1vector3d_a621fbddb42814edd3d14410252cf7b7a}


Rotates the vector by a specified number of degrees around the Y axis and the specified center. 


\begin{DoxyParams}{Parameters}
{\em degrees} & Number of degrees to rotate around the Y axis. \\
\hline
{\em center} & The center of the rotation. \\
\hline
\end{DoxyParams}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!rotate\+Y\+Z\+By@{rotate\+Y\+Z\+By}}
\index{rotate\+Y\+Z\+By@{rotate\+Y\+Z\+By}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{rotate\+Y\+Z\+By(f64 degrees, const vector3d$<$ T $>$ \&center=vector3d$<$ T $>$())}{rotateYZBy(f64 degrees, const vector3d< T > \&center=vector3d< T >())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ void {\bf irr\+::core\+::vector3d}$<$ T $>$\+::rotate\+Y\+Z\+By (
\begin{DoxyParamCaption}
\item[{{\bf f64}}]{degrees, }
\item[{const {\bf vector3d}$<$ T $>$ \&}]{center = {\ttfamily {\bf vector3d}$<$T$>$()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_aaa048312f75f152861479cb48e2ddfe4}{}\label{classirr_1_1core_1_1vector3d_aaa048312f75f152861479cb48e2ddfe4}


Rotates the vector by a specified number of degrees around the X axis and the specified center. 


\begin{DoxyParams}{Parameters}
{\em degrees} & Number of degrees to rotate around the X axis. \\
\hline
{\em center} & The center of the rotation. \\
\hline
\end{DoxyParams}
\index{irr\+::core\+::vector3d@{irr\+::core\+::vector3d}!rotation\+To\+Direction@{rotation\+To\+Direction}}
\index{rotation\+To\+Direction@{rotation\+To\+Direction}!irr\+::core\+::vector3d@{irr\+::core\+::vector3d}}
\subsubsection[{\texorpdfstring{rotation\+To\+Direction(const vector3d$<$ T $>$ \&forwards=vector3d$<$ T $>$(0, 0, 1)) const }{rotationToDirection(const vector3d< T > \&forwards=vector3d< T >(0, 0, 1)) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T$>$ {\bf vector3d}$<$T$>$ {\bf irr\+::core\+::vector3d}$<$ T $>$\+::rotation\+To\+Direction (
\begin{DoxyParamCaption}
\item[{const {\bf vector3d}$<$ T $>$ \&}]{forwards = {\ttfamily {\bf vector3d}$<$T$>$(0,~0,~1)}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classirr_1_1core_1_1vector3d_a4db5cfbb71995227e37334a19278474d}{}\label{classirr_1_1core_1_1vector3d_a4db5cfbb71995227e37334a19278474d}


Builds a direction vector from (this) rotation vector. 

This vector is assumed to be a rotation vector composed of 3 Euler angle rotations, in degrees. The implementation performs the same calculations as using a matrix to do the rotation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em forwards} & The direction representing \char`\"{}forwards\char`\"{} which will be rotated by this vector. If you do not provide a direction, then the +Z axis (0, 0, 1) will be assumed to be forwards. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A direction vector calculated by rotating the forwards direction by the 3 Euler angles (in degrees) represented by this vector. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/vector3d.\+h\end{DoxyCompactItemize}
