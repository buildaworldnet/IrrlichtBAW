\hypertarget{classirr_1_1video_1_1IVideoDriver}{}\section{irr\+:\+:video\+:\+:I\+Video\+Driver Class Reference}
\label{classirr_1_1video_1_1IVideoDriver}\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}


Interface to driver which is able to perform 2d and 3d graphics functions.  




{\ttfamily \#include $<$I\+Video\+Driver.\+h$>$}

Inheritance diagram for irr\+:\+:video\+:\+:I\+Video\+Driver\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classirr_1_1video_1_1IVideoDriver}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classirr_1_1video_1_1IGPUBuffer}{I\+G\+P\+U\+Buffer} $\ast$ {\bfseries create\+G\+P\+U\+Buffer} (const size\+\_\+t \&size, const void $\ast$data, const bool can\+Modify\+Sub\+Data=false, const bool \&in\+C\+P\+U\+Mem=false, const E\+\_\+\+G\+P\+U\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+A\+C\+C\+E\+SS \&usage\+Pattern=E\+G\+B\+A\+\_\+\+N\+O\+NE)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_ad8cfbfe854ca31d578870cb2dedfe1a3}{}\label{classirr_1_1video_1_1IVideoDriver_ad8cfbfe854ca31d578870cb2dedfe1a3}

\item 
virtual \hyperlink{classirr_1_1video_1_1IGPUMappedBuffer}{I\+G\+P\+U\+Mapped\+Buffer} $\ast$ {\bfseries create\+Persistently\+Mapped\+Buffer} (const size\+\_\+t \&size, const void $\ast$data, const E\+\_\+\+G\+P\+U\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+A\+C\+C\+E\+SS \&usage\+Pattern, const bool \&assumed\+Coherent, const bool \&in\+C\+P\+U\+Mem=true)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a62005b92bf8cd24c1fd1a08ddfd4faec}{}\label{classirr_1_1video_1_1IVideoDriver_a62005b92bf8cd24c1fd1a08ddfd4faec}

\item 
virtual \hyperlink{classirr_1_1scene_1_1IMeshDataFormatDesc}{scene\+::\+I\+G\+P\+U\+Mesh\+Data\+Format\+Desc} $\ast$ {\bfseries create\+G\+P\+U\+Mesh\+Data\+Format\+Desc} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a29e5b923cdc8ec2d6d265e317608e368}{}\label{classirr_1_1video_1_1IVideoDriver_a29e5b923cdc8ec2d6d265e317608e368}

\item 
virtual \hyperlink{classirr_1_1scene_1_1IMesh}{scene\+::\+I\+G\+P\+U\+Mesh} $\ast$ {\bfseries create\+G\+P\+U\+Mesh\+From\+C\+PU} (\hyperlink{classirr_1_1scene_1_1IMesh}{scene\+::\+I\+C\+P\+U\+Mesh} $\ast$mesh, const E\+\_\+\+M\+E\+S\+H\+\_\+\+D\+E\+S\+C\+\_\+\+C\+O\+N\+V\+E\+R\+T\+\_\+\+B\+E\+H\+A\+V\+I\+O\+UR \&buffer\+Options=E\+M\+D\+C\+B\+\_\+\+C\+L\+O\+N\+E\+\_\+\+A\+N\+D\+\_\+\+M\+I\+R\+R\+O\+R\+\_\+\+L\+A\+Y\+O\+UT)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a7a40fc1ab509af104a505e394ce61ac2}{}\label{classirr_1_1video_1_1IVideoDriver_a7a40fc1ab509af104a505e394ce61ac2}

\item 
virtual void {\bfseries buffer\+Copy} (\hyperlink{classirr_1_1video_1_1IGPUBuffer}{I\+G\+P\+U\+Buffer} $\ast$read\+Buffer, \hyperlink{classirr_1_1video_1_1IGPUBuffer}{I\+G\+P\+U\+Buffer} $\ast$write\+Buffer, const size\+\_\+t \&read\+Offset, const size\+\_\+t \&write\+Offset, const size\+\_\+t \&length)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_adb4634036e04db7614a0cf0f18030333}{}\label{classirr_1_1video_1_1IVideoDriver_adb4634036e04db7614a0cf0f18030333}

\item 
virtual bool {\bfseries init\+Aux\+Context} (const size\+\_\+t \&ctx\+Ix)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a6806af376ade2139e653a1c1c4a912a8}{}\label{classirr_1_1video_1_1IVideoDriver_a6806af376ade2139e653a1c1c4a912a8}

\item 
virtual bool {\bfseries deinit\+Aux\+Context} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a54d1cc3527f786faef44892a86f3ad65}{}\label{classirr_1_1video_1_1IVideoDriver_a54d1cc3527f786faef44892a86f3ad65}

\item 
virtual bool \hyperlink{classirr_1_1video_1_1IVideoDriver_a015b8f2f18c260a00a858181be1e9945}{begin\+Scene} (bool back\+Buffer=true, bool z\+Buffer=true, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{S\+Color}(255, 0, 0, 0), const \hyperlink{structirr_1_1video_1_1SExposedVideoData}{S\+Exposed\+Video\+Data} \&video\+Data=\hyperlink{structirr_1_1video_1_1SExposedVideoData}{S\+Exposed\+Video\+Data}(), \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $\ast$source\+Rect=0)=0
\begin{DoxyCompactList}\small\item\em Applications must call this method before performing any rendering. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1video_1_1IVideoDriver_a75f61a93c5fc9fdf161c044d27bc994e}{end\+Scene} ()=0
\begin{DoxyCompactList}\small\item\em Presents the rendered image to the screen. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1video_1_1IVideoDriver_acf2585c46d032904267887284c6e041c}{query\+Feature} (\hyperlink{namespaceirr_1_1video_a57b1721e42a79c5dcf8e830e3621e08f}{E\+\_\+\+V\+I\+D\+E\+O\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+F\+E\+A\+T\+U\+RE} feature) const  =0
\begin{DoxyCompactList}\small\item\em Queries the features of the driver. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_aea64c03fc205f23ec7575884fb7309c8}{disable\+Feature} (\hyperlink{namespaceirr_1_1video_a57b1721e42a79c5dcf8e830e3621e08f}{E\+\_\+\+V\+I\+D\+E\+O\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+F\+E\+A\+T\+U\+RE} feature, bool flag=true)=0
\begin{DoxyCompactList}\small\item\em Disable a feature of the driver. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1video_1_1IVideoDriver_a4ba84ee992939fc913d4935caffce87b}{check\+Driver\+Reset} ()=0
\begin{DoxyCompactList}\small\item\em Check if the driver was recently reset. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a827c428b9f83d07bfb4c6f2a0cb7dd07}{set\+Transform} (const \hyperlink{namespaceirr_1_1video_a9f34b0dd7b888c8cbabb22989f23b853}{E\+\_\+4\+X3\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+A\+T\+I\+O\+N\+\_\+\+S\+T\+A\+TE} \&state, const \hyperlink{classirr_1_1core_1_1matrix4x3}{core\+::matrix4x3} \&mat)=0
\begin{DoxyCompactList}\small\item\em Sets transformation matrices. \end{DoxyCompactList}\item 
virtual void {\bfseries set\+Transform} (const \hyperlink{namespaceirr_1_1video_a1336265bc542e3a3855f420565d889b6}{E\+\_\+\+P\+R\+O\+J\+E\+C\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+A\+T\+I\+O\+N\+\_\+\+S\+T\+A\+TE} \&state, const \hyperlink{namespaceirr_1_1core_a73fa92e638c5ca97efd72da307cc9b65}{core\+::matrix4} \&mat)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a0f13f6748f018bec8f2ec5c6a4e7fabe}{}\label{classirr_1_1video_1_1IVideoDriver_a0f13f6748f018bec8f2ec5c6a4e7fabe}

\item 
virtual const \hyperlink{classirr_1_1core_1_1matrix4x3}{core\+::matrix4x3} \& \hyperlink{classirr_1_1video_1_1IVideoDriver_a36c57effe355831805e340a4a1ee69b7}{get\+Transform} (const \hyperlink{namespaceirr_1_1video_a9f34b0dd7b888c8cbabb22989f23b853}{E\+\_\+4\+X3\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+A\+T\+I\+O\+N\+\_\+\+S\+T\+A\+TE} \&state)=0
\begin{DoxyCompactList}\small\item\em Returns the transformation set by set\+Transform. \end{DoxyCompactList}\item 
virtual const \hyperlink{namespaceirr_1_1core_a73fa92e638c5ca97efd72da307cc9b65}{core\+::matrix4} \& {\bfseries get\+Transform} (const \hyperlink{namespaceirr_1_1video_a1336265bc542e3a3855f420565d889b6}{E\+\_\+\+P\+R\+O\+J\+E\+C\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+A\+T\+I\+O\+N\+\_\+\+S\+T\+A\+TE} \&state)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_ad8676494c4eb637d5d978df60c57ab68}{}\label{classirr_1_1video_1_1IVideoDriver_ad8676494c4eb637d5d978df60c57ab68}

\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1video_1_1IVideoDriver_a672575822cce8b590b6ed709f08cdaac}{get\+Image\+Loader\+Count} () const  =0
\begin{DoxyCompactList}\small\item\em Retrieve the number of image loaders. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IImageLoader}{I\+Image\+Loader} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_a5cc08e7cd2ce2a30275e22ce13bb1013}{get\+Image\+Loader} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} n)=0
\begin{DoxyCompactList}\small\item\em Retrieve the given image loader. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1video_1_1IVideoDriver_ab8765c883399c84fca2165309e19d65e}{get\+Image\+Writer\+Count} () const  =0
\begin{DoxyCompactList}\small\item\em Retrieve the number of image writers. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IImageWriter}{I\+Image\+Writer} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_acdc5e788993c117efebb22e155ab6a77}{get\+Image\+Writer} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} n)=0
\begin{DoxyCompactList}\small\item\em Retrieve the given image writer. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a8c9e31b41b7e6fd26cf65ce538ebab05}{set\+Material} (const \hyperlink{classirr_1_1video_1_1SMaterial}{S\+Material} \&material)=0
\begin{DoxyCompactList}\small\item\em Sets a material. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IDriverFence}{I\+Driver\+Fence} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_aafdf5e755656fdd9f35d8ff8314db439}{place\+Fence} ()=0
\begin{DoxyCompactList}\small\item\em needs to be \char`\"{}deleted\char`\"{} since its not refcounted \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1ITexture}{I\+Texture} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_af4055165190e4adf221c6dc6f2434ea0}{get\+Texture} (const \hyperlink{namespaceirr_1_1io_ab1bdc45edb3f94d8319c02bc0f840ee1}{io\+::path} \&filename)=0
\begin{DoxyCompactList}\small\item\em Get access to a named texture. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1ITexture}{I\+Texture} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_aaf989c8688ffe2a28a4b8e7b6ec2bce7}{get\+Texture} (\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$file)=0
\begin{DoxyCompactList}\small\item\em Get access to a named texture. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1ITexture}{I\+Texture} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_abfe395b1320ac52cea6be0e912135351}{get\+Texture\+By\+Index} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index)=0
\begin{DoxyCompactList}\small\item\em Returns a texture by index. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1video_1_1IVideoDriver_acdfe6845b292baeff2fa160890c6d193}{get\+Texture\+Count} () const  =0
\begin{DoxyCompactList}\small\item\em Returns amount of textures currently loaded. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a2cefddb9ebd7f46ee946c04b301a5c5b}{rename\+Texture} (\hyperlink{classirr_1_1video_1_1ITexture}{I\+Texture} $\ast$texture, const \hyperlink{namespaceirr_1_1io_ab1bdc45edb3f94d8319c02bc0f840ee1}{io\+::path} \&new\+Name)=0
\begin{DoxyCompactList}\small\item\em Renames a texture. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1ITexture}{I\+Texture} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_a10d535f75351c4c65ac29a30407db530}{add\+Texture} (const I\+Texture\+::\+E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+T\+Y\+PE \&type, const uint32\+\_\+t $\ast$size, uint32\+\_\+t mipmap\+Levels, const \hyperlink{namespaceirr_1_1io_ab1bdc45edb3f94d8319c02bc0f840ee1}{io\+::path} \&name, \hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829ed}{E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT} format=\hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829eda55c57d63efff39efe33ee733fe962df0}{E\+C\+F\+\_\+\+A8\+R8\+G8\+B8})=0
\begin{DoxyCompactList}\small\item\em Creates an empty texture of specified size. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1ITexture}{I\+Texture} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_abfebeb09a692c0d6b4741d952d97668e}{add\+Texture} (const \hyperlink{namespaceirr_1_1io_ab1bdc45edb3f94d8319c02bc0f840ee1}{io\+::path} \&name, \hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$image, void $\ast$mipmap\+Data=0)=0
\begin{DoxyCompactList}\small\item\em Creates a texture from an \hyperlink{classirr_1_1video_1_1IImage}{I\+Image}. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IRenderBuffer}{I\+Render\+Buffer} $\ast$ {\bfseries add\+Render\+Buffer} (const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&size, \hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829ed}{E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT} format=\hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829eda55c57d63efff39efe33ee733fe962df0}{E\+C\+F\+\_\+\+A8\+R8\+G8\+B8})=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a4c57d9a7ea6df655946b55d0b06431f9}{}\label{classirr_1_1video_1_1IVideoDriver_a4c57d9a7ea6df655946b55d0b06431f9}

\item 
virtual \hyperlink{classirr_1_1video_1_1IFrameBuffer}{I\+Frame\+Buffer} $\ast$ {\bfseries add\+Frame\+Buffer} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a3d5b472fbe5fbbe0d7d40a69bb71b58a}{}\label{classirr_1_1video_1_1IVideoDriver_a3d5b472fbe5fbbe0d7d40a69bb71b58a}

\item 
virtual void {\bfseries blit\+Render\+Targets} (\hyperlink{classirr_1_1video_1_1IFrameBuffer}{I\+Frame\+Buffer} $\ast$in, \hyperlink{classirr_1_1video_1_1IFrameBuffer}{I\+Frame\+Buffer} $\ast$out, bool copy\+Depth=true, \hyperlink{namespaceirr_1_1core_a628365d56b9d3ca9c887cd7f651f7b45}{core\+::recti} src\+Rect=\hyperlink{namespaceirr_1_1core_a628365d56b9d3ca9c887cd7f651f7b45}{core\+::recti}(0, 0, 0, 0), \hyperlink{namespaceirr_1_1core_a628365d56b9d3ca9c887cd7f651f7b45}{core\+::recti} dst\+Rect=\hyperlink{namespaceirr_1_1core_a628365d56b9d3ca9c887cd7f651f7b45}{core\+::recti}(0, 0, 0, 0), bool bilinear\+Filter=false)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a1e066a013cb212d7f469b7f4deeb1f37}{}\label{classirr_1_1video_1_1IVideoDriver_a1e066a013cb212d7f469b7f4deeb1f37}

\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_ac88319ec41daa23fef2ae935285afcc9}{remove\+Texture} (\hyperlink{classirr_1_1video_1_1ITexture}{I\+Texture} $\ast$texture)=0
\begin{DoxyCompactList}\small\item\em Removes a texture from the texture cache and deletes it. \end{DoxyCompactList}\item 
virtual void {\bfseries remove\+Render\+Buffer} (\hyperlink{classirr_1_1video_1_1IRenderBuffer}{I\+Render\+Buffer} $\ast$renderbuf)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a58817dcfb83529e627504b095edafbe4}{}\label{classirr_1_1video_1_1IVideoDriver_a58817dcfb83529e627504b095edafbe4}

\item 
virtual void {\bfseries remove\+Frame\+Buffer} (\hyperlink{classirr_1_1video_1_1IFrameBuffer}{I\+Frame\+Buffer} $\ast$framebuf)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a02616480a0d14d2b5b5e06727a58fdc1}{}\label{classirr_1_1video_1_1IVideoDriver_a02616480a0d14d2b5b5e06727a58fdc1}

\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a179990e76fa91175d46c891b3508e717}{remove\+All\+Textures} ()=0
\begin{DoxyCompactList}\small\item\em Removes all textures from the texture cache and deletes them. \end{DoxyCompactList}\item 
virtual void {\bfseries remove\+All\+Render\+Buffers} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_af81a6192421b73903c2bc3a422337e59}{}\label{classirr_1_1video_1_1IVideoDriver_af81a6192421b73903c2bc3a422337e59}

\item 
virtual void {\bfseries remove\+All\+Frame\+Buffers} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_ad32e60d68c5121d1414539dc1648ae6a}{}\label{classirr_1_1video_1_1IVideoDriver_ad32e60d68c5121d1414539dc1648ae6a}

\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_abda0f0cef1461cb199270e367280861e}{begin\+Query} (\hyperlink{classirr_1_1video_1_1IQueryObject}{I\+Query\+Object} $\ast$query)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_abda0f0cef1461cb199270e367280861e}{}\label{classirr_1_1video_1_1IVideoDriver_abda0f0cef1461cb199270e367280861e}

\begin{DoxyCompactList}\small\item\em Queries. \end{DoxyCompactList}\item 
virtual void {\bfseries end\+Query} (\hyperlink{classirr_1_1video_1_1IQueryObject}{I\+Query\+Object} $\ast$query)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_ac73bd1ad0502d6010edd95db52fdbb90}{}\label{classirr_1_1video_1_1IVideoDriver_ac73bd1ad0502d6010edd95db52fdbb90}

\item 
virtual void {\bfseries begin\+Query} (\hyperlink{classirr_1_1video_1_1IQueryObject}{I\+Query\+Object} $\ast$query, const size\+\_\+t \&index)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a88af402abf5273aa277f888f526430b9}{}\label{classirr_1_1video_1_1IVideoDriver_a88af402abf5273aa277f888f526430b9}

\item 
virtual void {\bfseries end\+Query} (\hyperlink{classirr_1_1video_1_1IQueryObject}{I\+Query\+Object} $\ast$query, const size\+\_\+t \&index)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a2c58e5c0bf72f153306eca4c4e427f26}{}\label{classirr_1_1video_1_1IVideoDriver_a2c58e5c0bf72f153306eca4c4e427f26}

\item 
virtual \hyperlink{classirr_1_1video_1_1IOcclusionQuery}{I\+Occlusion\+Query} $\ast$ {\bfseries create\+Occlusion\+Query} (const E\+\_\+\+O\+C\+C\+L\+U\+S\+I\+O\+N\+\_\+\+Q\+U\+E\+R\+Y\+\_\+\+T\+Y\+PE \&heuristic)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a1e20c5d721d84428cfcd92b849aa8fe5}{}\label{classirr_1_1video_1_1IVideoDriver_a1e20c5d721d84428cfcd92b849aa8fe5}

\item 
virtual \hyperlink{classirr_1_1video_1_1IQueryObject}{I\+Query\+Object} $\ast$ {\bfseries create\+Primitives\+Generated\+Query} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a94828950c426987af5fef58924474d96}{}\label{classirr_1_1video_1_1IVideoDriver_a94828950c426987af5fef58924474d96}

\item 
virtual \hyperlink{classirr_1_1video_1_1IQueryObject}{I\+Query\+Object} $\ast$ {\bfseries create\+X\+Form\+Feedback\+Primitive\+Query} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a750c25703eb080d45a966d34a24aa227}{}\label{classirr_1_1video_1_1IVideoDriver_a750c25703eb080d45a966d34a24aa227}

\item 
virtual \hyperlink{classirr_1_1video_1_1IQueryObject}{I\+Query\+Object} $\ast$ {\bfseries create\+Elapsed\+Time\+Query} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a4c5180420fa55523508c335a416048b4}{}\label{classirr_1_1video_1_1IVideoDriver_a4c5180420fa55523508c335a416048b4}

\item 
virtual \hyperlink{classirr_1_1video_1_1IGPUTimestampQuery}{I\+G\+P\+U\+Timestamp\+Query} $\ast$ {\bfseries create\+Timestamp\+Query} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a144176498753bebd35210bfc443a3c44}{}\label{classirr_1_1video_1_1IVideoDriver_a144176498753bebd35210bfc443a3c44}

\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a6b349355b288c0b4ec69271e0d5cfc6b}{make\+Normal\+Map\+Texture} (\hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$texture, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} amplitude=1.\+0f) const  =0
\begin{DoxyCompactList}\small\item\em Creates a normal map from a height map texture. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1video_1_1IVideoDriver_a6ae8e7ce16215e5d0e8a0c155029aaa1}{set\+Render\+Target} (\hyperlink{classirr_1_1video_1_1IFrameBuffer}{I\+Frame\+Buffer} $\ast$frame\+Buffer, bool set\+New\+Viewport=true)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a6ae8e7ce16215e5d0e8a0c155029aaa1}{}\label{classirr_1_1video_1_1IVideoDriver_a6ae8e7ce16215e5d0e8a0c155029aaa1}

\begin{DoxyCompactList}\small\item\em Sets new multiple render targets. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a1cdd936731066604668e7be11cfead8d}{clear\+Z\+Buffer} (const float \&depth=0.\+0)=0
\begin{DoxyCompactList}\small\item\em Clears the Z\+Buffer. \end{DoxyCompactList}\item 
virtual void {\bfseries clear\+Stencil\+Buffer} (const int32\+\_\+t \&stencil)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a9f7f193f3f4a76a9fc55caf8687570b0}{}\label{classirr_1_1video_1_1IVideoDriver_a9f7f193f3f4a76a9fc55caf8687570b0}

\item 
virtual void {\bfseries clear\+Z\+Stencil\+Buffers} (const float \&depth, const int32\+\_\+t \&stencil)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a295d58e3c6e84878f495404889740d77}{}\label{classirr_1_1video_1_1IVideoDriver_a295d58e3c6e84878f495404889740d77}

\item 
virtual void {\bfseries clear\+Color\+Buffer} (const E\+\_\+\+F\+B\+O\+\_\+\+A\+T\+T\+A\+C\+H\+M\+E\+N\+T\+\_\+\+P\+O\+I\+NT \&attachment, const int32\+\_\+t $\ast$vals)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_aeabb7de919c37d53dfed05ad4c62ff9e}{}\label{classirr_1_1video_1_1IVideoDriver_aeabb7de919c37d53dfed05ad4c62ff9e}

\item 
virtual void {\bfseries clear\+Color\+Buffer} (const E\+\_\+\+F\+B\+O\+\_\+\+A\+T\+T\+A\+C\+H\+M\+E\+N\+T\+\_\+\+P\+O\+I\+NT \&attachment, const uint32\+\_\+t $\ast$vals)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a2fd4e332386938874a56e787fb7d7eeb}{}\label{classirr_1_1video_1_1IVideoDriver_a2fd4e332386938874a56e787fb7d7eeb}

\item 
virtual void {\bfseries clear\+Color\+Buffer} (const E\+\_\+\+F\+B\+O\+\_\+\+A\+T\+T\+A\+C\+H\+M\+E\+N\+T\+\_\+\+P\+O\+I\+NT \&attachment, const float $\ast$vals)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a89e94068508574cc1327a9c634022c57}{}\label{classirr_1_1video_1_1IVideoDriver_a89e94068508574cc1327a9c634022c57}

\item 
virtual void {\bfseries clear\+Screen} (const E\+\_\+\+S\+C\+R\+E\+E\+N\+\_\+\+B\+U\+F\+F\+E\+RS \&buffer, const float $\ast$vals)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a046d35598e7bf1e540cbb0ae91c73d02}{}\label{classirr_1_1video_1_1IVideoDriver_a046d35598e7bf1e540cbb0ae91c73d02}

\item 
virtual void {\bfseries clear\+Screen} (const E\+\_\+\+S\+C\+R\+E\+E\+N\+\_\+\+B\+U\+F\+F\+E\+RS \&buffer, const uint32\+\_\+t $\ast$vals)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a0a549d901e085c6f9ab0819cce03314b}{}\label{classirr_1_1video_1_1IVideoDriver_a0a549d901e085c6f9ab0819cce03314b}

\item 
virtual \hyperlink{classirr_1_1video_1_1ITransformFeedback}{I\+Transform\+Feedback} $\ast$ {\bfseries create\+Transform\+Feedback} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a35d53be79765ac777e5b2bf8a9661c51}{}\label{classirr_1_1video_1_1IVideoDriver_a35d53be79765ac777e5b2bf8a9661c51}

\item 
virtual void {\bfseries bind\+Transform\+Feedback} (\hyperlink{classirr_1_1video_1_1ITransformFeedback}{I\+Transform\+Feedback} $\ast$xform\+Feedback)=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a56cd7dcee97b68dcabfff12ec53f2fd4}{}\label{classirr_1_1video_1_1IVideoDriver_a56cd7dcee97b68dcabfff12ec53f2fd4}

\item 
virtual \hyperlink{classirr_1_1video_1_1ITransformFeedback}{I\+Transform\+Feedback} $\ast$ {\bfseries get\+Bound\+Transform\+Feedback} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_aaf763ec31cb9281ea403716a92c09410}{}\label{classirr_1_1video_1_1IVideoDriver_aaf763ec31cb9281ea403716a92c09410}

\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a2f5b83de6b1fff8059d443760a1e266e}{begin\+Transform\+Feedback} (\hyperlink{classirr_1_1video_1_1ITransformFeedback}{I\+Transform\+Feedback} $\ast$xform\+Feedback, const \hyperlink{namespaceirr_1_1video_ac8e9b6c66f7cebabd1a6d30cbc5430f1}{E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+\_\+\+T\+Y\+PE} \&xform\+Feedback\+Shader, const \hyperlink{namespaceirr_1_1scene_a5d7de82f2169761194b2f44d95cdc1dc}{scene\+::\+E\+\_\+\+P\+R\+I\+M\+I\+T\+I\+V\+E\+\_\+\+T\+Y\+PE} \&prim\+Type=\hyperlink{namespaceirr_1_1scene_a5d7de82f2169761194b2f44d95cdc1dca180689eadf794441c2c2dcd87462e203}{scene\+::\+E\+P\+T\+\_\+\+P\+O\+I\+N\+TS})=0
\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a48d9a5dddc334f33b7183d51e2632fdf}{pause\+Transform\+Feedback} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a48d9a5dddc334f33b7183d51e2632fdf}{}\label{classirr_1_1video_1_1IVideoDriver_a48d9a5dddc334f33b7183d51e2632fdf}

\begin{DoxyCompactList}\small\item\em A redundant wrapper call to \hyperlink{classirr_1_1video_1_1ITransformFeedback_ad6b5bfc841c37ea0c52eb40cf30b61c6}{I\+Transform\+Feedback\+::pause\+Transform\+Feedback()}, made just for clarity. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a0b4f5b82710a7a861f68898987f93ad1}{resume\+Transform\+Feedback} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a0b4f5b82710a7a861f68898987f93ad1}{}\label{classirr_1_1video_1_1IVideoDriver_a0b4f5b82710a7a861f68898987f93ad1}

\begin{DoxyCompactList}\small\item\em A redundant wrapper call to \hyperlink{classirr_1_1video_1_1ITransformFeedback_ad6b5bfc841c37ea0c52eb40cf30b61c6}{I\+Transform\+Feedback\+::pause\+Transform\+Feedback()}, made just for clarity. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a692be066885a3d0a5b777bfd16cac196}{end\+Transform\+Feedback} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a692be066885a3d0a5b777bfd16cac196}{}\label{classirr_1_1video_1_1IVideoDriver_a692be066885a3d0a5b777bfd16cac196}

\begin{DoxyCompactList}\small\item\em This issues an implicit call to bind\+Transform\+Feedback(\+N\+U\+L\+L) \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_af03cf9b67bb7b43a8021bbe4baa78a08}{set\+View\+Port} (const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&area)=0
\begin{DoxyCompactList}\small\item\em Sets a new viewport. \end{DoxyCompactList}\item 
virtual const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \& \hyperlink{classirr_1_1video_1_1IVideoDriver_aaf6c38991ee735a26acf0c70ffa463e6}{get\+View\+Port} () const  =0
\begin{DoxyCompactList}\small\item\em Gets the area of the current viewport. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a5e4e03dca1720f3d2019b73a4eebb5e6}{draw3\+D\+Line} (const \hyperlink{namespaceirr_1_1core_a06f169d08b5c429f5575acb7edbad811}{core\+::vector3df} \&start, const \hyperlink{namespaceirr_1_1core_a06f169d08b5c429f5575acb7edbad811}{core\+::vector3df} \&end, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{S\+Color}(255, 255, 255, 255))=0
\begin{DoxyCompactList}\small\item\em Draws a 3d line. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a7773fce9358ee81db5484b2d21015570}{draw3\+D\+Box} (const \hyperlink{classirr_1_1core_1_1aabbox3d}{core\+::aabbox3d}$<$ \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} $>$ \&box, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{S\+Color}(255, 255, 255, 255))=0
\begin{DoxyCompactList}\small\item\em Draws a 3d axis aligned box. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_ac1f12aefefb24414e03876bca942fb02}{draw2\+D\+Image} (const \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$texture, const core\+::position2d$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&dest\+Pos)=0
\begin{DoxyCompactList}\small\item\em Draws a 2d image without any special effects. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a167d3a5e2ea5804bfa9ba9e526bbcdb3}{draw2\+D\+Image} (const \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$texture, const core\+::position2d$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&dest\+Pos, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&source\+Rect, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $\ast$clip\+Rect=0, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{S\+Color}(255, 255, 255, 255), bool use\+Alpha\+Channel\+Of\+Texture=false)=0
\begin{DoxyCompactList}\small\item\em Draws a 2d image using a color. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a1b7647e900a56f23abb0809fd533617e}{draw2\+D\+Image\+Batch} (const \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$texture, const core\+::position2d$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&pos, const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $>$ \&source\+Rects, const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&indices, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} kerning\+Width=0, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $\ast$clip\+Rect=0, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{S\+Color}(255, 255, 255, 255), bool use\+Alpha\+Channel\+Of\+Texture=false)=0
\begin{DoxyCompactList}\small\item\em Draws a set of 2d images, using a color and the alpha channel of the texture. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a6485a684c4dfa4d0f94d0edfb46439a6}{draw2\+D\+Image\+Batch} (const \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$texture, const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ core\+::position2d$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $>$ \&positions, const \hyperlink{classirr_1_1core_1_1array}{core\+::array}$<$ \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $>$ \&source\+Rects, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $\ast$clip\+Rect=0, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{S\+Color}(255, 255, 255, 255), bool use\+Alpha\+Channel\+Of\+Texture=false)=0
\begin{DoxyCompactList}\small\item\em Draws a set of 2d images, using a color and the alpha channel of the texture. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a49258725a8c36dbb22d073acf7927354}{draw2\+D\+Image} (const \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$texture, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&dest\+Rect, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&source\+Rect, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $\ast$clip\+Rect=0, const \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} $\ast$const colors=0, bool use\+Alpha\+Channel\+Of\+Texture=false)=0
\begin{DoxyCompactList}\small\item\em Draws a part of the texture into the rectangle. Note that colors must be an array of 4 colors if used. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_ac7f452fae0ef8abe01768a78ba7033b7}{draw2\+D\+Rectangle} (\hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&pos, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $\ast$clip=0)=0
\begin{DoxyCompactList}\small\item\em Draws a 2d rectangle. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a83bb3c30be6c9f960a4d8b625d7dee8c}{draw2\+D\+Rectangle} (const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&pos, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color\+Left\+Up, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color\+Right\+Up, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color\+Left\+Down, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color\+Right\+Down, const \hyperlink{classirr_1_1core_1_1rect}{core\+::rect}$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ $\ast$clip=0)=0
\begin{DoxyCompactList}\small\item\em Draws a 2d rectangle with a gradient. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a65efe36e19f0570988848175a8af7bd1}{draw2\+D\+Rectangle\+Outline} (const \hyperlink{namespaceirr_1_1core_a628365d56b9d3ca9c887cd7f651f7b45}{core\+::recti} \&pos, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{S\+Color}(255, 255, 255, 255))=0
\begin{DoxyCompactList}\small\item\em Draws the outline of a 2D rectangle. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a7b5388e319a0ae1340c3d81db02dd959}{draw2\+D\+Line} (const core\+::position2d$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&start, const core\+::position2d$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&end, \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{S\+Color}(255, 255, 255, 255))=0
\begin{DoxyCompactList}\small\item\em Draws a 2d line. Both start and end will be included in coloring. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a6567ced74ed6dc8cb1b325493ae7a093}{draw\+Pixel} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} x, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} y, const \hyperlink{classirr_1_1video_1_1SColor}{S\+Color} \&color)=0
\begin{DoxyCompactList}\small\item\em Draws a pixel. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_aaf1318379f3d70c9347cfa853b944ad4}{draw2\+D\+Polygon} (core\+::position2d$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ center, \hyperlink{namespaceirr_a0277be98d67dc26ff93b1a6a1d086b07}{f32} radius, \hyperlink{classirr_1_1video_1_1SColor}{video\+::\+S\+Color} color=\hyperlink{classirr_1_1video_1_1SColor}{S\+Color}(100, 255, 255, 255), \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} vertex\+Count=10)=0
\begin{DoxyCompactList}\small\item\em Draws a non filled concyclic regular 2d polyon. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a3f03e53661b1fc83d92cba4af7de6c70}{draw\+Mesh\+Buffer} (\hyperlink{classirr_1_1scene_1_1IGPUMeshBuffer}{scene\+::\+I\+G\+P\+U\+Mesh\+Buffer} $\ast$mb, \hyperlink{classirr_1_1video_1_1IOcclusionQuery}{I\+Occlusion\+Query} $\ast$query=N\+U\+LL)=0
\begin{DoxyCompactList}\small\item\em Draws a mesh buffer. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829ed}{E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT} \hyperlink{classirr_1_1video_1_1IVideoDriver_a9a4eaeebbeae43dc329b978a79d9e034}{get\+Color\+Format} () const  =0
\begin{DoxyCompactList}\small\item\em Get the current color format of the color buffer. \end{DoxyCompactList}\item 
virtual const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \& \hyperlink{classirr_1_1video_1_1IVideoDriver_a8c072ecaab1a2786a3feaf274fbb99b6}{get\+Screen\+Size} () const  =0
\begin{DoxyCompactList}\small\item\em Get the size of the screen or render window. \end{DoxyCompactList}\item 
virtual const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \& \hyperlink{classirr_1_1video_1_1IVideoDriver_a38c665baaf25dcfd510dd3413455af4c}{get\+Current\+Render\+Target\+Size} () const  =0
\begin{DoxyCompactList}\small\item\em Get the size of the current render target. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} \hyperlink{classirr_1_1video_1_1IVideoDriver_a2fd9d69e9fb01719b8bcff7a463929a8}{get\+F\+PS} () const  =0
\begin{DoxyCompactList}\small\item\em Returns current frames per second value. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1video_1_1IVideoDriver_a29e046d6b90563100a2f2b0b06294c7d}{get\+Primitive\+Count\+Drawn} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} mode=0) const  =0
\begin{DoxyCompactList}\small\item\em Returns amount of primitives (mostly triangles) which were drawn in the last frame. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_ab1bd29567ef6eb31a43bebe04c47eb5e}{delete\+All\+Dynamic\+Lights} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_ab1bd29567ef6eb31a43bebe04c47eb5e}{}\label{classirr_1_1video_1_1IVideoDriver_ab1bd29567ef6eb31a43bebe04c47eb5e}

\begin{DoxyCompactList}\small\item\em Deletes all dynamic lights which were previously added with \hyperlink{classirr_1_1video_1_1IVideoDriver_a813a39352eae26c4d30b5882618639be}{add\+Dynamic\+Light()}. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} \hyperlink{classirr_1_1video_1_1IVideoDriver_a813a39352eae26c4d30b5882618639be}{add\+Dynamic\+Light} (const \hyperlink{structirr_1_1video_1_1SLight}{S\+Light} \&light)=0
\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1video_1_1IVideoDriver_a242c9e9d469476eb28d55dc8a17b6622}{get\+Maximal\+Dynamic\+Light\+Amount} () const  =0
\begin{DoxyCompactList}\small\item\em Returns the maximal amount of dynamic lights the device can handle. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1video_1_1IVideoDriver_a4c85208c572dc8c37350bf0bd11583f8}{get\+Dynamic\+Light\+Count} () const  =0
\begin{DoxyCompactList}\small\item\em Returns amount of dynamic lights currently set. \end{DoxyCompactList}\item 
virtual const \hyperlink{structirr_1_1video_1_1SLight}{S\+Light} \& \hyperlink{classirr_1_1video_1_1IVideoDriver_aba32f5b6ba9bf1a9eabe54cf1649bb97}{get\+Dynamic\+Light} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} idx) const  =0
\begin{DoxyCompactList}\small\item\em Returns light data which was previously set by \hyperlink{classirr_1_1video_1_1IVideoDriver_a813a39352eae26c4d30b5882618639be}{I\+Video\+Driver\+::add\+Dynamic\+Light()}. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a3c26904f7d1bf0e37d51fe71562346a0}{turn\+Light\+On} (\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} light\+Index, bool turn\+On)=0
\item 
virtual const wchar\+\_\+t $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_a3effb1d6dd3ea2f4b2671eabf9b15d6e}{get\+Name} () const  =0
\begin{DoxyCompactList}\small\item\em Gets name of this video driver. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a9479ae15f0e26eaaf15c9420ff289b6d}{add\+External\+Image\+Loader} (\hyperlink{classirr_1_1video_1_1IImageLoader}{I\+Image\+Loader} $\ast$loader)=0
\begin{DoxyCompactList}\small\item\em Adds an external image loader to the engine. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a56160e0d88346e04db921fbe4635a7ae}{add\+External\+Image\+Writer} (\hyperlink{classirr_1_1video_1_1IImageWriter}{I\+Image\+Writer} $\ast$writer)=0
\begin{DoxyCompactList}\small\item\em Adds an external image writer to the engine. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1video_1_1IVideoDriver_a834b7db981d14737c9162a4e3368eb03}{get\+Maximal\+Indices\+Count} () const  =0
\begin{DoxyCompactList}\small\item\em Returns the maximum amount of primitives. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a868b58a6b86b9e4841ca3879ce246c4e}{set\+Texture\+Creation\+Flag} (\hyperlink{namespaceirr_1_1video_acaf6f7414534f7d62bff18c5bf11876f}{E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+C\+R\+E\+A\+T\+I\+O\+N\+\_\+\+F\+L\+AG} flag, bool enabled=true)=0
\begin{DoxyCompactList}\small\item\em Enables or disables a texture creation flag. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1video_1_1IVideoDriver_a44621435e1e6b518fc833e6a3c68a837}{get\+Texture\+Creation\+Flag} (\hyperlink{namespaceirr_1_1video_acaf6f7414534f7d62bff18c5bf11876f}{E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+C\+R\+E\+A\+T\+I\+O\+N\+\_\+\+F\+L\+AG} flag) const  =0
\begin{DoxyCompactList}\small\item\em Returns if a texture creation flag is enabled or disabled. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_ac5b4c13f64d96d27fa27f52b68f77b8c}{create\+Image\+From\+File} (const \hyperlink{namespaceirr_1_1io_ab1bdc45edb3f94d8319c02bc0f840ee1}{io\+::path} \&filename)=0
\begin{DoxyCompactList}\small\item\em Creates a software image from a file. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_a322c41fa08c1da9de4633cf8a1e68607}{create\+Image\+From\+File} (\hyperlink{classirr_1_1io_1_1IReadFile}{io\+::\+I\+Read\+File} $\ast$file)=0
\begin{DoxyCompactList}\small\item\em Creates a software image from a file. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1video_1_1IVideoDriver_a407d6a1483f995060035340e0a92ce9b}{write\+Image\+To\+File} (\hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$image, const \hyperlink{namespaceirr_1_1io_ab1bdc45edb3f94d8319c02bc0f840ee1}{io\+::path} \&filename, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} param=0)=0
\begin{DoxyCompactList}\small\item\em Writes the provided image to a file. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classirr_1_1video_1_1IVideoDriver_ae12c362cfbc92a7c59b434666c8436c0}{write\+Image\+To\+File} (\hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$image, \hyperlink{classirr_1_1io_1_1IWriteFile}{io\+::\+I\+Write\+File} $\ast$file, \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} param=0)=0
\begin{DoxyCompactList}\small\item\em Writes the provided image to a file. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_a425d60f2fcad42d8a79c33c587f41a06}{create\+Image\+From\+Data} (\hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829ed}{E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT} format, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&size, void $\ast$data, bool own\+Foreign\+Memory=false, bool delete\+Memory=true)=0
\begin{DoxyCompactList}\small\item\em Creates a software image from a byte array. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_aee1578fdd92118665755f31c0dd1dbb5}{create\+Image} (\hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829ed}{E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT} format, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&size)=0
\begin{DoxyCompactList}\small\item\em Creates an empty software image. \end{DoxyCompactList}\item 
virtual \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_af92ef735bc8c755f5c201a52a70d05e8}{create\+Image} (\hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829ed}{E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT} format, \hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$image\+To\+Copy)=0
\begin{DoxyCompactList}\small\item\em Creates a software image by converting it to given format from another image. \end{DoxyCompactList}\item 
virtual \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ \hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_aa06059abf33e473d7af77e1fbc2b0f75}{create\+Image} (\hyperlink{classirr_1_1video_1_1IImage}{I\+Image} $\ast$image\+To\+Copy, const core\+::position2d$<$ \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} $>$ \&pos, const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&size)=0
\begin{DoxyCompactList}\small\item\em Creates a software image from a part of another image. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a1a236e1233fc6fc2c5f36aaa830814fc}{On\+Resize} (const \hyperlink{classirr_1_1core_1_1dimension2d}{core\+::dimension2d}$<$ \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} $>$ \&size)=0
\begin{DoxyCompactList}\small\item\em Event handler for resize events. Only used by the engine internally. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} \hyperlink{classirr_1_1video_1_1IVideoDriver_a0dfc3a7168f3a73a6f4323b579f03ff6}{add\+Material\+Renderer} (\hyperlink{classirr_1_1video_1_1IMaterialRenderer}{I\+Material\+Renderer} $\ast$renderer, const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$name=0)=0
\begin{DoxyCompactList}\small\item\em Adds a new material renderer to the video device. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IMaterialRenderer}{I\+Material\+Renderer} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_accb321dfb32ad3c76efb99427bc90cc8}{get\+Material\+Renderer} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} idx)=0
\begin{DoxyCompactList}\small\item\em Get access to a material renderer by index. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} \hyperlink{classirr_1_1video_1_1IVideoDriver_a928018242ff962a0d37bfdab2019bea0}{get\+Material\+Renderer\+Count} () const  =0
\begin{DoxyCompactList}\small\item\em Get amount of currently available material renderers. \end{DoxyCompactList}\item 
virtual const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_ac5d9a63968887470b663f17b574a1642}{get\+Material\+Renderer\+Name} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} idx) const  =0
\begin{DoxyCompactList}\small\item\em Get name of a material renderer. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a4ef324ed93094f84832e8d31cf0776f2}{set\+Material\+Renderer\+Name} (\hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} idx, const \hyperlink{namespaceirr_a9395eaea339bcb546b319e9c96bf7410}{c8} $\ast$name)=0
\begin{DoxyCompactList}\small\item\em Sets the name of a material renderer. \end{DoxyCompactList}\item 
virtual const \hyperlink{structirr_1_1video_1_1SExposedVideoData}{S\+Exposed\+Video\+Data} \& \hyperlink{classirr_1_1video_1_1IVideoDriver_a4f3535b2125e654e2e9645745e50cc49}{get\+Exposed\+Video\+Data} ()=0
\begin{DoxyCompactList}\small\item\em Returns driver and operating system specific data about the \hyperlink{classirr_1_1video_1_1IVideoDriver}{I\+Video\+Driver}. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_1_1video_ae35a6de6d436c76107ad157fe42356d0}{E\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+T\+Y\+PE} \hyperlink{classirr_1_1video_1_1IVideoDriver_ade555878f685d40aba348a71f25cd73c}{get\+Driver\+Type} () const  =0
\begin{DoxyCompactList}\small\item\em Get type of video driver. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1IGPUProgrammingServices}{I\+G\+P\+U\+Programming\+Services} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_ad2098a408bbe9dad8053c3f4aea7d856}{get\+G\+P\+U\+Programming\+Services} ()=0
\begin{DoxyCompactList}\small\item\em Gets the \hyperlink{classirr_1_1video_1_1IGPUProgrammingServices}{I\+G\+P\+U\+Programming\+Services} interface. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1ITexture}{video\+::\+I\+Texture} $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_ad4eaed6d56b092e6805400ca59795de9}{find\+Texture} (const \hyperlink{namespaceirr_1_1io_ab1bdc45edb3f94d8319c02bc0f840ee1}{io\+::path} \&filename)=0
\begin{DoxyCompactList}\small\item\em Check if the image is already loaded. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_aaaf9567c759f866311c76e3874822339}{enable\+Clip\+Plane} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} index, bool enable)=0
\begin{DoxyCompactList}\small\item\em Enable or disable a clipping plane. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a79cbd1329b4206503e9a9593592502ea}{set\+Min\+Hardware\+Buffer\+Vertex\+Count} (\hyperlink{namespaceirr_a0416a53257075833e7002efd0a18e804}{u32} count)=0
\begin{DoxyCompactList}\small\item\em Set the minimum number of vertices for which a hw buffer will be created. \end{DoxyCompactList}\item 
virtual \hyperlink{structirr_1_1video_1_1SOverrideMaterial}{S\+Override\+Material} \& \hyperlink{classirr_1_1video_1_1IVideoDriver_af119ebfd02f99f77a463007277abf14a}{get\+Override\+Material} ()=0
\begin{DoxyCompactList}\small\item\em Get the global Material, which might override local materials. \end{DoxyCompactList}\item 
virtual \hyperlink{classirr_1_1video_1_1SMaterial}{S\+Material} \& \hyperlink{classirr_1_1video_1_1IVideoDriver_a198bbe60fdb1b5d6d0f4921e8a26109c}{get\+Material2D} ()=0
\begin{DoxyCompactList}\small\item\em Get the 2d override material for altering its values. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a7686a41fe0f506bb04c262f724f65756}{enable\+Material2D} (bool enable=true)=0
\begin{DoxyCompactList}\small\item\em Enable the 2d override material. \end{DoxyCompactList}\item 
virtual \hyperlink{namespaceirr_1_1core_ade1071a878633f2f6d8a75c5d11fec19}{core\+::stringc} \hyperlink{classirr_1_1video_1_1IVideoDriver_a221a3ee79676ad9fbebc39cf0150516e}{get\+Vendor\+Info} ()=0\hypertarget{classirr_1_1video_1_1IVideoDriver_a221a3ee79676ad9fbebc39cf0150516e}{}\label{classirr_1_1video_1_1IVideoDriver_a221a3ee79676ad9fbebc39cf0150516e}

\begin{DoxyCompactList}\small\item\em Get the graphics card vendor name. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_af78022589e5b7cb42b4d6ed2f7950e42}{set\+Allow\+Z\+Write\+On\+Transparent} (bool flag)=0
\begin{DoxyCompactList}\small\item\em Only used by the engine internally. \end{DoxyCompactList}\item 
virtual const uint32\+\_\+t $\ast$ \hyperlink{classirr_1_1video_1_1IVideoDriver_a006a7122fae833d18c7d2633c8c21780}{get\+Max\+Texture\+Size} (const I\+Texture\+::\+E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+T\+Y\+PE \&type) const  =0\hypertarget{classirr_1_1video_1_1IVideoDriver_a006a7122fae833d18c7d2633c8c21780}{}\label{classirr_1_1video_1_1IVideoDriver_a006a7122fae833d18c7d2633c8c21780}

\begin{DoxyCompactList}\small\item\em Get the maximum texture size supported. \end{DoxyCompactList}\item 
virtual void \hyperlink{classirr_1_1video_1_1IVideoDriver_a3a66ae240bccdc514d699be87a4582e5}{convert\+Color} (const void $\ast$sP, \hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829ed}{E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT} sF, \hyperlink{namespaceirr_ac66849b7a6ed16e30ebede579f9b47c6}{s32} sN, void $\ast$dP, \hyperlink{namespaceirr_1_1video_a1d5e487888c32b1674a8f75116d829ed}{E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT} dF) const  =0
\begin{DoxyCompactList}\small\item\em Color conversion convenience function. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Interface to driver which is able to perform 2d and 3d graphics functions. 

This interface is one of the most important interfaces of the Irrlicht Engine\+: All rendering and texture manipulation is done with this interface. You are able to use the Irrlicht Engine by only invoking methods of this interface if you like to, although the \hyperlink{classirr_1_1scene_1_1ISceneManager}{irr\+::scene\+::\+I\+Scene\+Manager} interface provides a lot of powerful classes and methods to make the programmer\textquotesingle{}s life easier. 

\subsection{Member Function Documentation}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!add\+Dynamic\+Light@{add\+Dynamic\+Light}}
\index{add\+Dynamic\+Light@{add\+Dynamic\+Light}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{add\+Dynamic\+Light(const S\+Light \&light)=0}{addDynamicLight(const SLight \&light)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf s32} irr\+::video\+::\+I\+Video\+Driver\+::add\+Dynamic\+Light (
\begin{DoxyParamCaption}
\item[{const {\bf S\+Light} \&}]{light}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a813a39352eae26c4d30b5882618639be}{}\label{classirr_1_1video_1_1IVideoDriver_a813a39352eae26c4d30b5882618639be}
adds a dynamic light, returning an index to the light 
\begin{DoxyParams}{Parameters}
{\em light} & the light data to use to create the light \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An index to the light, or -\/1 if an error occurs 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!add\+External\+Image\+Loader@{add\+External\+Image\+Loader}}
\index{add\+External\+Image\+Loader@{add\+External\+Image\+Loader}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{add\+External\+Image\+Loader(\+I\+Image\+Loader $\ast$loader)=0}{addExternalImageLoader(IImageLoader *loader)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::add\+External\+Image\+Loader (
\begin{DoxyParamCaption}
\item[{{\bf I\+Image\+Loader} $\ast$}]{loader}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a9479ae15f0e26eaaf15c9420ff289b6d}{}\label{classirr_1_1video_1_1IVideoDriver_a9479ae15f0e26eaaf15c9420ff289b6d}


Adds an external image loader to the engine. 

This is useful if the Irrlicht Engine should be able to load textures of currently unsupported file formats (e.\+g. gif). The \hyperlink{classirr_1_1video_1_1IImageLoader}{I\+Image\+Loader} only needs to be implemented for loading this file format. A pointer to the implementation can be passed to the engine using this method. 
\begin{DoxyParams}{Parameters}
{\em loader} & Pointer to the external loader created. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!add\+External\+Image\+Writer@{add\+External\+Image\+Writer}}
\index{add\+External\+Image\+Writer@{add\+External\+Image\+Writer}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{add\+External\+Image\+Writer(\+I\+Image\+Writer $\ast$writer)=0}{addExternalImageWriter(IImageWriter *writer)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::add\+External\+Image\+Writer (
\begin{DoxyParamCaption}
\item[{{\bf I\+Image\+Writer} $\ast$}]{writer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a56160e0d88346e04db921fbe4635a7ae}{}\label{classirr_1_1video_1_1IVideoDriver_a56160e0d88346e04db921fbe4635a7ae}


Adds an external image writer to the engine. 

This is useful if the Irrlicht Engine should be able to write textures of currently unsupported file formats (e.\+g .gif). The \hyperlink{classirr_1_1video_1_1IImageWriter}{I\+Image\+Writer} only needs to be implemented for writing this file format. A pointer to the implementation can be passed to the engine using this method. 
\begin{DoxyParams}{Parameters}
{\em writer} & Pointer to the external writer created. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!add\+Material\+Renderer@{add\+Material\+Renderer}}
\index{add\+Material\+Renderer@{add\+Material\+Renderer}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{add\+Material\+Renderer(\+I\+Material\+Renderer $\ast$renderer, const c8 $\ast$name=0)=0}{addMaterialRenderer(IMaterialRenderer *renderer, const c8 *name=0)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf s32} irr\+::video\+::\+I\+Video\+Driver\+::add\+Material\+Renderer (
\begin{DoxyParamCaption}
\item[{{\bf I\+Material\+Renderer} $\ast$}]{renderer, }
\item[{const {\bf c8} $\ast$}]{name = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a0dfc3a7168f3a73a6f4323b579f03ff6}{}\label{classirr_1_1video_1_1IVideoDriver_a0dfc3a7168f3a73a6f4323b579f03ff6}


Adds a new material renderer to the video device. 

Use this method to extend the Video\+Driver with new material types. To extend the engine using this method do the following\+: Derive a class from \hyperlink{classirr_1_1video_1_1IMaterialRenderer}{I\+Material\+Renderer} and override the methods you need. For setting the right renderstates, you can try to get a pointer to the real rendering device using \hyperlink{classirr_1_1video_1_1IVideoDriver_a4f3535b2125e654e2e9645745e50cc49}{I\+Video\+Driver\+::get\+Exposed\+Video\+Data()}. Add your class with \hyperlink{classirr_1_1video_1_1IVideoDriver_a0dfc3a7168f3a73a6f4323b579f03ff6}{I\+Video\+Driver\+::add\+Material\+Renderer()}. To use an object being displayed with your new material, set the Material\+Type member of the \hyperlink{classirr_1_1video_1_1SMaterial}{S\+Material} struct to the value returned by this method. If you simply want to create a new material using vertex and/or pixel shaders it would be easier to use the \hyperlink{classirr_1_1video_1_1IGPUProgrammingServices}{video\+::\+I\+G\+P\+U\+Programming\+Services} interface which you can get using the \hyperlink{classirr_1_1video_1_1IVideoDriver_ad2098a408bbe9dad8053c3f4aea7d856}{get\+G\+P\+U\+Programming\+Services()} method. 
\begin{DoxyParams}{Parameters}
{\em renderer} & A pointer to the new renderer. \\
\hline
{\em name} & Optional name for the material renderer entry. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of the material type which can be set in \hyperlink{classirr_1_1video_1_1SMaterial_a8cb63ab4b49ae1c61fbca8353e6b2f8a}{S\+Material\+::\+Material\+Type} to use the renderer. -\/1 is returned if an error occured. For example if you tried to add an material renderer to the software renderer or the null device, which do not accept material renderers. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!add\+Texture@{add\+Texture}}
\index{add\+Texture@{add\+Texture}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{add\+Texture(const I\+Texture\+::\+E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+T\+Y\+P\+E \&type, const uint32\+\_\+t $\ast$size, uint32\+\_\+t mipmap\+Levels, const io\+::path \&name, E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+A\+T format=\+E\+C\+F\+\_\+\+A8\+R8\+G8\+B8)=0}{addTexture(const ITexture::E\_TEXTURE\_TYPE \&type, const uint32\_t *size, uint32\_t mipmapLevels, const io::path \&name, ECOLOR\_FORMAT format=ECF\_A8R8G8B8)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Texture}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::add\+Texture (
\begin{DoxyParamCaption}
\item[{const I\+Texture\+::\+E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+T\+Y\+PE \&}]{type, }
\item[{const uint32\+\_\+t $\ast$}]{size, }
\item[{uint32\+\_\+t}]{mipmap\+Levels, }
\item[{const {\bf io\+::path} \&}]{name, }
\item[{{\bf E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT}}]{format = {\ttfamily {\bf E\+C\+F\+\_\+\+A8\+R8\+G8\+B8}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a10d535f75351c4c65ac29a30407db530}{}\label{classirr_1_1video_1_1IVideoDriver_a10d535f75351c4c65ac29a30407db530}


Creates an empty texture of specified size. 


\begin{DoxyParams}{Parameters}
{\em size} & Size of the texture. \\
\hline
{\em name} & A name for the texture. Later calls to \hyperlink{classirr_1_1video_1_1IVideoDriver_af4055165190e4adf221c6dc6f2434ea0}{get\+Texture()} with this name will return this texture \\
\hline
{\em format} & Desired color format of the texture. Please note that the driver may choose to create the texture in another color format. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the newly created texture. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!add\+Texture@{add\+Texture}}
\index{add\+Texture@{add\+Texture}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{add\+Texture(const io\+::path \&name, I\+Image $\ast$image, void $\ast$mipmap\+Data=0)=0}{addTexture(const io::path \&name, IImage *image, void *mipmapData=0)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Texture}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::add\+Texture (
\begin{DoxyParamCaption}
\item[{const {\bf io\+::path} \&}]{name, }
\item[{{\bf I\+Image} $\ast$}]{image, }
\item[{void $\ast$}]{mipmap\+Data = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_abfebeb09a692c0d6b4741d952d97668e}{}\label{classirr_1_1video_1_1IVideoDriver_abfebeb09a692c0d6b4741d952d97668e}


Creates a texture from an \hyperlink{classirr_1_1video_1_1IImage}{I\+Image}. 


\begin{DoxyParams}{Parameters}
{\em name} & A name for the texture. Later calls of \hyperlink{classirr_1_1video_1_1IVideoDriver_af4055165190e4adf221c6dc6f2434ea0}{get\+Texture()} with this name will return this texture \\
\hline
{\em image} & Image the texture is created from. \\
\hline
{\em mipmap\+Data} & Optional pointer to a set of images which build up the whole mipmap set. Must be images of the same color type as image. If this parameter is not given, the mipmaps are derived from image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the newly created texture. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!begin\+Scene@{begin\+Scene}}
\index{begin\+Scene@{begin\+Scene}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{begin\+Scene(bool back\+Buffer=true, bool z\+Buffer=true, S\+Color color=\+S\+Color(255, 0, 0, 0), const S\+Exposed\+Video\+Data \&video\+Data=\+S\+Exposed\+Video\+Data(), core\+::rect$<$ s32 $>$ $\ast$source\+Rect=0)=0}{beginScene(bool backBuffer=true, bool zBuffer=true, SColor color=SColor(255, 0, 0, 0), const SExposedVideoData \&videoData=SExposedVideoData(), core::rect< s32 > *sourceRect=0)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool irr\+::video\+::\+I\+Video\+Driver\+::begin\+Scene (
\begin{DoxyParamCaption}
\item[{bool}]{back\+Buffer = {\ttfamily true}, }
\item[{bool}]{z\+Buffer = {\ttfamily true}, }
\item[{{\bf S\+Color}}]{color = {\ttfamily {\bf S\+Color}(255,~0,~0,~0)}, }
\item[{const {\bf S\+Exposed\+Video\+Data} \&}]{video\+Data = {\ttfamily {\bf S\+Exposed\+Video\+Data}()}, }
\item[{{\bf core\+::rect}$<$ {\bf s32} $>$ $\ast$}]{source\+Rect = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a015b8f2f18c260a00a858181be1e9945}{}\label{classirr_1_1video_1_1IVideoDriver_a015b8f2f18c260a00a858181be1e9945}


Applications must call this method before performing any rendering. 

This method can clear the back-\/ and the z-\/buffer. 
\begin{DoxyParams}{Parameters}
{\em back\+Buffer} & Specifies if the back buffer should be cleared, which means that the screen is filled with the color specified. If this parameter is false, the back buffer will not be cleared and the color parameter is ignored. \\
\hline
{\em z\+Buffer} & Specifies if the depth buffer (z buffer) should be cleared. It is not nesesarry to do so if only 2d drawing is used. \\
\hline
{\em color} & The color used for back buffer clearing \\
\hline
{\em video\+Data} & Handle of another window, if you want the bitmap to be displayed on another window. If this is an empty element, everything will be displayed in the default window. Note\+: This feature is not fully implemented for all devices. \\
\hline
{\em source\+Rect} & Pointer to a rectangle defining the source rectangle of the area to be presented. Set to null to present everything. Note\+: not implemented in all devices. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
False if failed. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!begin\+Transform\+Feedback@{begin\+Transform\+Feedback}}
\index{begin\+Transform\+Feedback@{begin\+Transform\+Feedback}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{begin\+Transform\+Feedback(\+I\+Transform\+Feedback $\ast$xform\+Feedback, const E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+\_\+\+T\+Y\+P\+E \&xform\+Feedback\+Shader, const scene\+::\+E\+\_\+\+P\+R\+I\+M\+I\+T\+I\+V\+E\+\_\+\+T\+Y\+P\+E \&prim\+Type=scene\+::\+E\+P\+T\+\_\+\+P\+O\+I\+N\+T\+S)=0}{beginTransformFeedback(ITransformFeedback *xformFeedback, const E\_MATERIAL\_TYPE \&xformFeedbackShader, const scene::E\_PRIMITIVE\_TYPE \&primType=scene::EPT\_POINTS)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::begin\+Transform\+Feedback (
\begin{DoxyParamCaption}
\item[{{\bf I\+Transform\+Feedback} $\ast$}]{xform\+Feedback, }
\item[{const {\bf E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+\_\+\+T\+Y\+PE} \&}]{xform\+Feedback\+Shader, }
\item[{const {\bf scene\+::\+E\+\_\+\+P\+R\+I\+M\+I\+T\+I\+V\+E\+\_\+\+T\+Y\+PE} \&}]{prim\+Type = {\ttfamily {\bf scene\+::\+E\+P\+T\+\_\+\+P\+O\+I\+N\+TS}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a2f5b83de6b1fff8059d443760a1e266e}{}\label{classirr_1_1video_1_1IVideoDriver_a2f5b83de6b1fff8059d443760a1e266e}
Only P\+O\+I\+N\+TS, L\+I\+N\+ES, and T\+R\+I\+A\+N\+G\+L\+ES are allowed as capture types.. no strips or fans! This issues an implicit call to bind\+Transform\+Feedback() \index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!check\+Driver\+Reset@{check\+Driver\+Reset}}
\index{check\+Driver\+Reset@{check\+Driver\+Reset}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{check\+Driver\+Reset()=0}{checkDriverReset()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool irr\+::video\+::\+I\+Video\+Driver\+::check\+Driver\+Reset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a4ba84ee992939fc913d4935caffce87b}{}\label{classirr_1_1video_1_1IVideoDriver_a4ba84ee992939fc913d4935caffce87b}


Check if the driver was recently reset. 

For d3d devices you will need to recreate the R\+T\+Ts if the driver was reset. Should be queried right after \hyperlink{classirr_1_1video_1_1IVideoDriver_a015b8f2f18c260a00a858181be1e9945}{begin\+Scene()}. \index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!clear\+Z\+Buffer@{clear\+Z\+Buffer}}
\index{clear\+Z\+Buffer@{clear\+Z\+Buffer}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{clear\+Z\+Buffer(const float \&depth=0.\+0)=0}{clearZBuffer(const float \&depth=0.0)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::clear\+Z\+Buffer (
\begin{DoxyParamCaption}
\item[{const float \&}]{depth = {\ttfamily 0.0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a1cdd936731066604668e7be11cfead8d}{}\label{classirr_1_1video_1_1IVideoDriver_a1cdd936731066604668e7be11cfead8d}


Clears the Z\+Buffer. 

Note that you usually need not to call this method, as it is automatically done in \hyperlink{classirr_1_1video_1_1IVideoDriver_a015b8f2f18c260a00a858181be1e9945}{I\+Video\+Driver\+::begin\+Scene()} or \hyperlink{classirr_1_1video_1_1IVideoDriver_a6ae8e7ce16215e5d0e8a0c155029aaa1}{I\+Video\+Driver\+::set\+Render\+Target()} if you enable z\+Buffer. But if you have to render some special things, you can clear the zbuffer during the rendering process with this method any time. \index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!convert\+Color@{convert\+Color}}
\index{convert\+Color@{convert\+Color}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{convert\+Color(const void $\ast$s\+P, E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+A\+T s\+F, s32 s\+N, void $\ast$d\+P, E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+A\+T d\+F) const  =0}{convertColor(const void *sP, ECOLOR\_FORMAT sF, s32 sN, void *dP, ECOLOR\_FORMAT dF) const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::convert\+Color (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{sP, }
\item[{{\bf E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT}}]{sF, }
\item[{{\bf s32}}]{sN, }
\item[{void $\ast$}]{dP, }
\item[{{\bf E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT}}]{dF}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a3a66ae240bccdc514d699be87a4582e5}{}\label{classirr_1_1video_1_1IVideoDriver_a3a66ae240bccdc514d699be87a4582e5}


Color conversion convenience function. 

Convert an image (as array of pixels) from source to destination array, thereby converting the color format. The pixel size is determined by the color formats. 
\begin{DoxyParams}{Parameters}
{\em sP} & Pointer to source \\
\hline
{\em sF} & Color format of source \\
\hline
{\em sN} & Number of pixels to convert, both array must be large enough \\
\hline
{\em dP} & Pointer to destination \\
\hline
{\em dF} & Color format of destination \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!create\+Image@{create\+Image}}
\index{create\+Image@{create\+Image}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{create\+Image(\+E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+A\+T format, const core\+::dimension2d$<$ u32 $>$ \&size)=0}{createImage(ECOLOR\_FORMAT format, const core::dimension2d< u32 > \&size)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Image}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::create\+Image (
\begin{DoxyParamCaption}
\item[{{\bf E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT}}]{format, }
\item[{const {\bf core\+::dimension2d}$<$ {\bf u32} $>$ \&}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_aee1578fdd92118665755f31c0dd1dbb5}{}\label{classirr_1_1video_1_1IVideoDriver_aee1578fdd92118665755f31c0dd1dbb5}


Creates an empty software image. 


\begin{DoxyParams}{Parameters}
{\em format} & Desired color format of the image. \\
\hline
{\em size} & Size of the image to create. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The created image. If you no longer need the image, you should call \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Image\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!create\+Image@{create\+Image}}
\index{create\+Image@{create\+Image}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{create\+Image(\+E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+A\+T format, I\+Image $\ast$image\+To\+Copy)=0}{createImage(ECOLOR\_FORMAT format, IImage *imageToCopy)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ {\bf I\+Image}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::create\+Image (
\begin{DoxyParamCaption}
\item[{{\bf E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT}}]{format, }
\item[{{\bf I\+Image} $\ast$}]{image\+To\+Copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_af92ef735bc8c755f5c201a52a70d05e8}{}\label{classirr_1_1video_1_1IVideoDriver_af92ef735bc8c755f5c201a52a70d05e8}


Creates a software image by converting it to given format from another image. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000006}{Deprecated}]Create an empty image and use copy\+To(). This method may be removed by Irrlicht 1.\+9. \end{DoxyRefDesc}

\begin{DoxyParams}{Parameters}
{\em format} & Desired color format of the image. \\
\hline
{\em image\+To\+Copy} & Image to copy to the new image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The created image. If you no longer need the image, you should call \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Image\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!create\+Image@{create\+Image}}
\index{create\+Image@{create\+Image}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{create\+Image(\+I\+Image $\ast$image\+To\+Copy, const core\+::position2d$<$ s32 $>$ \&pos, const core\+::dimension2d$<$ u32 $>$ \&size)=0}{createImage(IImage *imageToCopy, const core::position2d< s32 > \&pos, const core::dimension2d< u32 > \&size)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual \+\_\+\+I\+R\+R\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+\_\+ {\bf I\+Image}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::create\+Image (
\begin{DoxyParamCaption}
\item[{{\bf I\+Image} $\ast$}]{image\+To\+Copy, }
\item[{const core\+::position2d$<$ {\bf s32} $>$ \&}]{pos, }
\item[{const {\bf core\+::dimension2d}$<$ {\bf u32} $>$ \&}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_aa06059abf33e473d7af77e1fbc2b0f75}{}\label{classirr_1_1video_1_1IVideoDriver_aa06059abf33e473d7af77e1fbc2b0f75}


Creates a software image from a part of another image. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000007}{Deprecated}]Create an empty image and use copy\+To(). This method may be removed by Irrlicht 1.\+9. \end{DoxyRefDesc}

\begin{DoxyParams}{Parameters}
{\em image\+To\+Copy} & Image to copy to the new image in part. \\
\hline
{\em pos} & Position of rectangle to copy. \\
\hline
{\em size} & Extents of rectangle to copy. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The created image. If you no longer need the image, you should call \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Image\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!create\+Image\+From\+Data@{create\+Image\+From\+Data}}
\index{create\+Image\+From\+Data@{create\+Image\+From\+Data}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{create\+Image\+From\+Data(\+E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+A\+T format, const core\+::dimension2d$<$ u32 $>$ \&size, void $\ast$data, bool own\+Foreign\+Memory=false, bool delete\+Memory=true)=0}{createImageFromData(ECOLOR\_FORMAT format, const core::dimension2d< u32 > \&size, void *data, bool ownForeignMemory=false, bool deleteMemory=true)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Image}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::create\+Image\+From\+Data (
\begin{DoxyParamCaption}
\item[{{\bf E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT}}]{format, }
\item[{const {\bf core\+::dimension2d}$<$ {\bf u32} $>$ \&}]{size, }
\item[{void $\ast$}]{data, }
\item[{bool}]{own\+Foreign\+Memory = {\ttfamily false}, }
\item[{bool}]{delete\+Memory = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a425d60f2fcad42d8a79c33c587f41a06}{}\label{classirr_1_1video_1_1IVideoDriver_a425d60f2fcad42d8a79c33c587f41a06}


Creates a software image from a byte array. 

No hardware texture will be created for this image. This method is useful for example if you want to read a heightmap for a terrain renderer. 
\begin{DoxyParams}{Parameters}
{\em format} & Desired color format of the texture \\
\hline
{\em size} & Desired size of the image \\
\hline
{\em data} & A byte array with pixel color information \\
\hline
{\em own\+Foreign\+Memory} & If true, the image will use the data pointer directly and own it afterwards. If false, the memory will by copied internally. \\
\hline
{\em delete\+Memory} & Whether the memory is deallocated upon destruction. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The created image. If you no longer need the image, you should call \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Image\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!create\+Image\+From\+File@{create\+Image\+From\+File}}
\index{create\+Image\+From\+File@{create\+Image\+From\+File}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{create\+Image\+From\+File(const io\+::path \&filename)=0}{createImageFromFile(const io::path \&filename)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Image}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::create\+Image\+From\+File (
\begin{DoxyParamCaption}
\item[{const {\bf io\+::path} \&}]{filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ac5b4c13f64d96d27fa27f52b68f77b8c}{}\label{classirr_1_1video_1_1IVideoDriver_ac5b4c13f64d96d27fa27f52b68f77b8c}


Creates a software image from a file. 

No hardware texture will be created for this image. This method is useful for example if you want to read a heightmap for a terrain renderer. 
\begin{DoxyParams}{Parameters}
{\em filename} & Name of the file from which the image is created. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The created image. If you no longer need the image, you should call \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Image\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!create\+Image\+From\+File@{create\+Image\+From\+File}}
\index{create\+Image\+From\+File@{create\+Image\+From\+File}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{create\+Image\+From\+File(io\+::\+I\+Read\+File $\ast$file)=0}{createImageFromFile(io::IReadFile *file)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Image}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::create\+Image\+From\+File (
\begin{DoxyParamCaption}
\item[{{\bf io\+::\+I\+Read\+File} $\ast$}]{file}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a322c41fa08c1da9de4633cf8a1e68607}{}\label{classirr_1_1video_1_1IVideoDriver_a322c41fa08c1da9de4633cf8a1e68607}


Creates a software image from a file. 

No hardware texture will be created for this image. This method is useful for example if you want to read a heightmap for a terrain renderer. 
\begin{DoxyParams}{Parameters}
{\em file} & File from which the image is created. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The created image. If you no longer need the image, you should call \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Image\+::drop()}. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!disable\+Feature@{disable\+Feature}}
\index{disable\+Feature@{disable\+Feature}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{disable\+Feature(\+E\+\_\+\+V\+I\+D\+E\+O\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+F\+E\+A\+T\+U\+R\+E feature, bool flag=true)=0}{disableFeature(E\_VIDEO\_DRIVER\_FEATURE feature, bool flag=true)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::disable\+Feature (
\begin{DoxyParamCaption}
\item[{{\bf E\+\_\+\+V\+I\+D\+E\+O\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+F\+E\+A\+T\+U\+RE}}]{feature, }
\item[{bool}]{flag = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_aea64c03fc205f23ec7575884fb7309c8}{}\label{classirr_1_1video_1_1IVideoDriver_aea64c03fc205f23ec7575884fb7309c8}


Disable a feature of the driver. 

Can also be used to enable the features again. It is not possible to enable unsupported features this way, though. 
\begin{DoxyParams}{Parameters}
{\em feature} & Feature to disable. \\
\hline
{\em flag} & When true the feature is disabled, otherwise it is enabled. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Image@{draw2\+D\+Image}}
\index{draw2\+D\+Image@{draw2\+D\+Image}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Image(const video\+::\+I\+Texture $\ast$texture, const core\+::position2d$<$ s32 $>$ \&dest\+Pos)=0}{draw2DImage(const video::ITexture *texture, const core::position2d< s32 > \&destPos)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Image (
\begin{DoxyParamCaption}
\item[{const {\bf video\+::\+I\+Texture} $\ast$}]{texture, }
\item[{const core\+::position2d$<$ {\bf s32} $>$ \&}]{dest\+Pos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ac1f12aefefb24414e03876bca942fb02}{}\label{classirr_1_1video_1_1IVideoDriver_ac1f12aefefb24414e03876bca942fb02}


Draws a 2d image without any special effects. 


\begin{DoxyParams}{Parameters}
{\em texture} & Pointer to texture to use. \\
\hline
{\em dest\+Pos} & Upper left 2d destination position where the image will be drawn. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Image@{draw2\+D\+Image}}
\index{draw2\+D\+Image@{draw2\+D\+Image}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Image(const video\+::\+I\+Texture $\ast$texture, const core\+::position2d$<$ s32 $>$ \&dest\+Pos, const core\+::rect$<$ s32 $>$ \&source\+Rect, const core\+::rect$<$ s32 $>$ $\ast$clip\+Rect=0, S\+Color color=\+S\+Color(255, 255, 255, 255), bool use\+Alpha\+Channel\+Of\+Texture=false)=0}{draw2DImage(const video::ITexture *texture, const core::position2d< s32 > \&destPos, const core::rect< s32 > \&sourceRect, const core::rect< s32 > *clipRect=0, SColor color=SColor(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Image (
\begin{DoxyParamCaption}
\item[{const {\bf video\+::\+I\+Texture} $\ast$}]{texture, }
\item[{const core\+::position2d$<$ {\bf s32} $>$ \&}]{dest\+Pos, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ \&}]{source\+Rect, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ $\ast$}]{clip\+Rect = {\ttfamily 0}, }
\item[{{\bf S\+Color}}]{color = {\ttfamily {\bf S\+Color}(255,~255,~255,~255)}, }
\item[{bool}]{use\+Alpha\+Channel\+Of\+Texture = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a167d3a5e2ea5804bfa9ba9e526bbcdb3}{}\label{classirr_1_1video_1_1IVideoDriver_a167d3a5e2ea5804bfa9ba9e526bbcdb3}


Draws a 2d image using a color. 

(if color is other than Color(255,255,255,255)) and the alpha channel of the texture. 
\begin{DoxyParams}{Parameters}
{\em texture} & Texture to be drawn. \\
\hline
{\em dest\+Pos} & Upper left 2d destination position where the image will be drawn. \\
\hline
{\em source\+Rect} & Source rectangle in the image. \\
\hline
{\em clip\+Rect} & Pointer to rectangle on the screen where the image is clipped to. If this pointer is N\+U\+LL the image is not clipped. \\
\hline
{\em color} & Color with which the image is drawn. If the color equals Color(255,255,255,255) it is ignored. Note that the alpha component is used\+: If alpha is other than 255, the image will be transparent. \\
\hline
{\em use\+Alpha\+Channel\+Of\+Texture} & If true, the alpha channel of the texture is used to draw the image. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Image@{draw2\+D\+Image}}
\index{draw2\+D\+Image@{draw2\+D\+Image}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Image(const video\+::\+I\+Texture $\ast$texture, const core\+::rect$<$ s32 $>$ \&dest\+Rect, const core\+::rect$<$ s32 $>$ \&source\+Rect, const core\+::rect$<$ s32 $>$ $\ast$clip\+Rect=0, const video\+::\+S\+Color $\ast$const colors=0, bool use\+Alpha\+Channel\+Of\+Texture=false)=0}{draw2DImage(const video::ITexture *texture, const core::rect< s32 > \&destRect, const core::rect< s32 > \&sourceRect, const core::rect< s32 > *clipRect=0, const video::SColor *const colors=0, bool useAlphaChannelOfTexture=false)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Image (
\begin{DoxyParamCaption}
\item[{const {\bf video\+::\+I\+Texture} $\ast$}]{texture, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ \&}]{dest\+Rect, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ \&}]{source\+Rect, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ $\ast$}]{clip\+Rect = {\ttfamily 0}, }
\item[{const {\bf video\+::\+S\+Color} $\ast$const}]{colors = {\ttfamily 0}, }
\item[{bool}]{use\+Alpha\+Channel\+Of\+Texture = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a49258725a8c36dbb22d073acf7927354}{}\label{classirr_1_1video_1_1IVideoDriver_a49258725a8c36dbb22d073acf7927354}


Draws a part of the texture into the rectangle. Note that colors must be an array of 4 colors if used. 

Suggested and first implemented by zola. 
\begin{DoxyParams}{Parameters}
{\em texture} & The texture to draw from \\
\hline
{\em dest\+Rect} & The rectangle to draw into \\
\hline
{\em source\+Rect} & The rectangle denoting a part of the texture \\
\hline
{\em clip\+Rect} & Clips the destination rectangle (may be 0) \\
\hline
{\em colors} & Array of 4 colors denoting the color values of the corners of the dest\+Rect \\
\hline
{\em use\+Alpha\+Channel\+Of\+Texture} & True if alpha channel will be blended. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Image\+Batch@{draw2\+D\+Image\+Batch}}
\index{draw2\+D\+Image\+Batch@{draw2\+D\+Image\+Batch}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Image\+Batch(const video\+::\+I\+Texture $\ast$texture, const core\+::position2d$<$ s32 $>$ \&pos, const core\+::array$<$ core\+::rect$<$ s32 $>$ $>$ \&source\+Rects, const core\+::array$<$ s32 $>$ \&indices, s32 kerning\+Width=0, const core\+::rect$<$ s32 $>$ $\ast$clip\+Rect=0, S\+Color color=\+S\+Color(255, 255, 255, 255), bool use\+Alpha\+Channel\+Of\+Texture=false)=0}{draw2DImageBatch(const video::ITexture *texture, const core::position2d< s32 > \&pos, const core::array< core::rect< s32 > > \&sourceRects, const core::array< s32 > \&indices, s32 kerningWidth=0, const core::rect< s32 > *clipRect=0, SColor color=SColor(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Image\+Batch (
\begin{DoxyParamCaption}
\item[{const {\bf video\+::\+I\+Texture} $\ast$}]{texture, }
\item[{const core\+::position2d$<$ {\bf s32} $>$ \&}]{pos, }
\item[{const {\bf core\+::array}$<$ {\bf core\+::rect}$<$ {\bf s32} $>$ $>$ \&}]{source\+Rects, }
\item[{const {\bf core\+::array}$<$ {\bf s32} $>$ \&}]{indices, }
\item[{{\bf s32}}]{kerning\+Width = {\ttfamily 0}, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ $\ast$}]{clip\+Rect = {\ttfamily 0}, }
\item[{{\bf S\+Color}}]{color = {\ttfamily {\bf S\+Color}(255,~255,~255,~255)}, }
\item[{bool}]{use\+Alpha\+Channel\+Of\+Texture = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a1b7647e900a56f23abb0809fd533617e}{}\label{classirr_1_1video_1_1IVideoDriver_a1b7647e900a56f23abb0809fd533617e}


Draws a set of 2d images, using a color and the alpha channel of the texture. 

The images are drawn beginning at pos and concatenated in one line. All drawings are clipped against clip\+Rect (if != 0). The subtextures are defined by the array of source\+Rects and are chosen by the indices given. 
\begin{DoxyParams}{Parameters}
{\em texture} & Texture to be drawn. \\
\hline
{\em pos} & Upper left 2d destination position where the image will be drawn. \\
\hline
{\em source\+Rects} & Source rectangles of the image. \\
\hline
{\em indices} & List of indices which choose the actual rectangle used each time. \\
\hline
{\em kerning\+Width} & Offset to Position on X \\
\hline
{\em clip\+Rect} & Pointer to rectangle on the screen where the image is clipped to. If this pointer is 0 then the image is not clipped. \\
\hline
{\em color} & Color with which the image is drawn. Note that the alpha component is used. If alpha is other than 255, the image will be transparent. \\
\hline
{\em use\+Alpha\+Channel\+Of\+Texture} & If true, the alpha channel of the texture is used to draw the image. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Image\+Batch@{draw2\+D\+Image\+Batch}}
\index{draw2\+D\+Image\+Batch@{draw2\+D\+Image\+Batch}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Image\+Batch(const video\+::\+I\+Texture $\ast$texture, const core\+::array$<$ core\+::position2d$<$ s32 $>$ $>$ \&positions, const core\+::array$<$ core\+::rect$<$ s32 $>$ $>$ \&source\+Rects, const core\+::rect$<$ s32 $>$ $\ast$clip\+Rect=0, S\+Color color=\+S\+Color(255, 255, 255, 255), bool use\+Alpha\+Channel\+Of\+Texture=false)=0}{draw2DImageBatch(const video::ITexture *texture, const core::array< core::position2d< s32 > > \&positions, const core::array< core::rect< s32 > > \&sourceRects, const core::rect< s32 > *clipRect=0, SColor color=SColor(255, 255, 255, 255), bool useAlphaChannelOfTexture=false)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Image\+Batch (
\begin{DoxyParamCaption}
\item[{const {\bf video\+::\+I\+Texture} $\ast$}]{texture, }
\item[{const {\bf core\+::array}$<$ core\+::position2d$<$ {\bf s32} $>$ $>$ \&}]{positions, }
\item[{const {\bf core\+::array}$<$ {\bf core\+::rect}$<$ {\bf s32} $>$ $>$ \&}]{source\+Rects, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ $\ast$}]{clip\+Rect = {\ttfamily 0}, }
\item[{{\bf S\+Color}}]{color = {\ttfamily {\bf S\+Color}(255,~255,~255,~255)}, }
\item[{bool}]{use\+Alpha\+Channel\+Of\+Texture = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a6485a684c4dfa4d0f94d0edfb46439a6}{}\label{classirr_1_1video_1_1IVideoDriver_a6485a684c4dfa4d0f94d0edfb46439a6}


Draws a set of 2d images, using a color and the alpha channel of the texture. 

All drawings are clipped against clip\+Rect (if != 0). The subtextures are defined by the array of source\+Rects and are positioned using the array of positions. 
\begin{DoxyParams}{Parameters}
{\em texture} & Texture to be drawn. \\
\hline
{\em positions} & Array of upper left 2d destinations where the images will be drawn. \\
\hline
{\em source\+Rects} & Source rectangles of the image. \\
\hline
{\em clip\+Rect} & Pointer to rectangle on the screen where the images are clipped to. If this pointer is 0 then the image is not clipped. \\
\hline
{\em color} & Color with which the image is drawn. Note that the alpha component is used. If alpha is other than 255, the image will be transparent. \\
\hline
{\em use\+Alpha\+Channel\+Of\+Texture} & If true, the alpha channel of the texture is used to draw the image. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Line@{draw2\+D\+Line}}
\index{draw2\+D\+Line@{draw2\+D\+Line}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Line(const core\+::position2d$<$ s32 $>$ \&start, const core\+::position2d$<$ s32 $>$ \&end, S\+Color color=\+S\+Color(255, 255, 255, 255))=0}{draw2DLine(const core::position2d< s32 > \&start, const core::position2d< s32 > \&end, SColor color=SColor(255, 255, 255, 255))=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Line (
\begin{DoxyParamCaption}
\item[{const core\+::position2d$<$ {\bf s32} $>$ \&}]{start, }
\item[{const core\+::position2d$<$ {\bf s32} $>$ \&}]{end, }
\item[{{\bf S\+Color}}]{color = {\ttfamily {\bf S\+Color}(255,~255,~255,~255)}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a7b5388e319a0ae1340c3d81db02dd959}{}\label{classirr_1_1video_1_1IVideoDriver_a7b5388e319a0ae1340c3d81db02dd959}


Draws a 2d line. Both start and end will be included in coloring. 


\begin{DoxyParams}{Parameters}
{\em start} & Screen coordinates of the start of the line in pixels. \\
\hline
{\em end} & Screen coordinates of the start of the line in pixels. \\
\hline
{\em color} & Color of the line to draw. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Polygon@{draw2\+D\+Polygon}}
\index{draw2\+D\+Polygon@{draw2\+D\+Polygon}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Polygon(core\+::position2d$<$ s32 $>$ center, f32 radius, video\+::\+S\+Color color=\+S\+Color(100, 255, 255, 255), s32 vertex\+Count=10)=0}{draw2DPolygon(core::position2d< s32 > center, f32 radius, video::SColor color=SColor(100, 255, 255, 255), s32 vertexCount=10)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Polygon (
\begin{DoxyParamCaption}
\item[{core\+::position2d$<$ {\bf s32} $>$}]{center, }
\item[{{\bf f32}}]{radius, }
\item[{{\bf video\+::\+S\+Color}}]{color = {\ttfamily {\bf S\+Color}(100,~255,~255,~255)}, }
\item[{{\bf s32}}]{vertex\+Count = {\ttfamily 10}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_aaf1318379f3d70c9347cfa853b944ad4}{}\label{classirr_1_1video_1_1IVideoDriver_aaf1318379f3d70c9347cfa853b944ad4}


Draws a non filled concyclic regular 2d polyon. 

This method can be used to draw circles, but also triangles, tetragons, pentagons, hexagons, heptagons, octagons, enneagons, decagons, hendecagons, dodecagon, triskaidecagons, etc. I think you\textquotesingle{}ll got it now. And all this by simply specifying the vertex count. Welcome to the wonders of geometry. 
\begin{DoxyParams}{Parameters}
{\em center} & Position of center of circle (pixels). \\
\hline
{\em radius} & Radius of circle in pixels. \\
\hline
{\em color} & Color of the circle. \\
\hline
{\em vertex\+Count} & Amount of vertices of the polygon. Specify 2 to draw a line, 3 to draw a triangle, 4 for tetragons and a lot ($>$10) for nearly a circle. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Rectangle@{draw2\+D\+Rectangle}}
\index{draw2\+D\+Rectangle@{draw2\+D\+Rectangle}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Rectangle(\+S\+Color color, const core\+::rect$<$ s32 $>$ \&pos, const core\+::rect$<$ s32 $>$ $\ast$clip=0)=0}{draw2DRectangle(SColor color, const core::rect< s32 > \&pos, const core::rect< s32 > *clip=0)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Rectangle (
\begin{DoxyParamCaption}
\item[{{\bf S\+Color}}]{color, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ \&}]{pos, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ $\ast$}]{clip = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ac7f452fae0ef8abe01768a78ba7033b7}{}\label{classirr_1_1video_1_1IVideoDriver_ac7f452fae0ef8abe01768a78ba7033b7}


Draws a 2d rectangle. 


\begin{DoxyParams}{Parameters}
{\em color} & Color of the rectangle to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. \\
\hline
{\em pos} & Position of the rectangle. \\
\hline
{\em clip} & Pointer to rectangle against which the rectangle will be clipped. If the pointer is null, no clipping will be performed. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Rectangle@{draw2\+D\+Rectangle}}
\index{draw2\+D\+Rectangle@{draw2\+D\+Rectangle}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Rectangle(const core\+::rect$<$ s32 $>$ \&pos, S\+Color color\+Left\+Up, S\+Color color\+Right\+Up, S\+Color color\+Left\+Down, S\+Color color\+Right\+Down, const core\+::rect$<$ s32 $>$ $\ast$clip=0)=0}{draw2DRectangle(const core::rect< s32 > \&pos, SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown, const core::rect< s32 > *clip=0)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Rectangle (
\begin{DoxyParamCaption}
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ \&}]{pos, }
\item[{{\bf S\+Color}}]{color\+Left\+Up, }
\item[{{\bf S\+Color}}]{color\+Right\+Up, }
\item[{{\bf S\+Color}}]{color\+Left\+Down, }
\item[{{\bf S\+Color}}]{color\+Right\+Down, }
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ $\ast$}]{clip = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a83bb3c30be6c9f960a4d8b625d7dee8c}{}\label{classirr_1_1video_1_1IVideoDriver_a83bb3c30be6c9f960a4d8b625d7dee8c}


Draws a 2d rectangle with a gradient. 


\begin{DoxyParams}{Parameters}
{\em color\+Left\+Up} & Color of the upper left corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. \\
\hline
{\em color\+Right\+Up} & Color of the upper right corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. \\
\hline
{\em color\+Left\+Down} & Color of the lower left corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. \\
\hline
{\em color\+Right\+Down} & Color of the lower right corner to draw. The alpha component will not be ignored and specifies how transparent the rectangle will be. \\
\hline
{\em pos} & Position of the rectangle. \\
\hline
{\em clip} & Pointer to rectangle against which the rectangle will be clipped. If the pointer is null, no clipping will be performed. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw2\+D\+Rectangle\+Outline@{draw2\+D\+Rectangle\+Outline}}
\index{draw2\+D\+Rectangle\+Outline@{draw2\+D\+Rectangle\+Outline}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw2\+D\+Rectangle\+Outline(const core\+::recti \&pos, S\+Color color=\+S\+Color(255, 255, 255, 255))=0}{draw2DRectangleOutline(const core::recti \&pos, SColor color=SColor(255, 255, 255, 255))=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw2\+D\+Rectangle\+Outline (
\begin{DoxyParamCaption}
\item[{const {\bf core\+::recti} \&}]{pos, }
\item[{{\bf S\+Color}}]{color = {\ttfamily {\bf S\+Color}(255,~255,~255,~255)}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a65efe36e19f0570988848175a8af7bd1}{}\label{classirr_1_1video_1_1IVideoDriver_a65efe36e19f0570988848175a8af7bd1}


Draws the outline of a 2D rectangle. 


\begin{DoxyParams}{Parameters}
{\em pos} & Position of the rectangle. \\
\hline
{\em color} & Color of the rectangle to draw. The alpha component specifies how transparent the rectangle outline will be. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw3\+D\+Box@{draw3\+D\+Box}}
\index{draw3\+D\+Box@{draw3\+D\+Box}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw3\+D\+Box(const core\+::aabbox3d$<$ f32 $>$ \&box, S\+Color color=\+S\+Color(255, 255, 255, 255))=0}{draw3DBox(const core::aabbox3d< f32 > \&box, SColor color=SColor(255, 255, 255, 255))=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw3\+D\+Box (
\begin{DoxyParamCaption}
\item[{const {\bf core\+::aabbox3d}$<$ {\bf f32} $>$ \&}]{box, }
\item[{{\bf S\+Color}}]{color = {\ttfamily {\bf S\+Color}(255,~255,~255,~255)}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a7773fce9358ee81db5484b2d21015570}{}\label{classirr_1_1video_1_1IVideoDriver_a7773fce9358ee81db5484b2d21015570}


Draws a 3d axis aligned box. 

This method simply calls draw3\+D\+Line for the edges of the box. Note that the box is drawn using the current transformation matrix and material. So if you need to draw it independently of the current transformation, use 
\begin{DoxyCode}
driver->setMaterial(someMaterial);
driver->setTransform(\hyperlink{namespaceirr_1_1video_a9f34b0dd7b888c8cbabb22989f23b853a9e2da71dc29e91d31f7be3ce1ea1f377}{video::E4X3TS\_WORLD}, 
      \hyperlink{namespaceirr_1_1core_af9c0ceb45d98dc627c8ed455d223efeb}{core::IdentityMatrix});
\end{DoxyCode}
 for some properly set up material before drawing the box. 
\begin{DoxyParams}{Parameters}
{\em box} & The axis aligned box to draw \\
\hline
{\em color} & Color to use while drawing the box. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw3\+D\+Line@{draw3\+D\+Line}}
\index{draw3\+D\+Line@{draw3\+D\+Line}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw3\+D\+Line(const core\+::vector3df \&start, const core\+::vector3df \&end, S\+Color color=\+S\+Color(255, 255, 255, 255))=0}{draw3DLine(const core::vector3df \&start, const core::vector3df \&end, SColor color=SColor(255, 255, 255, 255))=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw3\+D\+Line (
\begin{DoxyParamCaption}
\item[{const {\bf core\+::vector3df} \&}]{start, }
\item[{const {\bf core\+::vector3df} \&}]{end, }
\item[{{\bf S\+Color}}]{color = {\ttfamily {\bf S\+Color}(255,~255,~255,~255)}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a5e4e03dca1720f3d2019b73a4eebb5e6}{}\label{classirr_1_1video_1_1IVideoDriver_a5e4e03dca1720f3d2019b73a4eebb5e6}


Draws a 3d line. 

Note that the line is drawn using the current transformation matrix and material. So if you need to draw the 3D line independently of the current transformation, use 
\begin{DoxyCode}
driver->setMaterial(someMaterial);
driver->setTransform(\hyperlink{namespaceirr_1_1video_a9f34b0dd7b888c8cbabb22989f23b853a9e2da71dc29e91d31f7be3ce1ea1f377}{video::E4X3TS\_WORLD}, 
      \hyperlink{namespaceirr_1_1core_af9c0ceb45d98dc627c8ed455d223efeb}{core::IdentityMatrix});
\end{DoxyCode}
 for some properly set up material before drawing the line. Some drivers support line thickness set in the material. 
\begin{DoxyParams}{Parameters}
{\em start} & Start of the 3d line. \\
\hline
{\em end} & End of the 3d line. \\
\hline
{\em color} & Color of the line. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw\+Mesh\+Buffer@{draw\+Mesh\+Buffer}}
\index{draw\+Mesh\+Buffer@{draw\+Mesh\+Buffer}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw\+Mesh\+Buffer(scene\+::\+I\+G\+P\+U\+Mesh\+Buffer $\ast$mb, I\+Occlusion\+Query $\ast$query=\+N\+U\+L\+L)=0}{drawMeshBuffer(scene::IGPUMeshBuffer *mb, IOcclusionQuery *query=NULL)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw\+Mesh\+Buffer (
\begin{DoxyParamCaption}
\item[{{\bf scene\+::\+I\+G\+P\+U\+Mesh\+Buffer} $\ast$}]{mb, }
\item[{{\bf I\+Occlusion\+Query} $\ast$}]{query = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a3f03e53661b1fc83d92cba4af7de6c70}{}\label{classirr_1_1video_1_1IVideoDriver_a3f03e53661b1fc83d92cba4af7de6c70}


Draws a mesh buffer. 


\begin{DoxyParams}{Parameters}
{\em mb} & Buffer to draw \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!draw\+Pixel@{draw\+Pixel}}
\index{draw\+Pixel@{draw\+Pixel}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{draw\+Pixel(u32 x, u32 y, const S\+Color \&color)=0}{drawPixel(u32 x, u32 y, const SColor \&color)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::draw\+Pixel (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{x, }
\item[{{\bf u32}}]{y, }
\item[{const {\bf S\+Color} \&}]{color}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a6567ced74ed6dc8cb1b325493ae7a093}{}\label{classirr_1_1video_1_1IVideoDriver_a6567ced74ed6dc8cb1b325493ae7a093}


Draws a pixel. 


\begin{DoxyParams}{Parameters}
{\em x} & The x-\/position of the pixel. \\
\hline
{\em y} & The y-\/position of the pixel. \\
\hline
{\em color} & Color of the pixel to draw. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!enable\+Clip\+Plane@{enable\+Clip\+Plane}}
\index{enable\+Clip\+Plane@{enable\+Clip\+Plane}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{enable\+Clip\+Plane(u32 index, bool enable)=0}{enableClipPlane(u32 index, bool enable)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::enable\+Clip\+Plane (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{index, }
\item[{bool}]{enable}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_aaaf9567c759f866311c76e3874822339}{}\label{classirr_1_1video_1_1IVideoDriver_aaaf9567c759f866311c76e3874822339}


Enable or disable a clipping plane. 

There are at least 6 clipping planes available for the user to set at will. 
\begin{DoxyParams}{Parameters}
{\em index} & The plane index. Must be between 0 and Max\+User\+Clip\+Planes. \\
\hline
{\em enable} & If true, enable the clipping plane else disable it. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!enable\+Material2D@{enable\+Material2D}}
\index{enable\+Material2D@{enable\+Material2D}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{enable\+Material2\+D(bool enable=true)=0}{enableMaterial2D(bool enable=true)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::enable\+Material2D (
\begin{DoxyParamCaption}
\item[{bool}]{enable = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a7686a41fe0f506bb04c262f724f65756}{}\label{classirr_1_1video_1_1IVideoDriver_a7686a41fe0f506bb04c262f724f65756}


Enable the 2d override material. 


\begin{DoxyParams}{Parameters}
{\em enable} & Flag which tells whether the material shall be enabled or disabled. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!end\+Scene@{end\+Scene}}
\index{end\+Scene@{end\+Scene}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{end\+Scene()=0}{endScene()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool irr\+::video\+::\+I\+Video\+Driver\+::end\+Scene (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a75f61a93c5fc9fdf161c044d27bc994e}{}\label{classirr_1_1video_1_1IVideoDriver_a75f61a93c5fc9fdf161c044d27bc994e}


Presents the rendered image to the screen. 

Applications must call this method after performing any rendering. \begin{DoxyReturn}{Returns}
False if failed and true if succeeded. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!find\+Texture@{find\+Texture}}
\index{find\+Texture@{find\+Texture}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{find\+Texture(const io\+::path \&filename)=0}{findTexture(const io::path \&filename)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf video\+::\+I\+Texture}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::find\+Texture (
\begin{DoxyParamCaption}
\item[{const {\bf io\+::path} \&}]{filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ad4eaed6d56b092e6805400ca59795de9}{}\label{classirr_1_1video_1_1IVideoDriver_ad4eaed6d56b092e6805400ca59795de9}


Check if the image is already loaded. 

Works similar to \hyperlink{classirr_1_1video_1_1IVideoDriver_af4055165190e4adf221c6dc6f2434ea0}{get\+Texture()}, but does not load the texture if it is not currently loaded. 
\begin{DoxyParams}{Parameters}
{\em filename} & Name of the texture. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to loaded texture, or 0 if not found. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Color\+Format@{get\+Color\+Format}}
\index{get\+Color\+Format@{get\+Color\+Format}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Color\+Format() const  =0}{getColorFormat() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf E\+C\+O\+L\+O\+R\+\_\+\+F\+O\+R\+M\+AT} irr\+::video\+::\+I\+Video\+Driver\+::get\+Color\+Format (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a9a4eaeebbeae43dc329b978a79d9e034}{}\label{classirr_1_1video_1_1IVideoDriver_a9a4eaeebbeae43dc329b978a79d9e034}


Get the current color format of the color buffer. 

\begin{DoxyReturn}{Returns}
Color format of the color buffer. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Current\+Render\+Target\+Size@{get\+Current\+Render\+Target\+Size}}
\index{get\+Current\+Render\+Target\+Size@{get\+Current\+Render\+Target\+Size}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Current\+Render\+Target\+Size() const  =0}{getCurrentRenderTargetSize() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const {\bf core\+::dimension2d}$<${\bf u32}$>$\& irr\+::video\+::\+I\+Video\+Driver\+::get\+Current\+Render\+Target\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a38c665baaf25dcfd510dd3413455af4c}{}\label{classirr_1_1video_1_1IVideoDriver_a38c665baaf25dcfd510dd3413455af4c}


Get the size of the current render target. 

This method will return the screen size if the driver doesn\textquotesingle{}t support render to texture, or if the current render target is the screen. \begin{DoxyReturn}{Returns}
Size of render target or screen/window 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Driver\+Type@{get\+Driver\+Type}}
\index{get\+Driver\+Type@{get\+Driver\+Type}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Driver\+Type() const  =0}{getDriverType() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf E\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+T\+Y\+PE} irr\+::video\+::\+I\+Video\+Driver\+::get\+Driver\+Type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ade555878f685d40aba348a71f25cd73c}{}\label{classirr_1_1video_1_1IVideoDriver_ade555878f685d40aba348a71f25cd73c}


Get type of video driver. 

\begin{DoxyReturn}{Returns}
Type of driver. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Dynamic\+Light@{get\+Dynamic\+Light}}
\index{get\+Dynamic\+Light@{get\+Dynamic\+Light}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Dynamic\+Light(u32 idx) const  =0}{getDynamicLight(u32 idx) const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const {\bf S\+Light}\& irr\+::video\+::\+I\+Video\+Driver\+::get\+Dynamic\+Light (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{idx}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_aba32f5b6ba9bf1a9eabe54cf1649bb97}{}\label{classirr_1_1video_1_1IVideoDriver_aba32f5b6ba9bf1a9eabe54cf1649bb97}


Returns light data which was previously set by \hyperlink{classirr_1_1video_1_1IVideoDriver_a813a39352eae26c4d30b5882618639be}{I\+Video\+Driver\+::add\+Dynamic\+Light()}. 


\begin{DoxyParams}{Parameters}
{\em idx} & Zero based index of the light. Must be 0 or greater and smaller than \hyperlink{classirr_1_1video_1_1IVideoDriver_a4c85208c572dc8c37350bf0bd11583f8}{I\+Video\+Driver\+::get\+Dynamic\+Light\+Count}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Light data. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Dynamic\+Light\+Count@{get\+Dynamic\+Light\+Count}}
\index{get\+Dynamic\+Light\+Count@{get\+Dynamic\+Light\+Count}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Dynamic\+Light\+Count() const  =0}{getDynamicLightCount() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf u32} irr\+::video\+::\+I\+Video\+Driver\+::get\+Dynamic\+Light\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a4c85208c572dc8c37350bf0bd11583f8}{}\label{classirr_1_1video_1_1IVideoDriver_a4c85208c572dc8c37350bf0bd11583f8}


Returns amount of dynamic lights currently set. 

\begin{DoxyReturn}{Returns}
Amount of dynamic lights currently set 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Exposed\+Video\+Data@{get\+Exposed\+Video\+Data}}
\index{get\+Exposed\+Video\+Data@{get\+Exposed\+Video\+Data}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Exposed\+Video\+Data()=0}{getExposedVideoData()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const {\bf S\+Exposed\+Video\+Data}\& irr\+::video\+::\+I\+Video\+Driver\+::get\+Exposed\+Video\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a4f3535b2125e654e2e9645745e50cc49}{}\label{classirr_1_1video_1_1IVideoDriver_a4f3535b2125e654e2e9645745e50cc49}


Returns driver and operating system specific data about the \hyperlink{classirr_1_1video_1_1IVideoDriver}{I\+Video\+Driver}. 

This method should only be used if the engine should be extended without having to modify the source of the engine. \begin{DoxyReturn}{Returns}
Collection of device dependent pointers. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+F\+PS@{get\+F\+PS}}
\index{get\+F\+PS@{get\+F\+PS}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+F\+P\+S() const  =0}{getFPS() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf s32} irr\+::video\+::\+I\+Video\+Driver\+::get\+F\+PS (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a2fd9d69e9fb01719b8bcff7a463929a8}{}\label{classirr_1_1video_1_1IVideoDriver_a2fd9d69e9fb01719b8bcff7a463929a8}


Returns current frames per second value. 

This value is updated approximately every 1.\+5 seconds and is only intended to provide a rough guide to the average frame rate. It is not suitable for use in performing timing calculations or framerate independent movement. \begin{DoxyReturn}{Returns}
Approximate amount of frames per second drawn. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+G\+P\+U\+Programming\+Services@{get\+G\+P\+U\+Programming\+Services}}
\index{get\+G\+P\+U\+Programming\+Services@{get\+G\+P\+U\+Programming\+Services}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+G\+P\+U\+Programming\+Services()=0}{getGPUProgrammingServices()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+G\+P\+U\+Programming\+Services}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::get\+G\+P\+U\+Programming\+Services (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ad2098a408bbe9dad8053c3f4aea7d856}{}\label{classirr_1_1video_1_1IVideoDriver_ad2098a408bbe9dad8053c3f4aea7d856}


Gets the \hyperlink{classirr_1_1video_1_1IGPUProgrammingServices}{I\+G\+P\+U\+Programming\+Services} interface. 

\begin{DoxyReturn}{Returns}
Pointer to the \hyperlink{classirr_1_1video_1_1IGPUProgrammingServices}{I\+G\+P\+U\+Programming\+Services}. Returns 0 if the video driver does not support this. For example the Software driver and the Null driver will always return 0. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Image\+Loader@{get\+Image\+Loader}}
\index{get\+Image\+Loader@{get\+Image\+Loader}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Image\+Loader(u32 n)=0}{getImageLoader(u32 n)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Image\+Loader}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::get\+Image\+Loader (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a5cc08e7cd2ce2a30275e22ce13bb1013}{}\label{classirr_1_1video_1_1IVideoDriver_a5cc08e7cd2ce2a30275e22ce13bb1013}


Retrieve the given image loader. 


\begin{DoxyParams}{Parameters}
{\em n} & The index of the loader to retrieve. This parameter is an 0-\/based array index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the specified loader, 0 if the index is incorrect. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Image\+Loader\+Count@{get\+Image\+Loader\+Count}}
\index{get\+Image\+Loader\+Count@{get\+Image\+Loader\+Count}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Image\+Loader\+Count() const  =0}{getImageLoaderCount() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf u32} irr\+::video\+::\+I\+Video\+Driver\+::get\+Image\+Loader\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a672575822cce8b590b6ed709f08cdaac}{}\label{classirr_1_1video_1_1IVideoDriver_a672575822cce8b590b6ed709f08cdaac}


Retrieve the number of image loaders. 

\begin{DoxyReturn}{Returns}
Number of image loaders 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Image\+Writer@{get\+Image\+Writer}}
\index{get\+Image\+Writer@{get\+Image\+Writer}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Image\+Writer(u32 n)=0}{getImageWriter(u32 n)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Image\+Writer}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::get\+Image\+Writer (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_acdc5e788993c117efebb22e155ab6a77}{}\label{classirr_1_1video_1_1IVideoDriver_acdc5e788993c117efebb22e155ab6a77}


Retrieve the given image writer. 


\begin{DoxyParams}{Parameters}
{\em n} & The index of the writer to retrieve. This parameter is an 0-\/based array index. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the specified writer, 0 if the index is incorrect. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Image\+Writer\+Count@{get\+Image\+Writer\+Count}}
\index{get\+Image\+Writer\+Count@{get\+Image\+Writer\+Count}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Image\+Writer\+Count() const  =0}{getImageWriterCount() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf u32} irr\+::video\+::\+I\+Video\+Driver\+::get\+Image\+Writer\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ab8765c883399c84fca2165309e19d65e}{}\label{classirr_1_1video_1_1IVideoDriver_ab8765c883399c84fca2165309e19d65e}


Retrieve the number of image writers. 

\begin{DoxyReturn}{Returns}
Number of image writers 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Material2D@{get\+Material2D}}
\index{get\+Material2D@{get\+Material2D}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Material2\+D()=0}{getMaterial2D()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf S\+Material}\& irr\+::video\+::\+I\+Video\+Driver\+::get\+Material2D (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a198bbe60fdb1b5d6d0f4921e8a26109c}{}\label{classirr_1_1video_1_1IVideoDriver_a198bbe60fdb1b5d6d0f4921e8a26109c}


Get the 2d override material for altering its values. 

The 2d override materual allows to alter certain render states of the 2d methods. Not all members of \hyperlink{classirr_1_1video_1_1SMaterial}{S\+Material} are honored, especially not Material\+Type and Textures. Moreover, the zbuffer is always ignored, and lighting is always off. All other flags can be changed, though some might have to effect in most cases. Please note that you have to enable/disable this effect with enable\+Init\+Material2\+D(). This effect is costly, as it increases the number of state changes considerably. Always reset the values when done. \begin{DoxyReturn}{Returns}
Material reference which should be altered to reflect the new settings. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Material\+Renderer@{get\+Material\+Renderer}}
\index{get\+Material\+Renderer@{get\+Material\+Renderer}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Material\+Renderer(u32 idx)=0}{getMaterialRenderer(u32 idx)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Material\+Renderer}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::get\+Material\+Renderer (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{idx}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_accb321dfb32ad3c76efb99427bc90cc8}{}\label{classirr_1_1video_1_1IVideoDriver_accb321dfb32ad3c76efb99427bc90cc8}


Get access to a material renderer by index. 


\begin{DoxyParams}{Parameters}
{\em idx} & Id of the material renderer. Can be a value of the E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+\_\+\+T\+Y\+PE enum or a value which was returned by \hyperlink{classirr_1_1video_1_1IVideoDriver_a0dfc3a7168f3a73a6f4323b579f03ff6}{add\+Material\+Renderer()}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to material renderer or null if not existing. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Material\+Renderer\+Count@{get\+Material\+Renderer\+Count}}
\index{get\+Material\+Renderer\+Count@{get\+Material\+Renderer\+Count}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Material\+Renderer\+Count() const  =0}{getMaterialRendererCount() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf u32} irr\+::video\+::\+I\+Video\+Driver\+::get\+Material\+Renderer\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a928018242ff962a0d37bfdab2019bea0}{}\label{classirr_1_1video_1_1IVideoDriver_a928018242ff962a0d37bfdab2019bea0}


Get amount of currently available material renderers. 

\begin{DoxyReturn}{Returns}
Amount of currently available material renderers. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Material\+Renderer\+Name@{get\+Material\+Renderer\+Name}}
\index{get\+Material\+Renderer\+Name@{get\+Material\+Renderer\+Name}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Material\+Renderer\+Name(u32 idx) const  =0}{getMaterialRendererName(u32 idx) const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const {\bf c8}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::get\+Material\+Renderer\+Name (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{idx}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ac5d9a63968887470b663f17b574a1642}{}\label{classirr_1_1video_1_1IVideoDriver_ac5d9a63968887470b663f17b574a1642}


Get name of a material renderer. 

This string can, e.\+g., be used to test if a specific renderer already has been registered/created, or use this string to store data about materials\+: This returned name will be also used when serializing materials. 
\begin{DoxyParams}{Parameters}
{\em idx} & Id of the material renderer. Can be a value of the E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+\_\+\+T\+Y\+PE enum or a value which was returned by \hyperlink{classirr_1_1video_1_1IVideoDriver_a0dfc3a7168f3a73a6f4323b579f03ff6}{add\+Material\+Renderer()}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
String with the name of the renderer, or 0 if not exisiting 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Maximal\+Dynamic\+Light\+Amount@{get\+Maximal\+Dynamic\+Light\+Amount}}
\index{get\+Maximal\+Dynamic\+Light\+Amount@{get\+Maximal\+Dynamic\+Light\+Amount}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Maximal\+Dynamic\+Light\+Amount() const  =0}{getMaximalDynamicLightAmount() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf u32} irr\+::video\+::\+I\+Video\+Driver\+::get\+Maximal\+Dynamic\+Light\+Amount (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a242c9e9d469476eb28d55dc8a17b6622}{}\label{classirr_1_1video_1_1IVideoDriver_a242c9e9d469476eb28d55dc8a17b6622}


Returns the maximal amount of dynamic lights the device can handle. 

\begin{DoxyReturn}{Returns}
Maximal amount of dynamic lights. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Maximal\+Indices\+Count@{get\+Maximal\+Indices\+Count}}
\index{get\+Maximal\+Indices\+Count@{get\+Maximal\+Indices\+Count}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Maximal\+Indices\+Count() const  =0}{getMaximalIndicesCount() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf u32} irr\+::video\+::\+I\+Video\+Driver\+::get\+Maximal\+Indices\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a834b7db981d14737c9162a4e3368eb03}{}\label{classirr_1_1video_1_1IVideoDriver_a834b7db981d14737c9162a4e3368eb03}


Returns the maximum amount of primitives. 

(mostly vertices) which the device is able to render. \begin{DoxyReturn}{Returns}
Maximum amount of primitives. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Name@{get\+Name}}
\index{get\+Name@{get\+Name}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Name() const  =0}{getName() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const wchar\+\_\+t$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::get\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a3effb1d6dd3ea2f4b2671eabf9b15d6e}{}\label{classirr_1_1video_1_1IVideoDriver_a3effb1d6dd3ea2f4b2671eabf9b15d6e}


Gets name of this video driver. 

\begin{DoxyReturn}{Returns}
Returns the name of the video driver, e.\+g. in case of the Direct3\+D8 driver, it would return \char`\"{}\+Direct3\+D 8.\+1\char`\"{}. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Override\+Material@{get\+Override\+Material}}
\index{get\+Override\+Material@{get\+Override\+Material}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Override\+Material()=0}{getOverrideMaterial()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf S\+Override\+Material}\& irr\+::video\+::\+I\+Video\+Driver\+::get\+Override\+Material (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_af119ebfd02f99f77a463007277abf14a}{}\label{classirr_1_1video_1_1IVideoDriver_af119ebfd02f99f77a463007277abf14a}


Get the global Material, which might override local materials. 

Depending on the enable flags, values from this Material are used to override those of local materials of some meshbuffer being rendered. \begin{DoxyReturn}{Returns}
Reference to the Override Material. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Primitive\+Count\+Drawn@{get\+Primitive\+Count\+Drawn}}
\index{get\+Primitive\+Count\+Drawn@{get\+Primitive\+Count\+Drawn}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Primitive\+Count\+Drawn(u32 mode=0) const  =0}{getPrimitiveCountDrawn(u32 mode=0) const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf u32} irr\+::video\+::\+I\+Video\+Driver\+::get\+Primitive\+Count\+Drawn (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{mode = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a29e046d6b90563100a2f2b0b06294c7d}{}\label{classirr_1_1video_1_1IVideoDriver_a29e046d6b90563100a2f2b0b06294c7d}


Returns amount of primitives (mostly triangles) which were drawn in the last frame. 

Together with \hyperlink{classirr_1_1video_1_1IVideoDriver_a2fd9d69e9fb01719b8bcff7a463929a8}{get\+F\+P\+S()} very useful method for statistics. 
\begin{DoxyParams}{Parameters}
{\em mode} & Defines if the primitives drawn are accumulated or counted per frame. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Amount of primitives drawn in the last frame. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Screen\+Size@{get\+Screen\+Size}}
\index{get\+Screen\+Size@{get\+Screen\+Size}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Screen\+Size() const  =0}{getScreenSize() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const {\bf core\+::dimension2d}$<${\bf u32}$>$\& irr\+::video\+::\+I\+Video\+Driver\+::get\+Screen\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a8c072ecaab1a2786a3feaf274fbb99b6}{}\label{classirr_1_1video_1_1IVideoDriver_a8c072ecaab1a2786a3feaf274fbb99b6}


Get the size of the screen or render window. 

\begin{DoxyReturn}{Returns}
Size of screen or render window. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Texture@{get\+Texture}}
\index{get\+Texture@{get\+Texture}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Texture(const io\+::path \&filename)=0}{getTexture(const io::path \&filename)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Texture}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::get\+Texture (
\begin{DoxyParamCaption}
\item[{const {\bf io\+::path} \&}]{filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_af4055165190e4adf221c6dc6f2434ea0}{}\label{classirr_1_1video_1_1IVideoDriver_af4055165190e4adf221c6dc6f2434ea0}


Get access to a named texture. 

Loads the texture from disk if it is not already loaded and generates mipmap levels if desired. Texture loading can be influenced using the \hyperlink{classirr_1_1video_1_1IVideoDriver_a868b58a6b86b9e4841ca3879ce246c4e}{set\+Texture\+Creation\+Flag()} method. The texture can be in several imageformats, such as B\+MP, J\+PG, T\+GA, P\+CX, P\+NG, and P\+SD. 
\begin{DoxyParams}{Parameters}
{\em filename} & Filename of the texture to be loaded. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the texture, or 0 if the texture could not be loaded. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Texture@{get\+Texture}}
\index{get\+Texture@{get\+Texture}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Texture(io\+::\+I\+Read\+File $\ast$file)=0}{getTexture(io::IReadFile *file)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Texture}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::get\+Texture (
\begin{DoxyParamCaption}
\item[{{\bf io\+::\+I\+Read\+File} $\ast$}]{file}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_aaf989c8688ffe2a28a4b8e7b6ec2bce7}{}\label{classirr_1_1video_1_1IVideoDriver_aaf989c8688ffe2a28a4b8e7b6ec2bce7}


Get access to a named texture. 

Loads the texture from disk if it is not already loaded and generates mipmap levels if desired. Texture loading can be influenced using the \hyperlink{classirr_1_1video_1_1IVideoDriver_a868b58a6b86b9e4841ca3879ce246c4e}{set\+Texture\+Creation\+Flag()} method. The texture can be in several imageformats, such as B\+MP, J\+PG, T\+GA, P\+CX, P\+NG, and P\+SD. 
\begin{DoxyParams}{Parameters}
{\em file} & Pointer to an already opened file. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the texture, or 0 if the texture could not be loaded. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Texture\+By\+Index@{get\+Texture\+By\+Index}}
\index{get\+Texture\+By\+Index@{get\+Texture\+By\+Index}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Texture\+By\+Index(u32 index)=0}{getTextureByIndex(u32 index)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Texture}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::get\+Texture\+By\+Index (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_abfe395b1320ac52cea6be0e912135351}{}\label{classirr_1_1video_1_1IVideoDriver_abfe395b1320ac52cea6be0e912135351}


Returns a texture by index. 


\begin{DoxyParams}{Parameters}
{\em index} & Index of the texture, must be smaller than \hyperlink{classirr_1_1video_1_1IVideoDriver_acdfe6845b292baeff2fa160890c6d193}{get\+Texture\+Count()} Please note that this index might change when adding or removing textures \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the texture, or 0 if the texture was not set or index is out of bounds. This pointer should not be dropped. See \hyperlink{classirr_1_1IReferenceCounted_afb169a857e0d2cdb96b8821cb9bff17a}{I\+Reference\+Counted\+::drop()} for more information. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Texture\+Count@{get\+Texture\+Count}}
\index{get\+Texture\+Count@{get\+Texture\+Count}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Texture\+Count() const  =0}{getTextureCount() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf u32} irr\+::video\+::\+I\+Video\+Driver\+::get\+Texture\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_acdfe6845b292baeff2fa160890c6d193}{}\label{classirr_1_1video_1_1IVideoDriver_acdfe6845b292baeff2fa160890c6d193}


Returns amount of textures currently loaded. 

\begin{DoxyReturn}{Returns}
Amount of textures currently loaded 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Texture\+Creation\+Flag@{get\+Texture\+Creation\+Flag}}
\index{get\+Texture\+Creation\+Flag@{get\+Texture\+Creation\+Flag}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Texture\+Creation\+Flag(\+E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+C\+R\+E\+A\+T\+I\+O\+N\+\_\+\+F\+L\+A\+G flag) const  =0}{getTextureCreationFlag(E\_TEXTURE\_CREATION\_FLAG flag) const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool irr\+::video\+::\+I\+Video\+Driver\+::get\+Texture\+Creation\+Flag (
\begin{DoxyParamCaption}
\item[{{\bf E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+C\+R\+E\+A\+T\+I\+O\+N\+\_\+\+F\+L\+AG}}]{flag}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a44621435e1e6b518fc833e6a3c68a837}{}\label{classirr_1_1video_1_1IVideoDriver_a44621435e1e6b518fc833e6a3c68a837}


Returns if a texture creation flag is enabled or disabled. 

You can change this value using \hyperlink{classirr_1_1video_1_1IVideoDriver_a868b58a6b86b9e4841ca3879ce246c4e}{set\+Texture\+Creation\+Flag()}. 
\begin{DoxyParams}{Parameters}
{\em flag} & Texture creation flag. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The current texture creation flag enabled mode. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+Transform@{get\+Transform}}
\index{get\+Transform@{get\+Transform}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+Transform(const E\+\_\+4\+X3\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+A\+T\+I\+O\+N\+\_\+\+S\+T\+A\+T\+E \&state)=0}{getTransform(const E\_4X3\_TRANSFORMATION\_STATE \&state)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const {\bf core\+::matrix4x3}\& irr\+::video\+::\+I\+Video\+Driver\+::get\+Transform (
\begin{DoxyParamCaption}
\item[{const {\bf E\+\_\+4\+X3\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+A\+T\+I\+O\+N\+\_\+\+S\+T\+A\+TE} \&}]{state}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a36c57effe355831805e340a4a1ee69b7}{}\label{classirr_1_1video_1_1IVideoDriver_a36c57effe355831805e340a4a1ee69b7}


Returns the transformation set by set\+Transform. 


\begin{DoxyParams}{Parameters}
{\em state} & Transformation type to query \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Matrix describing the transformation. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!get\+View\+Port@{get\+View\+Port}}
\index{get\+View\+Port@{get\+View\+Port}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{get\+View\+Port() const  =0}{getViewPort() const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const {\bf core\+::rect}$<${\bf s32}$>$\& irr\+::video\+::\+I\+Video\+Driver\+::get\+View\+Port (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_aaf6c38991ee735a26acf0c70ffa463e6}{}\label{classirr_1_1video_1_1IVideoDriver_aaf6c38991ee735a26acf0c70ffa463e6}


Gets the area of the current viewport. 

\begin{DoxyReturn}{Returns}
Rectangle of the current viewport. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!make\+Normal\+Map\+Texture@{make\+Normal\+Map\+Texture}}
\index{make\+Normal\+Map\+Texture@{make\+Normal\+Map\+Texture}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{make\+Normal\+Map\+Texture(video\+::\+I\+Texture $\ast$texture, f32 amplitude=1.\+0f) const  =0}{makeNormalMapTexture(video::ITexture *texture, f32 amplitude=1.0f) const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::make\+Normal\+Map\+Texture (
\begin{DoxyParamCaption}
\item[{{\bf video\+::\+I\+Texture} $\ast$}]{texture, }
\item[{{\bf f32}}]{amplitude = {\ttfamily 1.0f}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a6b349355b288c0b4ec69271e0d5cfc6b}{}\label{classirr_1_1video_1_1IVideoDriver_a6b349355b288c0b4ec69271e0d5cfc6b}


Creates a normal map from a height map texture. 

If the target texture has 32 bit, the height value is stored in the alpha component of the texture as addition. This value is used by the video\+::\+E\+M\+T\+\_\+\+P\+A\+R\+A\+L\+L\+A\+X\+\_\+\+M\+A\+P\+\_\+\+S\+O\+L\+ID material and similar materials. 
\begin{DoxyParams}{Parameters}
{\em texture} & Texture whose alpha channel is modified. \\
\hline
{\em amplitude} & Constant value by which the height information is multiplied. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!On\+Resize@{On\+Resize}}
\index{On\+Resize@{On\+Resize}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{On\+Resize(const core\+::dimension2d$<$ u32 $>$ \&size)=0}{OnResize(const core::dimension2d< u32 > \&size)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::\+On\+Resize (
\begin{DoxyParamCaption}
\item[{const {\bf core\+::dimension2d}$<$ {\bf u32} $>$ \&}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a1a236e1233fc6fc2c5f36aaa830814fc}{}\label{classirr_1_1video_1_1IVideoDriver_a1a236e1233fc6fc2c5f36aaa830814fc}


Event handler for resize events. Only used by the engine internally. 

Used to notify the driver that the window was resized. Usually, there is no need to call this method. \index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!place\+Fence@{place\+Fence}}
\index{place\+Fence@{place\+Fence}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{place\+Fence()=0}{placeFence()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf I\+Driver\+Fence}$\ast$ irr\+::video\+::\+I\+Video\+Driver\+::place\+Fence (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_aafdf5e755656fdd9f35d8ff8314db439}{}\label{classirr_1_1video_1_1IVideoDriver_aafdf5e755656fdd9f35d8ff8314db439}


needs to be \char`\"{}deleted\char`\"{} since its not refcounted 

Since not owned by any open\+GL context and hence not owned by driver \index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!query\+Feature@{query\+Feature}}
\index{query\+Feature@{query\+Feature}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{query\+Feature(\+E\+\_\+\+V\+I\+D\+E\+O\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+F\+E\+A\+T\+U\+R\+E feature) const  =0}{queryFeature(E\_VIDEO\_DRIVER\_FEATURE feature) const  =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool irr\+::video\+::\+I\+Video\+Driver\+::query\+Feature (
\begin{DoxyParamCaption}
\item[{{\bf E\+\_\+\+V\+I\+D\+E\+O\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+F\+E\+A\+T\+U\+RE}}]{feature}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_acf2585c46d032904267887284c6e041c}{}\label{classirr_1_1video_1_1IVideoDriver_acf2585c46d032904267887284c6e041c}


Queries the features of the driver. 

Returns true if a feature is available 
\begin{DoxyParams}{Parameters}
{\em feature} & Feature to query. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the feature is available, false if not. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!remove\+All\+Textures@{remove\+All\+Textures}}
\index{remove\+All\+Textures@{remove\+All\+Textures}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{remove\+All\+Textures()=0}{removeAllTextures()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::remove\+All\+Textures (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a179990e76fa91175d46c891b3508e717}{}\label{classirr_1_1video_1_1IVideoDriver_a179990e76fa91175d46c891b3508e717}


Removes all textures from the texture cache and deletes them. 

This method can free a lot of memory! Please note that after calling this, the pointer to the \hyperlink{classirr_1_1video_1_1ITexture}{I\+Texture} may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer. So it is a good idea to set all materials which are using this texture to 0 or another texture first. \index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!remove\+Texture@{remove\+Texture}}
\index{remove\+Texture@{remove\+Texture}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{remove\+Texture(\+I\+Texture $\ast$texture)=0}{removeTexture(ITexture *texture)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::remove\+Texture (
\begin{DoxyParamCaption}
\item[{{\bf I\+Texture} $\ast$}]{texture}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ac88319ec41daa23fef2ae935285afcc9}{}\label{classirr_1_1video_1_1IVideoDriver_ac88319ec41daa23fef2ae935285afcc9}


Removes a texture from the texture cache and deletes it. 

This method can free a lot of memory! Please note that after calling this, the pointer to the \hyperlink{classirr_1_1video_1_1ITexture}{I\+Texture} may no longer be valid, if it was not grabbed before by other parts of the engine for storing it longer. So it is a good idea to set all materials which are using this texture to 0 or another texture first. 
\begin{DoxyParams}{Parameters}
{\em texture} & Texture to delete from the engine cache. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!rename\+Texture@{rename\+Texture}}
\index{rename\+Texture@{rename\+Texture}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{rename\+Texture(\+I\+Texture $\ast$texture, const io\+::path \&new\+Name)=0}{renameTexture(ITexture *texture, const io::path \&newName)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::rename\+Texture (
\begin{DoxyParamCaption}
\item[{{\bf I\+Texture} $\ast$}]{texture, }
\item[{const {\bf io\+::path} \&}]{new\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a2cefddb9ebd7f46ee946c04b301a5c5b}{}\label{classirr_1_1video_1_1IVideoDriver_a2cefddb9ebd7f46ee946c04b301a5c5b}


Renames a texture. 


\begin{DoxyParams}{Parameters}
{\em texture} & Pointer to the texture to rename. \\
\hline
{\em new\+Name} & New name for the texture. This should be a unique name. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!set\+Allow\+Z\+Write\+On\+Transparent@{set\+Allow\+Z\+Write\+On\+Transparent}}
\index{set\+Allow\+Z\+Write\+On\+Transparent@{set\+Allow\+Z\+Write\+On\+Transparent}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{set\+Allow\+Z\+Write\+On\+Transparent(bool flag)=0}{setAllowZWriteOnTransparent(bool flag)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::set\+Allow\+Z\+Write\+On\+Transparent (
\begin{DoxyParamCaption}
\item[{bool}]{flag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_af78022589e5b7cb42b4d6ed2f7950e42}{}\label{classirr_1_1video_1_1IVideoDriver_af78022589e5b7cb42b4d6ed2f7950e42}


Only used by the engine internally. 

Passes the global material flag Allow\+Z\+Write\+On\+Transparent. Use the Scene\+Manager attribute to set this value from your app. 
\begin{DoxyParams}{Parameters}
{\em flag} & Default behavior is to disable Z\+Write, i.\+e. false. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!set\+Material@{set\+Material}}
\index{set\+Material@{set\+Material}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{set\+Material(const S\+Material \&material)=0}{setMaterial(const SMaterial \&material)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::set\+Material (
\begin{DoxyParamCaption}
\item[{const {\bf S\+Material} \&}]{material}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a8c9e31b41b7e6fd26cf65ce538ebab05}{}\label{classirr_1_1video_1_1IVideoDriver_a8c9e31b41b7e6fd26cf65ce538ebab05}


Sets a material. 

All 3d drawing functions will draw geometry using this material thereafter. 
\begin{DoxyParams}{Parameters}
{\em material} & Material to be used from now on. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!set\+Material\+Renderer\+Name@{set\+Material\+Renderer\+Name}}
\index{set\+Material\+Renderer\+Name@{set\+Material\+Renderer\+Name}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{set\+Material\+Renderer\+Name(s32 idx, const c8 $\ast$name)=0}{setMaterialRendererName(s32 idx, const c8 *name)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::set\+Material\+Renderer\+Name (
\begin{DoxyParamCaption}
\item[{{\bf s32}}]{idx, }
\item[{const {\bf c8} $\ast$}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a4ef324ed93094f84832e8d31cf0776f2}{}\label{classirr_1_1video_1_1IVideoDriver_a4ef324ed93094f84832e8d31cf0776f2}


Sets the name of a material renderer. 

Will have no effect on built-\/in material renderers. 
\begin{DoxyParams}{Parameters}
{\em idx} & Id of the material renderer. Can be a value of the E\+\_\+\+M\+A\+T\+E\+R\+I\+A\+L\+\_\+\+T\+Y\+PE enum or a value which was returned by \hyperlink{classirr_1_1video_1_1IVideoDriver_a0dfc3a7168f3a73a6f4323b579f03ff6}{add\+Material\+Renderer()}. \\
\hline
{\em name} & New name of the material renderer. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!set\+Min\+Hardware\+Buffer\+Vertex\+Count@{set\+Min\+Hardware\+Buffer\+Vertex\+Count}}
\index{set\+Min\+Hardware\+Buffer\+Vertex\+Count@{set\+Min\+Hardware\+Buffer\+Vertex\+Count}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{set\+Min\+Hardware\+Buffer\+Vertex\+Count(u32 count)=0}{setMinHardwareBufferVertexCount(u32 count)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::set\+Min\+Hardware\+Buffer\+Vertex\+Count (
\begin{DoxyParamCaption}
\item[{{\bf u32}}]{count}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a79cbd1329b4206503e9a9593592502ea}{}\label{classirr_1_1video_1_1IVideoDriver_a79cbd1329b4206503e9a9593592502ea}


Set the minimum number of vertices for which a hw buffer will be created. 


\begin{DoxyParams}{Parameters}
{\em count} & Number of vertices to set as minimum. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!set\+Texture\+Creation\+Flag@{set\+Texture\+Creation\+Flag}}
\index{set\+Texture\+Creation\+Flag@{set\+Texture\+Creation\+Flag}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{set\+Texture\+Creation\+Flag(\+E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+C\+R\+E\+A\+T\+I\+O\+N\+\_\+\+F\+L\+A\+G flag, bool enabled=true)=0}{setTextureCreationFlag(E\_TEXTURE\_CREATION\_FLAG flag, bool enabled=true)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::set\+Texture\+Creation\+Flag (
\begin{DoxyParamCaption}
\item[{{\bf E\+\_\+\+T\+E\+X\+T\+U\+R\+E\+\_\+\+C\+R\+E\+A\+T\+I\+O\+N\+\_\+\+F\+L\+AG}}]{flag, }
\item[{bool}]{enabled = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a868b58a6b86b9e4841ca3879ce246c4e}{}\label{classirr_1_1video_1_1IVideoDriver_a868b58a6b86b9e4841ca3879ce246c4e}


Enables or disables a texture creation flag. 

These flags define how textures should be created. By changing this value, you can influence for example the speed of rendering a lot. But please note that the video drivers take this value only as recommendation. It could happen that you enable the E\+T\+C\+F\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+16\+\_\+\+B\+IT mode, but the driver still creates 32 bit textures. 
\begin{DoxyParams}{Parameters}
{\em flag} & Texture creation flag. \\
\hline
{\em enabled} & Specifies if the given flag should be enabled or disabled. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!set\+Transform@{set\+Transform}}
\index{set\+Transform@{set\+Transform}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{set\+Transform(const E\+\_\+4\+X3\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+A\+T\+I\+O\+N\+\_\+\+S\+T\+A\+T\+E \&state, const core\+::matrix4x3 \&mat)=0}{setTransform(const E\_4X3\_TRANSFORMATION\_STATE \&state, const core::matrix4x3 \&mat)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::set\+Transform (
\begin{DoxyParamCaption}
\item[{const {\bf E\+\_\+4\+X3\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+A\+T\+I\+O\+N\+\_\+\+S\+T\+A\+TE} \&}]{state, }
\item[{const {\bf core\+::matrix4x3} \&}]{mat}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a827c428b9f83d07bfb4c6f2a0cb7dd07}{}\label{classirr_1_1video_1_1IVideoDriver_a827c428b9f83d07bfb4c6f2a0cb7dd07}


Sets transformation matrices. 


\begin{DoxyParams}{Parameters}
{\em state} & Transformation type to be set, e.\+g. view, world, or projection. \\
\hline
{\em mat} & Matrix describing the transformation. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!set\+View\+Port@{set\+View\+Port}}
\index{set\+View\+Port@{set\+View\+Port}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{set\+View\+Port(const core\+::rect$<$ s32 $>$ \&area)=0}{setViewPort(const core::rect< s32 > \&area)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::set\+View\+Port (
\begin{DoxyParamCaption}
\item[{const {\bf core\+::rect}$<$ {\bf s32} $>$ \&}]{area}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_af03cf9b67bb7b43a8021bbe4baa78a08}{}\label{classirr_1_1video_1_1IVideoDriver_af03cf9b67bb7b43a8021bbe4baa78a08}


Sets a new viewport. 

Every rendering operation is done into this new area. 
\begin{DoxyParams}{Parameters}
{\em area} & Rectangle defining the new area of rendering operations. \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!turn\+Light\+On@{turn\+Light\+On}}
\index{turn\+Light\+On@{turn\+Light\+On}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{turn\+Light\+On(s32 light\+Index, bool turn\+On)=0}{turnLightOn(s32 lightIndex, bool turnOn)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void irr\+::video\+::\+I\+Video\+Driver\+::turn\+Light\+On (
\begin{DoxyParamCaption}
\item[{{\bf s32}}]{light\+Index, }
\item[{bool}]{turn\+On}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a3c26904f7d1bf0e37d51fe71562346a0}{}\label{classirr_1_1video_1_1IVideoDriver_a3c26904f7d1bf0e37d51fe71562346a0}
Turns a dynamic light on or off 
\begin{DoxyParams}{Parameters}
{\em light\+Index} & the index returned by add\+Dynamic\+Light \\
\hline
{\em turn\+On} & true to turn the light on, false to turn it off \\
\hline
\end{DoxyParams}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!write\+Image\+To\+File@{write\+Image\+To\+File}}
\index{write\+Image\+To\+File@{write\+Image\+To\+File}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{write\+Image\+To\+File(\+I\+Image $\ast$image, const io\+::path \&filename, u32 param=0)=0}{writeImageToFile(IImage *image, const io::path \&filename, u32 param=0)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool irr\+::video\+::\+I\+Video\+Driver\+::write\+Image\+To\+File (
\begin{DoxyParamCaption}
\item[{{\bf I\+Image} $\ast$}]{image, }
\item[{const {\bf io\+::path} \&}]{filename, }
\item[{{\bf u32}}]{param = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_a407d6a1483f995060035340e0a92ce9b}{}\label{classirr_1_1video_1_1IVideoDriver_a407d6a1483f995060035340e0a92ce9b}


Writes the provided image to a file. 

Requires that there is a suitable image writer registered for writing the image. 
\begin{DoxyParams}{Parameters}
{\em image} & Image to write. \\
\hline
{\em filename} & Name of the file to write. \\
\hline
{\em param} & Control parameter for the backend (e.\+g. compression level). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True on successful write. 
\end{DoxyReturn}
\index{irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}!write\+Image\+To\+File@{write\+Image\+To\+File}}
\index{write\+Image\+To\+File@{write\+Image\+To\+File}!irr\+::video\+::\+I\+Video\+Driver@{irr\+::video\+::\+I\+Video\+Driver}}
\subsubsection[{\texorpdfstring{write\+Image\+To\+File(\+I\+Image $\ast$image, io\+::\+I\+Write\+File $\ast$file, u32 param=0)=0}{writeImageToFile(IImage *image, io::IWriteFile *file, u32 param=0)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool irr\+::video\+::\+I\+Video\+Driver\+::write\+Image\+To\+File (
\begin{DoxyParamCaption}
\item[{{\bf I\+Image} $\ast$}]{image, }
\item[{{\bf io\+::\+I\+Write\+File} $\ast$}]{file, }
\item[{{\bf u32}}]{param = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classirr_1_1video_1_1IVideoDriver_ae12c362cfbc92a7c59b434666c8436c0}{}\label{classirr_1_1video_1_1IVideoDriver_ae12c362cfbc92a7c59b434666c8436c0}


Writes the provided image to a file. 

Requires that there is a suitable image writer registered for writing the image. 
\begin{DoxyParams}{Parameters}
{\em image} & Image to write. \\
\hline
{\em file} & An already open \hyperlink{classirr_1_1io_1_1IWriteFile}{io\+::\+I\+Write\+File} object. The name will be used to determine the appropriate image writer to use. \\
\hline
{\em param} & Control parameter for the backend (e.\+g. compression level). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True on successful write. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/I\+Video\+Driver.\+h\end{DoxyCompactItemize}
