<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Irrlicht 2.0: irr::scene::ISceneManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Irrlicht 2.0
   </div>
   <div id="projectbrief">FastOpenSource3DEnginebasedonOpenGL4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceirr.html">irr</a></li><li class="navelem"><a class="el" href="namespaceirr_1_1scene.html">scene</a></li><li class="navelem"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classirr_1_1scene_1_1ISceneManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">irr::scene::ISceneManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The Scene Manager manages scene nodes, mesh recources, cameras and all the other stuff.  
 <a href="classirr_1_1scene_1_1ISceneManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ISceneManager_8h_source.html">ISceneManager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for irr::scene::ISceneManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classirr_1_1scene_1_1ISceneManager.png" usemap="#irr::scene::ISceneManager_map" alt=""/>
  <map id="irr::scene::ISceneManager_map" name="irr::scene::ISceneManager_map">
<area href="classirr_1_1IReferenceCounted.html" title="Base class of most objects of the Irrlicht Engine. " alt="irr::IReferenceCounted" shape="rect" coords="0,0,161,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aca1b12117220849983243ee2f73a8f4d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMesh.html">ICPUMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aca1b12117220849983243ee2f73a8f4d">getMesh</a> (const <a class="el" href="namespaceirr_1_1io.html#ab1bdc45edb3f94d8319c02bc0f840ee1">io::path</a> &amp;filename)=0</td></tr>
<tr class="memdesc:aca1b12117220849983243ee2f73a8f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to an animateable mesh. Loads the file if not loaded already.  <a href="#aca1b12117220849983243ee2f73a8f4d">More...</a><br /></td></tr>
<tr class="separator:aca1b12117220849983243ee2f73a8f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733c4e8040702ec9fe486ee15a5089a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMesh.html">ICPUMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a733c4e8040702ec9fe486ee15a5089a6">getMesh</a> (<a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *file)=0</td></tr>
<tr class="memdesc:a733c4e8040702ec9fe486ee15a5089a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to an animateable mesh. Loads the file if not loaded already.  <a href="#a733c4e8040702ec9fe486ee15a5089a6">More...</a><br /></td></tr>
<tr class="separator:a733c4e8040702ec9fe486ee15a5089a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ffbb676d3c68becfb565cf72e2afa0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshCache.html">IMeshCache</a>&lt; <a class="el" href="classirr_1_1scene_1_1IMesh.html">ICPUMesh</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ac5ffbb676d3c68becfb565cf72e2afa0">getMeshCache</a> ()=0</td></tr>
<tr class="memdesc:ac5ffbb676d3c68becfb565cf72e2afa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interface to the mesh cache which is shared beween all existing scene managers.  <a href="#ac5ffbb676d3c68becfb565cf72e2afa0">More...</a><br /></td></tr>
<tr class="separator:ac5ffbb676d3c68becfb565cf72e2afa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde082160205a8faab44cd5b61e3745c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IVideoDriver.html">video::IVideoDriver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#afde082160205a8faab44cd5b61e3745c">getVideoDriver</a> ()=0</td></tr>
<tr class="memdesc:afde082160205a8faab44cd5b61e3745c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the video driver.  <a href="#afde082160205a8faab44cd5b61e3745c">More...</a><br /></td></tr>
<tr class="separator:afde082160205a8faab44cd5b61e3745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd98fbeba199005cf795a5bae7ccbaf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1io_1_1IFileSystem.html">io::IFileSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#adbd98fbeba199005cf795a5bae7ccbaf">getFileSystem</a> ()=0</td></tr>
<tr class="memdesc:adbd98fbeba199005cf795a5bae7ccbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active FileSystem.  <a href="#adbd98fbeba199005cf795a5bae7ccbaf">More...</a><br /></td></tr>
<tr class="separator:adbd98fbeba199005cf795a5bae7ccbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4dcb2db5e5e03088ecf8be1b18224b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshSceneNode.html">IMeshSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#afd4dcb2db5e5e03088ecf8be1b18224b">addCubeSceneNode</a> (<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> size=10.0f, IDummyTransformationSceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0</td></tr>
<tr class="memdesc:afd4dcb2db5e5e03088ecf8be1b18224b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cube scene node.  <a href="#afd4dcb2db5e5e03088ecf8be1b18224b">More...</a><br /></td></tr>
<tr class="separator:afd4dcb2db5e5e03088ecf8be1b18224b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12969449cd9a4365657702a69315d1db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshSceneNode.html">IMeshSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a12969449cd9a4365657702a69315d1db">addSphereSceneNode</a> (<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> radius=5.0f, s32 polyCount=16, IDummyTransformationSceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))=0</td></tr>
<tr class="memdesc:a12969449cd9a4365657702a69315d1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a sphere scene node of the given radius and detail.  <a href="#a12969449cd9a4365657702a69315d1db">More...</a><br /></td></tr>
<tr class="separator:a12969449cd9a4365657702a69315d1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4951de213617dba472877a459d9e4402"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4951de213617dba472877a459d9e4402"></a>
virtual <a class="el" href="classirr_1_1scene_1_1ISkinnedMeshSceneNode.html">ISkinnedMeshSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a4951de213617dba472877a459d9e4402">addSkinnedMeshSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1IGPUSkinnedMesh.html">IGPUSkinnedMesh</a> *mesh, const <a class="el" href="classirr_1_1scene_1_1ISkinningStateManager.html#a78f9d8d280dc029b3637bd3a48c0c3c6">ISkinningStateManager::E_BONE_UPDATE_MODE</a> &amp;boneControlMode=<a class="el" href="classirr_1_1scene_1_1ISkinningStateManager.html#a78f9d8d280dc029b3637bd3a48c0c3c6af91613b0a4c9ac338de93ff48a28885c">ISkinningStateManager::EBUM_NONE</a>, <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1, const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;rotation=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;scale=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f, 1.0f, 1.0f))=0</td></tr>
<tr class="memdesc:a4951de213617dba472877a459d9e4402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node for rendering an skinned mesh model. <br /></td></tr>
<tr class="separator:a4951de213617dba472877a459d9e4402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b254e43611c84a73c1302ced3816a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshSceneNode.html">IMeshSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a38b254e43611c84a73c1302ced3816a8">addMeshSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1IMesh.html">IGPUMesh</a> *mesh, <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1, const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;rotation=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;scale=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f, 1.0f, 1.0f), bool alsoAddIfMeshPointerZero=false)=0</td></tr>
<tr class="memdesc:a38b254e43611c84a73c1302ced3816a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node for rendering a static mesh.  <a href="#a38b254e43611c84a73c1302ced3816a8">More...</a><br /></td></tr>
<tr class="separator:a38b254e43611c84a73c1302ced3816a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8828efc58d2e2630ce14453978bfa710"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8828efc58d2e2630ce14453978bfa710"></a>
virtual <a class="el" href="classirr_1_1scene_1_1IMeshSceneNodeInstanced.html">IMeshSceneNodeInstanced</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>addMeshSceneNodeInstanced</b> (<a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1, const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;rotation=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;scale=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f, 1.0f, 1.0f))=0</td></tr>
<tr class="separator:a8828efc58d2e2630ce14453978bfa710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8f9930cfbd4469ebfd798ba1e65db8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a6d8f9930cfbd4469ebfd798ba1e65db8">addCameraSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;lookat=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 100), <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1, bool makeActive=true)=0</td></tr>
<tr class="memdesc:a6d8f9930cfbd4469ebfd798ba1e65db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a camera scene node to the scene graph and sets it as active camera.  <a href="#a6d8f9930cfbd4469ebfd798ba1e65db8">More...</a><br /></td></tr>
<tr class="separator:a6d8f9930cfbd4469ebfd798ba1e65db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6cafb1f284dea325e9511917cb1f14"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#adc6cafb1f284dea325e9511917cb1f14">addCameraSceneNodeMaya</a> (<a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> rotateSpeed=-1500.f, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> zoomSpeed=200.f, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> translationSpeed=1500.f, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> distance=70.f, bool makeActive=true)=0</td></tr>
<tr class="memdesc:adc6cafb1f284dea325e9511917cb1f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a maya style user controlled camera scene node to the scene graph.  <a href="#adc6cafb1f284dea325e9511917cb1f14">More...</a><br /></td></tr>
<tr class="separator:adc6cafb1f284dea325e9511917cb1f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad89f90e140ec8f26ec54c9b8f3d81c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a0ad89f90e140ec8f26ec54c9b8f3d81c">addCameraSceneNodeFPS</a> (<a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> rotateSpeed=100.0f, f32 moveSpeed=0.5f, s32 id=-1, SKeyMap *keyMapArray=0, s32 keyMapSize=0, bool noVerticalMovement=false, f32 jumpSpeed=0.f, bool invertMouse=false, bool makeActive=true)=0</td></tr>
<tr class="memdesc:a0ad89f90e140ec8f26ec54c9b8f3d81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a camera scene node with an animator which provides mouse and keyboard control appropriate for first person shooters (FPS).  <a href="#a0ad89f90e140ec8f26ec54c9b8f3d81c">More...</a><br /></td></tr>
<tr class="separator:a0ad89f90e140ec8f26ec54c9b8f3d81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac832789009b7670a90eb0e3250397a83"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ILightSceneNode.html">ILightSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ac832789009b7670a90eb0e3250397a83">addLightSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), <a class="el" href="classirr_1_1video_1_1SColorf.html">video::SColorf</a> color=<a class="el" href="classirr_1_1video_1_1SColorf.html">video::SColorf</a>(1.0f, 1.0f, 1.0f), f32 radius=100.0f, s32 id=-1)=0</td></tr>
<tr class="memdesc:ac832789009b7670a90eb0e3250397a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dynamic light scene node to the scene graph.  <a href="#ac832789009b7670a90eb0e3250397a83">More...</a><br /></td></tr>
<tr class="separator:ac832789009b7670a90eb0e3250397a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580bb5e0db1043e9c57874b87a7d3b8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IBillboardSceneNode.html">IBillboardSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a580bb5e0db1043e9c57874b87a7d3b8a">addBillboardSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;size=<a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt;(10.0f, 10.0f), const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1, video::SColor colorTop=0xFFFFFFFF, video::SColor colorBottom=0xFFFFFFFF)=0</td></tr>
<tr class="memdesc:a580bb5e0db1043e9c57874b87a7d3b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a billboard scene node to the scene graph.  <a href="#a580bb5e0db1043e9c57874b87a7d3b8a">More...</a><br /></td></tr>
<tr class="separator:a580bb5e0db1043e9c57874b87a7d3b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd697396eaef0d1d22e7bb32abbf7d55"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#acd697396eaef0d1d22e7bb32abbf7d55">addSkyBoxSceneNode</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *top, <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *bottom, <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *left, <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *right, <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *front, <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *back, <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1)=0</td></tr>
<tr class="memdesc:acd697396eaef0d1d22e7bb32abbf7d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a skybox scene node to the scene graph.  <a href="#acd697396eaef0d1d22e7bb32abbf7d55">More...</a><br /></td></tr>
<tr class="separator:acd697396eaef0d1d22e7bb32abbf7d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ea6d8b624064781a6ffd6a1841b525"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a30ea6d8b624064781a6ffd6a1841b525">addSkyDomeSceneNode</a> (<a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *texture, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> horiRes=16, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> vertRes=8, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> texturePercentage=0.9, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> spherePercentage=2.0, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> radius=1000.f, <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1)=0</td></tr>
<tr class="memdesc:a30ea6d8b624064781a6ffd6a1841b525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a skydome scene node to the scene graph.  <a href="#a30ea6d8b624064781a6ffd6a1841b525">More...</a><br /></td></tr>
<tr class="separator:a30ea6d8b624064781a6ffd6a1841b525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb834a110b49b0306c9220dee900b66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aebb834a110b49b0306c9220dee900b66">addEmptySceneNode</a> (<a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1)=0</td></tr>
<tr class="memdesc:aebb834a110b49b0306c9220dee900b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an empty scene node to the scene graph.  <a href="#aebb834a110b49b0306c9220dee900b66">More...</a><br /></td></tr>
<tr class="separator:aebb834a110b49b0306c9220dee900b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae411fd946f586aaed158364640cef58c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ae411fd946f586aaed158364640cef58c">addDummyTransformationSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> id=-1)=0</td></tr>
<tr class="memdesc:ae411fd946f586aaed158364640cef58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dummy transformation scene node to the scene graph.  <a href="#ae411fd946f586aaed158364640cef58c">More...</a><br /></td></tr>
<tr class="separator:ae411fd946f586aaed158364640cef58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7075320f1a3bf2838f29c23f78635f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a4f7075320f1a3bf2838f29c23f78635f">getRootSceneNode</a> ()=0</td></tr>
<tr class="memdesc:a4f7075320f1a3bf2838f29c23f78635f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the root scene node.  <a href="#a4f7075320f1a3bf2838f29c23f78635f">More...</a><br /></td></tr>
<tr class="separator:a4f7075320f1a3bf2838f29c23f78635f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78585330c2c7ffae133abefd55f495b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a78585330c2c7ffae133abefd55f495b3">getActiveCamera</a> () const  =0</td></tr>
<tr class="memdesc:a78585330c2c7ffae133abefd55f495b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current active camera.  <a href="#a78585330c2c7ffae133abefd55f495b3">More...</a><br /></td></tr>
<tr class="separator:a78585330c2c7ffae133abefd55f495b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d19b7a6803a0a021082fc2b86043b3d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a5d19b7a6803a0a021082fc2b86043b3d">setActiveCamera</a> (<a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *camera)=0</td></tr>
<tr class="memdesc:a5d19b7a6803a0a021082fc2b86043b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the currently active camera.  <a href="#a5d19b7a6803a0a021082fc2b86043b3d">More...</a><br /></td></tr>
<tr class="separator:a5d19b7a6803a0a021082fc2b86043b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf17bdde6d4e9ef61a76f3b43100ecb8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aaf17bdde6d4e9ef61a76f3b43100ecb8">registerNodeForRendering</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node, <a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a> pass=<a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67fa5ceee6e4bc2fab42c663b32018e276e8">ESNRP_AUTOMATIC</a>)=0</td></tr>
<tr class="memdesc:aaf17bdde6d4e9ef61a76f3b43100ecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a node for rendering it at a specific time.  <a href="#aaf17bdde6d4e9ef61a76f3b43100ecb8">More...</a><br /></td></tr>
<tr class="separator:aaf17bdde6d4e9ef61a76f3b43100ecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04240262904667c821bd9de5e5fd9b02"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a04240262904667c821bd9de5e5fd9b02">drawAll</a> ()=0</td></tr>
<tr class="memdesc:a04240262904667c821bd9de5e5fd9b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws all the scene nodes.  <a href="#a04240262904667c821bd9de5e5fd9b02">More...</a><br /></td></tr>
<tr class="separator:a04240262904667c821bd9de5e5fd9b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29efe9505de4e5dc2218283ef0c2a64d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a29efe9505de4e5dc2218283ef0c2a64d">createRotationAnimator</a> (const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;rotationSpeed)=0</td></tr>
<tr class="memdesc:a29efe9505de4e5dc2218283ef0c2a64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotation animator, which rotates the attached scene node around itself.  <a href="#a29efe9505de4e5dc2218283ef0c2a64d">More...</a><br /></td></tr>
<tr class="separator:a29efe9505de4e5dc2218283ef0c2a64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e49ff49bc9e88e8ecf3d681354e1ab6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a2e49ff49bc9e88e8ecf3d681354e1ab6">createFlyCircleAnimator</a> (const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;center=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0.f, 0.f, 0.f), <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> radius=100.f, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> speed=0.001f, const core::vector3df &amp;direction=core::vector3df(0.f, 1.f, 0.f), f32 startPosition=0.f, f32 radiusEllipsoid=0.f)=0</td></tr>
<tr class="memdesc:a2e49ff49bc9e88e8ecf3d681354e1ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fly circle animator, which lets the attached scene node fly around a center.  <a href="#a2e49ff49bc9e88e8ecf3d681354e1ab6">More...</a><br /></td></tr>
<tr class="separator:a2e49ff49bc9e88e8ecf3d681354e1ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865c2da86486dcdb44847d5baa7aaa61"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a865c2da86486dcdb44847d5baa7aaa61">createFlyStraightAnimator</a> (const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;startPoint, const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;endPoint, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> timeForWay, bool loop=false, bool pingpong=false)=0</td></tr>
<tr class="memdesc:a865c2da86486dcdb44847d5baa7aaa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fly straight animator, which lets the attached scene node fly or move along a line between two points.  <a href="#a865c2da86486dcdb44847d5baa7aaa61">More...</a><br /></td></tr>
<tr class="separator:a865c2da86486dcdb44847d5baa7aaa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae212e01dffc4891d32e3d1735d22d04a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ae212e01dffc4891d32e3d1735d22d04a">createTextureAnimator</a> (const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> * &gt; &amp;textures, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> timePerFrame, bool loop=true)=0</td></tr>
<tr class="memdesc:ae212e01dffc4891d32e3d1735d22d04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture animator, which switches the textures of the target scene node based on a list of textures.  <a href="#ae212e01dffc4891d32e3d1735d22d04a">More...</a><br /></td></tr>
<tr class="separator:ae212e01dffc4891d32e3d1735d22d04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163cc04ff2cb03852ac891de56200fa3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a163cc04ff2cb03852ac891de56200fa3">createDeleteAnimator</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> timeMs)=0</td></tr>
<tr class="memdesc:a163cc04ff2cb03852ac891de56200fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scene node animator, which deletes the scene node after some time automatically.  <a href="#a163cc04ff2cb03852ac891de56200fa3">More...</a><br /></td></tr>
<tr class="separator:a163cc04ff2cb03852ac891de56200fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c9d4ab88bbe2ad71623b1054a0c3ba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ab0c9d4ab88bbe2ad71623b1054a0c3ba">createFollowSplineAnimator</a> (<a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> startTime, const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &gt; &amp;points, <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> speed=1.0f, f32 tightness=0.5f, bool loop=true, bool pingpong=false)=0</td></tr>
<tr class="memdesc:ab0c9d4ab88bbe2ad71623b1054a0c3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a follow spline animator.  <a href="#ab0c9d4ab88bbe2ad71623b1054a0c3ba">More...</a><br /></td></tr>
<tr class="separator:ab0c9d4ab88bbe2ad71623b1054a0c3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808972cc001db86c0576c38b3b3fbbf7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a808972cc001db86c0576c38b3b3fbbf7">addExternalMeshLoader</a> (<a class="el" href="classirr_1_1scene_1_1IMeshLoader.html">IMeshLoader</a> *externalLoader)=0</td></tr>
<tr class="memdesc:a808972cc001db86c0576c38b3b3fbbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external mesh loader for extending the engine with new file formats.  <a href="#a808972cc001db86c0576c38b3b3fbbf7">More...</a><br /></td></tr>
<tr class="separator:a808972cc001db86c0576c38b3b3fbbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f1cb453aa87f3cbaa2fd9d1a2aa9a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78f1cb453aa87f3cbaa2fd9d1a2aa9a6"></a>
virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a78f1cb453aa87f3cbaa2fd9d1a2aa9a6">getMeshLoaderCount</a> () const  =0</td></tr>
<tr class="memdesc:a78f1cb453aa87f3cbaa2fd9d1a2aa9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mesh loaders supported by Irrlicht at this time. <br /></td></tr>
<tr class="separator:a78f1cb453aa87f3cbaa2fd9d1a2aa9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd2e6e1f82298b9b95e96d2b36ddc33"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshLoader.html">IMeshLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a9fd2e6e1f82298b9b95e96d2b36ddc33">getMeshLoader</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index) const  =0</td></tr>
<tr class="memdesc:a9fd2e6e1f82298b9b95e96d2b36ddc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the given mesh loader.  <a href="#a9fd2e6e1f82298b9b95e96d2b36ddc33">More...</a><br /></td></tr>
<tr class="separator:a9fd2e6e1f82298b9b95e96d2b36ddc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05138d6b5f99fced0061794fb5c42318"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshManipulator.html">IMeshManipulator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a05138d6b5f99fced0061794fb5c42318">getMeshManipulator</a> ()=0</td></tr>
<tr class="memdesc:a05138d6b5f99fced0061794fb5c42318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the mesh manipulator.  <a href="#a05138d6b5f99fced0061794fb5c42318">More...</a><br /></td></tr>
<tr class="separator:a05138d6b5f99fced0061794fb5c42318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c29710a7802881200a26384313bd14c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a4c29710a7802881200a26384313bd14c">addToDeletionQueue</a> (<a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *node)=0</td></tr>
<tr class="memdesc:a4c29710a7802881200a26384313bd14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node to the deletion queue.  <a href="#a4c29710a7802881200a26384313bd14c">More...</a><br /></td></tr>
<tr class="separator:a4c29710a7802881200a26384313bd14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68aa8d654884f19ad52fa28f11db424"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ac68aa8d654884f19ad52fa28f11db424">postEventFromUser</a> (const <a class="el" href="structirr_1_1SEvent.html">SEvent</a> &amp;event)=0</td></tr>
<tr class="memdesc:ac68aa8d654884f19ad52fa28f11db424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an input event to the environment.  <a href="#ac68aa8d654884f19ad52fa28f11db424">More...</a><br /></td></tr>
<tr class="separator:ac68aa8d654884f19ad52fa28f11db424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa3d11a833b89f7579848e234881988"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#abaa3d11a833b89f7579848e234881988">clear</a> ()=0</td></tr>
<tr class="memdesc:abaa3d11a833b89f7579848e234881988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the whole scene.  <a href="#abaa3d11a833b89f7579848e234881988">More...</a><br /></td></tr>
<tr class="separator:abaa3d11a833b89f7579848e234881988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f92b38444d719c4d2314242884e4951"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a7f92b38444d719c4d2314242884e4951">getSceneNodeRenderPass</a> () const  =0</td></tr>
<tr class="memdesc:a7f92b38444d719c4d2314242884e4951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current render pass.  <a href="#a7f92b38444d719c4d2314242884e4951">More...</a><br /></td></tr>
<tr class="separator:a7f92b38444d719c4d2314242884e4951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea0ec7ec95a97819f1de5222b97e774"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeFactory.html">ISceneNodeFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a1ea0ec7ec95a97819f1de5222b97e774">getDefaultSceneNodeFactory</a> ()=0</td></tr>
<tr class="memdesc:a1ea0ec7ec95a97819f1de5222b97e774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default scene node factory which can create all built in scene nodes.  <a href="#a1ea0ec7ec95a97819f1de5222b97e774">More...</a><br /></td></tr>
<tr class="separator:a1ea0ec7ec95a97819f1de5222b97e774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ac9315def74ae5e26a2d6a2f5a38e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a75ac9315def74ae5e26a2d6a2f5a38e9">registerSceneNodeFactory</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNodeFactory.html">ISceneNodeFactory</a> *factoryToAdd)=0</td></tr>
<tr class="memdesc:a75ac9315def74ae5e26a2d6a2f5a38e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node factory to the scene manager.  <a href="#a75ac9315def74ae5e26a2d6a2f5a38e9">More...</a><br /></td></tr>
<tr class="separator:a75ac9315def74ae5e26a2d6a2f5a38e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6297be8248b8bada0de1bf7f56753c63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6297be8248b8bada0de1bf7f56753c63"></a>
virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a6297be8248b8bada0de1bf7f56753c63">getRegisteredSceneNodeFactoryCount</a> () const  =0</td></tr>
<tr class="memdesc:a6297be8248b8bada0de1bf7f56753c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get amount of registered scene node factories. <br /></td></tr>
<tr class="separator:a6297be8248b8bada0de1bf7f56753c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac912b9effd5ce46f5dc038e0568e614c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeFactory.html">ISceneNodeFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ac912b9effd5ce46f5dc038e0568e614c">getSceneNodeFactory</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index)=0</td></tr>
<tr class="memdesc:ac912b9effd5ce46f5dc038e0568e614c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a scene node factory by index.  <a href="#ac912b9effd5ce46f5dc038e0568e614c">More...</a><br /></td></tr>
<tr class="separator:ac912b9effd5ce46f5dc038e0568e614c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb3d24c8ffafd5e671f344931a0b3a5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorFactory.html">ISceneNodeAnimatorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#adeb3d24c8ffafd5e671f344931a0b3a5">getDefaultSceneNodeAnimatorFactory</a> ()=0</td></tr>
<tr class="memdesc:adeb3d24c8ffafd5e671f344931a0b3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default scene node animator factory which can create all built-in scene node animators.  <a href="#adeb3d24c8ffafd5e671f344931a0b3a5">More...</a><br /></td></tr>
<tr class="separator:adeb3d24c8ffafd5e671f344931a0b3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48c93cc41f986f08ed964cc575ee7a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#af48c93cc41f986f08ed964cc575ee7a0">registerSceneNodeAnimatorFactory</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorFactory.html">ISceneNodeAnimatorFactory</a> *factoryToAdd)=0</td></tr>
<tr class="memdesc:af48c93cc41f986f08ed964cc575ee7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node animator factory to the scene manager.  <a href="#af48c93cc41f986f08ed964cc575ee7a0">More...</a><br /></td></tr>
<tr class="separator:af48c93cc41f986f08ed964cc575ee7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d694570ee1de7279727555a9ecd7bc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d694570ee1de7279727555a9ecd7bc2"></a>
virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a8d694570ee1de7279727555a9ecd7bc2">getRegisteredSceneNodeAnimatorFactoryCount</a> () const  =0</td></tr>
<tr class="memdesc:a8d694570ee1de7279727555a9ecd7bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get amount of registered scene node animator factories. <br /></td></tr>
<tr class="separator:a8d694570ee1de7279727555a9ecd7bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d8272b74bd0adc9138f17e832dc887"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorFactory.html">ISceneNodeAnimatorFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a96d8272b74bd0adc9138f17e832dc887">getSceneNodeAnimatorFactory</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index)=0</td></tr>
<tr class="memdesc:a96d8272b74bd0adc9138f17e832dc887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scene node animator factory by index.  <a href="#a96d8272b74bd0adc9138f17e832dc887">More...</a><br /></td></tr>
<tr class="separator:a96d8272b74bd0adc9138f17e832dc887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8cc1f55b8e067528b7a9a21b7fdd50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f8cc1f55b8e067528b7a9a21b7fdd50"></a>
virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a9f8cc1f55b8e067528b7a9a21b7fdd50">getSceneNodeTypeName</a> (<a class="el" href="namespaceirr_1_1scene.html#acad3d7ef92a9807d391ba29120f3b7bd">ESCENE_NODE_TYPE</a> type)=0</td></tr>
<tr class="memdesc:a9f8cc1f55b8e067528b7a9a21b7fdd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get typename from a scene node type or null if not found. <br /></td></tr>
<tr class="separator:a9f8cc1f55b8e067528b7a9a21b7fdd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedfa596280048e6ea6463ff69d23855"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeedfa596280048e6ea6463ff69d23855"></a>
virtual const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aeedfa596280048e6ea6463ff69d23855">getAnimatorTypeName</a> (<a class="el" href="namespaceirr_1_1scene.html#a327a1e43872705cf8f3f3342fb307d19">ESCENE_NODE_ANIMATOR_TYPE</a> type)=0</td></tr>
<tr class="memdesc:aeedfa596280048e6ea6463ff69d23855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typename from a scene node animator type or null if not found. <br /></td></tr>
<tr class="separator:aeedfa596280048e6ea6463ff69d23855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3616e641e586b400a923b967ff32ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a8a3616e641e586b400a923b967ff32ab">addSceneNode</a> (const char *sceneNodeTypeName, <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *parent=0)=0</td></tr>
<tr class="memdesc:a8a3616e641e586b400a923b967ff32ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node to the scene by name.  <a href="#a8a3616e641e586b400a923b967ff32ab">More...</a><br /></td></tr>
<tr class="separator:a8a3616e641e586b400a923b967ff32ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63c38a05b8e7d0a11ddb1752da36835"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ac63c38a05b8e7d0a11ddb1752da36835">createSceneNodeAnimator</a> (const char *typeName, <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *target=0)=0</td></tr>
<tr class="memdesc:ac63c38a05b8e7d0a11ddb1752da36835"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a scene node animator based on its type name  <a href="#ac63c38a05b8e7d0a11ddb1752da36835">More...</a><br /></td></tr>
<tr class="separator:ac63c38a05b8e7d0a11ddb1752da36835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94805dd4eca41ccef9607aefe669aed9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a94805dd4eca41ccef9607aefe669aed9">createNewSceneManager</a> (bool cloneContent=false)=0</td></tr>
<tr class="memdesc:a94805dd4eca41ccef9607aefe669aed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new scene manager.  <a href="#a94805dd4eca41ccef9607aefe669aed9">More...</a><br /></td></tr>
<tr class="separator:a94805dd4eca41ccef9607aefe669aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a06fb68757381f99cfe11ecbd153e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshWriter.html">IMeshWriter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ae9a06fb68757381f99cfe11ecbd153e6">createMeshWriter</a> (<a class="el" href="namespaceirr_1_1scene.html#a431fa15741518ba15f6d5f2608b6cb4e">EMESH_WRITER_TYPE</a> type)=0</td></tr>
<tr class="memdesc:ae9a06fb68757381f99cfe11ecbd153e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mesh writer implementation if available.  <a href="#ae9a06fb68757381f99cfe11ecbd153e6">More...</a><br /></td></tr>
<tr class="separator:ae9a06fb68757381f99cfe11ecbd153e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a424accb615c4f60fde59f55033a816"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a424accb615c4f60fde59f55033a816"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a8a424accb615c4f60fde59f55033a816">setAmbientLight</a> (const <a class="el" href="classirr_1_1video_1_1SColorf.html">video::SColorf</a> &amp;ambientColor)=0</td></tr>
<tr class="memdesc:a8a424accb615c4f60fde59f55033a816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ambient color of the scene. <br /></td></tr>
<tr class="separator:a8a424accb615c4f60fde59f55033a816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec06ba0cc248383153af9bc044cbd34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adec06ba0cc248383153af9bc044cbd34"></a>
virtual const <a class="el" href="classirr_1_1video_1_1SColorf.html">video::SColorf</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#adec06ba0cc248383153af9bc044cbd34">getAmbientLight</a> () const  =0</td></tr>
<tr class="memdesc:adec06ba0cc248383153af9bc044cbd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ambient color of the scene. <br /></td></tr>
<tr class="separator:adec06ba0cc248383153af9bc044cbd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0065307bf3ff12fdc5b7bb624987a1c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a0065307bf3ff12fdc5b7bb624987a1c2">setLightManager</a> (<a class="el" href="classirr_1_1scene_1_1ILightManager.html">ILightManager</a> *lightManager)=0</td></tr>
<tr class="memdesc:a0065307bf3ff12fdc5b7bb624987a1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a custom callbacks manager which gets callbacks during scene rendering.  <a href="#a0065307bf3ff12fdc5b7bb624987a1c2">More...</a><br /></td></tr>
<tr class="separator:a0065307bf3ff12fdc5b7bb624987a1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa907bfdd82887a9855157fdfb41985e0"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classirr_1_1scene_1_1IGeometryCreator.html">IGeometryCreator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aa907bfdd82887a9855157fdfb41985e0">getGeometryCreator</a> (void) const  =0</td></tr>
<tr class="memdesc:aa907bfdd82887a9855157fdfb41985e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an instance of a geometry creator.  <a href="#aa907bfdd82887a9855157fdfb41985e0">More...</a><br /></td></tr>
<tr class="separator:aa907bfdd82887a9855157fdfb41985e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819bea16578056eea049d4bfe0545575"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a819bea16578056eea049d4bfe0545575">isCulled</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node) const  =0</td></tr>
<tr class="memdesc:a819bea16578056eea049d4bfe0545575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if node is culled in current view frustum.  <a href="#a819bea16578056eea049d4bfe0545575">More...</a><br /></td></tr>
<tr class="separator:a819bea16578056eea049d4bfe0545575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8411682018e68a2752d4c82675c71040"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a8411682018e68a2752d4c82675c71040">IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78abc75801cbb13d9db0955b3c07251c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a78abc75801cbb13d9db0955b3c07251c">~IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7a035532e5f409ca9482dab79185f4 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a2b7a035532e5f409ca9482dab79185f4">grab</a> () const </td></tr>
<tr class="memdesc:a2b7a035532e5f409ca9482dab79185f4 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the object. Increments the reference counter by one.  <a href="#a2b7a035532e5f409ca9482dab79185f4">More...</a><br /></td></tr>
<tr class="separator:a2b7a035532e5f409ca9482dab79185f4 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb169a857e0d2cdb96b8821cb9bff17a inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a">drop</a> () const </td></tr>
<tr class="memdesc:afb169a857e0d2cdb96b8821cb9bff17a inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the object. Decrements the reference counter by one.  <a href="#afb169a857e0d2cdb96b8821cb9bff17a">More...</a><br /></td></tr>
<tr class="separator:afb169a857e0d2cdb96b8821cb9bff17a inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198560456588db46331f06eda909a399 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a198560456588db46331f06eda909a399">getReferenceCount</a> () const </td></tr>
<tr class="memdesc:a198560456588db46331f06eda909a399 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <a href="#a198560456588db46331f06eda909a399">More...</a><br /></td></tr>
<tr class="separator:a198560456588db46331f06eda909a399 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768e697e55d496e396b3acc5003d2bea inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a768e697e55d496e396b3acc5003d2bea">getDebugName</a> () const </td></tr>
<tr class="memdesc:a768e697e55d496e396b3acc5003d2bea inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of the object.  <a href="#a768e697e55d496e396b3acc5003d2bea">More...</a><br /></td></tr>
<tr class="separator:a768e697e55d496e396b3acc5003d2bea inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">setDebugName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *newName)</td></tr>
<tr class="memdesc:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name of the object.  <a href="#a704c5042d399fe8cd3bdd65a0559002a">More...</a><br /></td></tr>
<tr class="separator:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Scene Manager manages scene nodes, mesh recources, cameras and all the other stuff. </p>
<p>All Scene nodes can be created only here. There is a always growing list of scene nodes for lots of purposes: Indoor rendering scene nodes, different Camera scene nodes (<a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a6d8f9930cfbd4469ebfd798ba1e65db8" title="Adds a camera scene node to the scene graph and sets it as active camera. ">addCameraSceneNode()</a>, <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#adc6cafb1f284dea325e9511917cb1f14" title="Adds a maya style user controlled camera scene node to the scene graph. ">addCameraSceneNodeMaya()</a>), scene nodes for Light (<a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ac832789009b7670a90eb0e3250397a83" title="Adds a dynamic light scene node to the scene graph. ">addLightSceneNode()</a>), Billboards (<a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a580bb5e0db1043e9c57874b87a7d3b8a" title="Adds a billboard scene node to the scene graph. ">addBillboardSceneNode()</a>) and so on. A scene node is a node in the hierachical scene graph. Every scene node may have children, which are other scene nodes. Children move relative the their parents position. If the parent of a node is not visible, its children won't be visible, too. In this way, it is for example easily possible to attach a light to a moving car or to place a walking character on a moving platform on a moving ship. The SceneManager is also able to load 3d mesh files of different formats. Take a look at <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aca1b12117220849983243ee2f73a8f4d" title="Get pointer to an animateable mesh. Loads the file if not loaded already. ">getMesh()</a> to find out what formats are supported. If these formats are not enough, use <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a808972cc001db86c0576c38b3b3fbbf7" title="Adds an external mesh loader for extending the engine with new file formats. ">addExternalMeshLoader()</a> to add new formats to the engine. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a580bb5e0db1043e9c57874b87a7d3b8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IBillboardSceneNode.html">IBillboardSceneNode</a>* irr::scene::ISceneManager::addBillboardSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em> = <code><a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt;&#160;<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;&gt;(10.0f,&#160;10.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>colorTop</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>colorBottom</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a billboard scene node to the scene graph. </p>
<p>A billboard is like a 3d sprite: A 2d element, which always looks to the camera. It is usually used for things like explosions, fire, lensflares and things like that. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent scene node of the billboard. Can be null. If the parent moves, the billboard will move too. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the billboard. This size is 2 dimensional because a billboard only has width and height. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the billboard will be placed. </td></tr>
    <tr><td class="paramname">id</td><td>An id of the node. This id can be used to identify the node. </td></tr>
    <tr><td class="paramname">colorTop</td><td>The color of the vertices at the top of the billboard (default: white). </td></tr>
    <tr><td class="paramname">colorBottom</td><td>The color of the vertices at the bottom of the billboard (default: white). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the billboard if successful, otherwise NULL. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d8f9930cfbd4469ebfd798ba1e65db8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a>* irr::scene::ISceneManager::addCameraSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>lookat</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;100)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeActive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a camera scene node to the scene graph and sets it as active camera. </p>
<p>This camera does not react on user input like for example the one created with <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a0ad89f90e140ec8f26ec54c9b8f3d81c" title="Adds a camera scene node with an animator which provides mouse and keyboard control appropriate for f...">addCameraSceneNodeFPS()</a>. If you want to move or animate it, use animators or the ISceneNode::setPosition(), <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a7280b07fd7915c64350db5a132b4ba07" title="Sets the look at target of the camera. ">ICameraSceneNode::setTarget()</a> etc methods. By default, a camera's look at position (set with setTarget()) and its scene node rotation (set with setRotation()) are independent. If you want to be able to control the direction that the camera looks by using setRotation() then call ICameraSceneNode::bindTargetAndRotation(true) on it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the camera will be placed. </td></tr>
    <tr><td class="paramname">lookat</td><td>Position where the camera will look at. Also known as target. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent scene node of the camera. Can be null. If the parent moves, the camera will move too. </td></tr>
    <tr><td class="paramname">id</td><td>id of the camera. This id can be used to identify the camera. </td></tr>
    <tr><td class="paramname">makeActive</td><td>Flag whether this camera should become the active one. Make sure you always have one active camera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to interface to camera if successful, otherwise 0. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ad89f90e140ec8f26ec54c9b8f3d81c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a>* irr::scene::ISceneManager::addCameraSceneNodeFPS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>rotateSpeed</em> = <code>100.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>moveSpeed</em> = <code>0.5f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structirr_1_1SKeyMap.html">SKeyMap</a> *&#160;</td>
          <td class="paramname"><em>keyMapArray</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>keyMapSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noVerticalMovement</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>jumpSpeed</em> = <code>0.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertMouse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeActive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a camera scene node with an animator which provides mouse and keyboard control appropriate for first person shooters (FPS). </p>
<p>This FPS camera is intended to provide a demonstration of a camera that behaves like a typical First Person Shooter. It is useful for simple demos and prototyping but is not intended to provide a full solution for a production quality game. It binds the camera scene node rotation to the look-at target; </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#ad8785d7b2f730933a8d4425ac54e7205" title="Binds the camera scene node&#39;s rotation to its target position and vice vera, or unbinds them...">ICameraSceneNode::bindTargetAndRotation()</a>. With this camera, you look with the mouse, and move with cursor keys. If you want to change the key layout, you can specify your own keymap. For example to make the camera be controlled by the cursor keys AND the keys W,A,S, and D, do something like this: <div class="fragment"><div class="line"> SKeyMap keyMap[8];</div><div class="line"> keyMap[0].Action = EKA_MOVE_FORWARD;</div><div class="line"> keyMap[0].KeyCode = KEY_UP;</div><div class="line"> keyMap[1].Action = EKA_MOVE_FORWARD;</div><div class="line"> keyMap[1].KeyCode = KEY_KEY_W;</div><div class="line"></div><div class="line"> keyMap[2].Action = EKA_MOVE_BACKWARD;</div><div class="line"> keyMap[2].KeyCode = KEY_DOWN;</div><div class="line"> keyMap[3].Action = EKA_MOVE_BACKWARD;</div><div class="line"> keyMap[3].KeyCode = KEY_KEY_S;</div><div class="line"></div><div class="line"> keyMap[4].Action = EKA_STRAFE_LEFT;</div><div class="line"> keyMap[4].KeyCode = KEY_LEFT;</div><div class="line"> keyMap[5].Action = EKA_STRAFE_LEFT;</div><div class="line"> keyMap[5].KeyCode = KEY_KEY_A;</div><div class="line"></div><div class="line"> keyMap[6].Action = EKA_STRAFE_RIGHT;</div><div class="line"> keyMap[6].KeyCode = KEY_RIGHT;</div><div class="line"> keyMap[7].Action = EKA_STRAFE_RIGHT;</div><div class="line"> keyMap[7].KeyCode = KEY_KEY_D;</div><div class="line"></div><div class="line">camera = sceneManager-&gt;addCameraSceneNodeFPS(0, 100, 500, -1, keyMap, 8);</div></div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent scene node of the camera. Can be null. </td></tr>
    <tr><td class="paramname">rotateSpeed</td><td>Speed in degress with which the camera is rotated. This can be done only with the mouse. </td></tr>
    <tr><td class="paramname">moveSpeed</td><td>Speed in units per millisecond with which the camera is moved. Movement is done with the cursor keys. </td></tr>
    <tr><td class="paramname">id</td><td>id of the camera. This id can be used to identify the camera. </td></tr>
    <tr><td class="paramname">keyMapArray</td><td>Optional pointer to an array of a keymap, specifying what keys should be used to move the camera. If this is null, the default keymap is used. You can define actions more then one time in the array, to bind multiple keys to the same action. </td></tr>
    <tr><td class="paramname">keyMapSize</td><td>Amount of items in the keymap array. </td></tr>
    <tr><td class="paramname">noVerticalMovement</td><td>Setting this to true makes the camera only move within a horizontal plane, and disables vertical movement as known from most ego shooters. Default is 'false', with which it is possible to fly around in space, if no gravity is there. </td></tr>
    <tr><td class="paramname">jumpSpeed</td><td>Speed with which the camera is moved when jumping. </td></tr>
    <tr><td class="paramname">invertMouse</td><td>Setting this to true makes the camera look up when the mouse is moved down and down when the mouse is moved up, the default is 'false' which means it will follow the movement of the mouse cursor. </td></tr>
    <tr><td class="paramname">makeActive</td><td>Flag whether this camera should become the active one. Make sure you always have one active camera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="adc6cafb1f284dea325e9511917cb1f14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a>* irr::scene::ISceneManager::addCameraSceneNodeMaya </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>rotateSpeed</em> = <code>-1500.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>zoomSpeed</em> = <code>200.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>translationSpeed</em> = <code>1500.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>distance</em> = <code>70.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeActive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a maya style user controlled camera scene node to the scene graph. </p>
<p>This is a standard camera with an animator that provides mouse control similar to camera in the 3D Software Maya by Alias Wavefront. The camera does not react on setPosition anymore after applying this animator. Instead use setTarget, to fix the target the camera the camera hovers around. And setDistance to set the current distance from that target, i.e. the radius of the orbit the camera hovers on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent scene node of the camera. Can be null. </td></tr>
    <tr><td class="paramname">rotateSpeed</td><td>Rotation speed of the camera. </td></tr>
    <tr><td class="paramname">zoomSpeed</td><td>Zoom speed of the camera. </td></tr>
    <tr><td class="paramname">translationSpeed</td><td>TranslationSpeed of the camera. </td></tr>
    <tr><td class="paramname">id</td><td>id of the camera. This id can be used to identify the camera. </td></tr>
    <tr><td class="paramname">distance</td><td>Initial distance of the camera from the object </td></tr>
    <tr><td class="paramname">makeActive</td><td>Flag whether this camera should become the active one. Make sure you always have one active camera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the interface of the camera if successful, otherwise 0. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="afd4dcb2db5e5e03088ecf8be1b18224b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshSceneNode.html">IMeshSceneNode</a>* irr::scene::ISceneManager::addCubeSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>size</em> = <code>10.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f,&#160;1.0f,&#160;1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a cube scene node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the cube, uniformly in each dimension. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent of the scene node. Can be 0 if no parent. </td></tr>
    <tr><td class="paramname">id</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td class="paramname">rotation</td><td>Initital rotation of the scene node. </td></tr>
    <tr><td class="paramname">scale</td><td>Initial scale of the scene node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created test scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="ae411fd946f586aaed158364640cef58c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a>* irr::scene::ISceneManager::addDummyTransformationSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a dummy transformation scene node to the scene graph. </p>
<p>This scene node does not render itself, and does not respond to set/getPosition, set/getRotation and set/getScale. Its just a simple scene node that takes a matrix as relative transformation, making it possible to insert any transformation anywhere into the scene graph. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the created scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="aebb834a110b49b0306c9220dee900b66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::addEmptySceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an empty scene node to the scene graph. </p>
<p>Can be used for doing advanced transformations or structuring the scene graph. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the created scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a808972cc001db86c0576c38b3b3fbbf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::addExternalMeshLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IMeshLoader.html">IMeshLoader</a> *&#160;</td>
          <td class="paramname"><em>externalLoader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an external mesh loader for extending the engine with new file formats. </p>
<p>If you want the engine to be extended with file formats it currently is not able to load (e.g. .cob), just implement the <a class="el" href="classirr_1_1scene_1_1IMeshLoader.html" title="Class which is able to load an animated mesh from a file. ">IMeshLoader</a> interface in your loading class and add it with this method. Using this method it is also possible to override built-in mesh loaders with newer or updated versions without the need to recompile the engine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">externalLoader</td><td>Implementation of a new mesh loader. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac832789009b7670a90eb0e3250397a83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ILightSceneNode.html">ILightSceneNode</a>* irr::scene::ISceneManager::addLightSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColorf.html">video::SColorf</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classirr_1_1video_1_1SColorf.html">video::SColorf</a>(1.0f,&#160;1.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>100.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a dynamic light scene node to the scene graph. </p>
<p>The light will cast dynamic light on all other scene nodes in the scene, which have the material flag video::MTF_LIGHTING turned on. (This is the default setting in most scene nodes). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent scene node of the light. Can be null. If the parent moves, the light will move too. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the light will be placed. </td></tr>
    <tr><td class="paramname">color</td><td>Diffuse color of the light. Ambient or Specular colors can be set manually with the <a class="el" href="classirr_1_1scene_1_1ILightSceneNode.html#a20147e049be1a4790346fd72b150b30c" title="Gets the light data associated with this ILightSceneNode. ">ILightSceneNode::getLightData()</a> method. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the light. </td></tr>
    <tr><td class="paramname">id</td><td>id of the node. This id can be used to identify the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the interface of the light if successful, otherwise NULL. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a38b254e43611c84a73c1302ced3816a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshSceneNode.html">IMeshSceneNode</a>* irr::scene::ISceneManager::addMeshSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IMesh.html">IGPUMesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f,&#160;1.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alsoAddIfMeshPointerZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scene node for rendering a static mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Pointer to the loaded static mesh to be displayed. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent of the scene node. Can be NULL if no parent. </td></tr>
    <tr><td class="paramname">id</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td class="paramname">rotation</td><td>Initital rotation of the scene node. </td></tr>
    <tr><td class="paramname">scale</td><td>Initial scale of the scene node. </td></tr>
    <tr><td class="paramname">alsoAddIfMeshPointerZero</td><td>Add the scene node even if a 0 pointer is passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a3616e641e586b400a923b967ff32ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::addSceneNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sceneNodeTypeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scene node to the scene by name. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the scene node added by a factory This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="acd697396eaef0d1d22e7bb32abbf7d55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::addSkyBoxSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>back</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a skybox scene node to the scene graph. </p>
<p>A skybox is a big cube with 6 textures on it and is drawn around the camera position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top</td><td>Texture for the top plane of the box. </td></tr>
    <tr><td class="paramname">bottom</td><td>Texture for the bottom plane of the box. </td></tr>
    <tr><td class="paramname">left</td><td>Texture for the left plane of the box. </td></tr>
    <tr><td class="paramname">right</td><td>Texture for the right plane of the box. </td></tr>
    <tr><td class="paramname">front</td><td>Texture for the front plane of the box. </td></tr>
    <tr><td class="paramname">back</td><td>Texture for the back plane of the box. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent scene node of the skybox. A skybox usually has no parent, so this should be null. Note: If a parent is set to the skybox, the box will not change how it is drawn. </td></tr>
    <tr><td class="paramname">id</td><td>An id of the node. This id can be used to identify the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the sky box if successful, otherwise NULL. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a30ea6d8b624064781a6ffd6a1841b525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::addSkyDomeSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>horiRes</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>vertRes</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>texturePercentage</em> = <code>0.9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>spherePercentage</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1000.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a skydome scene node to the scene graph. </p>
<p>A skydome is a large (half-) sphere with a panoramic texture on the inside and is drawn around the camera position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Texture for the dome. </td></tr>
    <tr><td class="paramname">horiRes</td><td>Number of vertices of a horizontal layer of the sphere. </td></tr>
    <tr><td class="paramname">vertRes</td><td>Number of vertices of a vertical layer of the sphere. </td></tr>
    <tr><td class="paramname">texturePercentage</td><td>How much of the height of the texture is used. Should be between 0 and 1. </td></tr>
    <tr><td class="paramname">spherePercentage</td><td>How much of the sphere is drawn. Value should be between 0 and 2, where 1 is an exact half-sphere and 2 is a full sphere. </td></tr>
    <tr><td class="paramname">radius</td><td>The Radius of the sphere </td></tr>
    <tr><td class="paramname">parent</td><td>Parent scene node of the dome. A dome usually has no parent, so this should be null. Note: If a parent is set, the dome will not change how it is drawn. </td></tr>
    <tr><td class="paramname">id</td><td>An id of the node. This id can be used to identify the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the sky dome if successful, otherwise NULL. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a12969449cd9a4365657702a69315d1db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshSceneNode.html">IMeshSceneNode</a>* irr::scene::ISceneManager::addSphereSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>5.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>polyCount</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f,&#160;1.0f,&#160;1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a sphere scene node of the given radius and detail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>Radius of the sphere. </td></tr>
    <tr><td class="paramname">polyCount</td><td>The number of vertices in horizontal and vertical direction. The total polyCount of the sphere is polyCount*polyCount. This parameter must be less than 256 to stay within the 16-bit limit of the indices of a meshbuffer. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent of the scene node. Can be 0 if no parent. </td></tr>
    <tr><td class="paramname">id</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td class="paramname">rotation</td><td>Initital rotation of the scene node. </td></tr>
    <tr><td class="paramname">scale</td><td>Initial scale of the scene node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created test scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c29710a7802881200a26384313bd14c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::addToDeletionQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scene node to the deletion queue. </p>
<p>The scene node is immediatly deleted when it's secure. Which means when the scene node does not execute animators and things like that. This method is for example used for deleting scene nodes by their scene node animators. In most other cases, a <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html#a672cb748079172ee204bb389e1bde04d" title="Removes this scene node from the scene. ">ISceneNode::remove()</a> call is enough, using this deletion queue is not necessary. See <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a163cc04ff2cb03852ac891de56200fa3" title="Creates a scene node animator, which deletes the scene node after some time automatically. ">ISceneManager::createDeleteAnimator()</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to detete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abaa3d11a833b89f7579848e234881988"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the whole scene. </p>
<p>All scene nodes are removed. </p>

</div>
</div>
<a class="anchor" id="a163cc04ff2cb03852ac891de56200fa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a>* irr::scene::ISceneManager::createDeleteAnimator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>timeMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a scene node animator, which deletes the scene node after some time automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeMs</td><td>Time in milliseconds, after when the node will be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The animator. Attach it to a scene node with <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html#ace62fd3a3a33bccfbed6fa958786bf9b" title="Adds an animator which should animate this node. ">ISceneNode::addAnimator()</a> and the animator will animate it. If you no longer need the animator, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">ISceneNodeAnimator::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e49ff49bc9e88e8ecf3d681354e1ab6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a>* irr::scene::ISceneManager::createFlyCircleAnimator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0.f,&#160;0.f,&#160;0.f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>100.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>speed</em> = <code>0.001f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0.f,&#160;1.f,&#160;0.f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>startPosition</em> = <code>0.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>radiusEllipsoid</em> = <code>0.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fly circle animator, which lets the attached scene node fly around a center. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>Center of the circle. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the circle. </td></tr>
    <tr><td class="paramname">speed</td><td>The orbital speed, in radians per millisecond. </td></tr>
    <tr><td class="paramname">direction</td><td>Specifies the upvector used for alignment of the mesh. </td></tr>
    <tr><td class="paramname">startPosition</td><td>The position on the circle where the animator will begin. Value is in multiples of a circle, i.e. 0.5 is half way around. (phase) </td></tr>
    <tr><td class="paramname">radiusEllipsoid</td><td>if radiusEllipsoid != 0 then radius2 froms a ellipsoid begin. Value is in multiples of a circle, i.e. 0.5 is half way around. (phase) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The animator. Attach it to a scene node with <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html#ace62fd3a3a33bccfbed6fa958786bf9b" title="Adds an animator which should animate this node. ">ISceneNode::addAnimator()</a> and the animator will animate it. If you no longer need the animator, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">ISceneNodeAnimator::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a865c2da86486dcdb44847d5baa7aaa61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a>* irr::scene::ISceneManager::createFlyStraightAnimator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>startPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>endPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>timeForWay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pingpong</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fly straight animator, which lets the attached scene node fly or move along a line between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startPoint</td><td>Start point of the line. </td></tr>
    <tr><td class="paramname">endPoint</td><td>End point of the line. </td></tr>
    <tr><td class="paramname">timeForWay</td><td>Time in milli seconds how long the node should need to move from the start point to the end point. </td></tr>
    <tr><td class="paramname">loop</td><td>If set to false, the node stops when the end point is reached. If loop is true, the node begins again at the start. </td></tr>
    <tr><td class="paramname">pingpong</td><td>Flag to set whether the animator should fly back from end to start again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The animator. Attach it to a scene node with <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html#ace62fd3a3a33bccfbed6fa958786bf9b" title="Adds an animator which should animate this node. ">ISceneNode::addAnimator()</a> and the animator will animate it. If you no longer need the animator, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">ISceneNodeAnimator::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0c9d4ab88bbe2ad71623b1054a0c3ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a>* irr::scene::ISceneManager::createFollowSplineAnimator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>speed</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;</td>
          <td class="paramname"><em>tightness</em> = <code>0.5f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loop</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pingpong</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a follow spline animator. </p>
<p>The animator modifies the position of the attached scene node to make it follow a hermite spline. It uses a subset of hermite splines: either cardinal splines (tightness != 0.5) or catmull-rom-splines (tightness == 0.5). The animator moves from one control point to the next in 1/speed seconds. This code was sent in by Matthias Gall. If you no longer need the animator, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">ISceneNodeAnimator::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </p>

</div>
</div>
<a class="anchor" id="ae9a06fb68757381f99cfe11ecbd153e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshWriter.html">IMeshWriter</a>* irr::scene::ISceneManager::createMeshWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a431fa15741518ba15f6d5f2608b6cb4e">EMESH_WRITER_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a mesh writer implementation if available. </p>
<p>Note: You need to <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">drop()</a> the pointer after use again, see <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for details. </p>

</div>
</div>
<a class="anchor" id="a94805dd4eca41ccef9607aefe669aed9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a>* irr::scene::ISceneManager::createNewSceneManager </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneContent</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new scene manager. </p>
<p>This can be used to easily draw and/or store two independent scenes at the same time. The mesh cache will be shared between all existing scene managers, which means if you load a mesh in the original scene manager using for example <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aca1b12117220849983243ee2f73a8f4d" title="Get pointer to an animateable mesh. Loads the file if not loaded already. ">getMesh()</a>, the mesh will be available in all other scene managers too, without loading. The original/main scene manager will still be there and accessible via <a class="el" href="classirr_1_1IrrlichtDevice.html#a891b503ff4d5041296d88f23f97d7b3d" title="Provides access to the scene manager. ">IrrlichtDevice::getSceneManager()</a>. If you need input event in this new scene manager, for example for FPS cameras, you'll need to forward input to this manually: Just implement an <a class="el" href="classirr_1_1IEventReceiver.html" title="Interface of an object which can receive events. ">IEventReceiver</a> and call yourNewSceneManager-&gt;<a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ac68aa8d654884f19ad52fa28f11db424" title="Posts an input event to the environment. ">postEventFromUser()</a>, and return true so that the original scene manager doesn't get the event. Otherwise, all input will go to the main scene manager automatically. If you no longer need the new scene manager, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">ISceneManager::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </p>

</div>
</div>
<a class="anchor" id="a29efe9505de4e5dc2218283ef0c2a64d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a>* irr::scene::ISceneManager::createRotationAnimator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>rotationSpeed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rotation animator, which rotates the attached scene node around itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotationSpeed</td><td>Specifies the speed of the animation in degree per 10 milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The animator. Attach it to a scene node with <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html#ace62fd3a3a33bccfbed6fa958786bf9b" title="Adds an animator which should animate this node. ">ISceneNode::addAnimator()</a> and the animator will animate it. If you no longer need the animator, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">ISceneNodeAnimator::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="ac63c38a05b8e7d0a11ddb1752da36835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a>* irr::scene::ISceneManager::createSceneNodeAnimator </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>target</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a scene node animator based on its type name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeName</td><td>Type of the scene node animator to add. </td></tr>
    <tr><td class="paramname">target</td><td>Target scene node of the new animator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns pointer to the new scene node animator or null if not successful. You need to drop this pointer after calling this, see <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for details. </dd></dl>

</div>
</div>
<a class="anchor" id="ae212e01dffc4891d32e3d1735d22d04a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimator.html">ISceneNodeAnimator</a>* irr::scene::ISceneManager::createTextureAnimator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1video_1_1ITexture.html">video::ITexture</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>textures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>timePerFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loop</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a texture animator, which switches the textures of the target scene node based on a list of textures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textures</td><td>List of textures to use. </td></tr>
    <tr><td class="paramname">timePerFrame</td><td>Time in milliseconds, how long any texture in the list should be visible. </td></tr>
    <tr><td class="paramname">loop</td><td>If set to to false, the last texture remains set, and the animation stops. If set to true, the animation restarts with the first texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The animator. Attach it to a scene node with <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html#ace62fd3a3a33bccfbed6fa958786bf9b" title="Adds an animator which should animate this node. ">ISceneNode::addAnimator()</a> and the animator will animate it. If you no longer need the animator, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">ISceneNodeAnimator::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a04240262904667c821bd9de5e5fd9b02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::drawAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws all the scene nodes. </p>
<p>This can only be invoked between IVideoDriver::beginScene() and IVideoDriver::endScene(). Please note that the scene is not only drawn when calling this, but also animated by existing scene node animators, culling of scene nodes is done, etc. </p>

</div>
</div>
<a class="anchor" id="a78585330c2c7ffae133abefd55f495b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a>* irr::scene::ISceneManager::getActiveCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current active camera. </p>
<dl class="section return"><dt>Returns</dt><dd>The active camera is returned. Note that this can be NULL, if there was no camera created yet. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="adeb3d24c8ffafd5e671f344931a0b3a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorFactory.html">ISceneNodeAnimatorFactory</a>* irr::scene::ISceneManager::getDefaultSceneNodeAnimatorFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default scene node animator factory which can create all built-in scene node animators. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the default scene node animator factory This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ea0ec7ec95a97819f1de5222b97e774"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeFactory.html">ISceneNodeFactory</a>* irr::scene::ISceneManager::getDefaultSceneNodeFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default scene node factory which can create all built in scene nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the default scene node factory This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="adbd98fbeba199005cf795a5bae7ccbaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1io_1_1IFileSystem.html">io::IFileSystem</a>* irr::scene::ISceneManager::getFileSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the active FileSystem. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the FileSystem This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="aa907bfdd82887a9855157fdfb41985e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classirr_1_1scene_1_1IGeometryCreator.html">IGeometryCreator</a>* irr::scene::ISceneManager::getGeometryCreator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an instance of a geometry creator. </p>
<p>The geometry creator provides some helper methods to create various types of basic geometry. This can be useful for custom scene nodes. </p>

</div>
</div>
<a class="anchor" id="aca1b12117220849983243ee2f73a8f4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMesh.html">ICPUMesh</a>* irr::scene::ISceneManager::getMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1io.html#ab1bdc45edb3f94d8319c02bc0f840ee1">io::path</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to an animateable mesh. Loads the file if not loaded already. </p>
<p>If you want to remove a loaded mesh from the cache again, use removeMesh(). Currently there are the following mesh formats supported: </p><table  border="1" cellpadding="2" cellspacing="0">
<tr>
<td>Format </td><td>Description  </td></tr>
<tr>
<td>3D Studio (.3ds) </td><td>Loader for 3D-Studio files which lots of 3D packages are able to export. Only static meshes are currently supported by this importer.  </td></tr>
<tr>
<td>3D World Studio (.smf) </td><td>Loader for Leadwerks SMF mesh files, a simple mesh format containing static geometry for games. The proprietary .STF texture format is not supported yet. This loader was originally written by Joseph Ellis.   </td></tr>
<tr>
<td>Bliz Basic B3D (.b3d) </td><td>Loader for blitz basic files, developed by Mark Sibly. This is the ideal animated mesh format for game characters as it is both rigidly defined and widely supported by modeling and animation software. As this format supports skeletal animations, an ISkinnedMesh will be returned by this importer.  </td></tr>
<tr>
<td>Cartography shop 4 (.csm) </td><td>Cartography Shop is a modeling program for creating architecture and calculating lighting. Irrlicht can directly import .csm files thanks to the IrrCSM library created by Saurav Mohapatra which is now integrated directly in Irrlicht. If you are using this loader, please note that you'll have to set the path of the textures before loading .csm files. You can do this using SceneManager-&gt;getParameters()-&gt;setAttribute(<a class="el" href="namespaceirr_1_1scene.html#aecf002b9e14bd101b455632e1c260a8d" title="Name of the parameter for changing the texture path of the built-in csm loader. ">scene::CSM_TEXTURE_PATH</a>, &quot;path/to/your/textures&quot;);  </td></tr>
<tr>
<td>COLLADA (.dae, .xml) </td><td><p class="starttd">COLLADA is an open Digital Asset Exchange Schema for the interactive 3D industry. There are exporters and importers for this format available for most of the big 3d packagesat <a href="http://collada.org">http://collada.org</a>. Irrlicht can import COLLADA files by using the <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aca1b12117220849983243ee2f73a8f4d" title="Get pointer to an animateable mesh. Loads the file if not loaded already. ">ISceneManager::getMesh()</a> method. COLLADA files need not contain only one single mesh but multiple meshes and a whole scene setup with lights, cameras and mesh instances, this loader can set up a scene as described by the COLLADA file instead of loading and returning one single mesh. By default, this loader behaves like the other loaders and does not create instances, but it can be switched into this mode by using SceneManager-&gt;getParameters()-&gt;setAttribute(COLLADA_CREATE_SCENE_INSTANCES, true); Created scene nodes will be named as the names of the nodes in the COLLADA file. The returned mesh is just a dummy object in this mode. Meshes included in the scene will be added into the scene manager with the following naming scheme: "path/to/file/file.dea#meshname". The loading of such meshes is logged. Currently, this loader is able to</p>
<pre class="fragment">   create meshes (made of only polygons), lights, and
   cameras. Materials and animations are currently not
   supported but this will change with future releases.
</pre>   </td></tr>
<tr>
<td>Delgine DeleD (.dmf) </td><td>DeleD (delgine.com) is a 3D editor and level-editor combined into one and is specifically designed for 3D game-development. With this loader, it is possible to directly load all geometry is as well as textures and lightmaps from .dmf files. To set texture and material paths, see scene::DMF_USE_MATERIALS_DIRS and <a class="el" href="namespaceirr_1_1scene.html#a2a6e8bd33eaec1815e3e16a59c269fb5" title="Name of the parameter for changing the texture path of the built-in DMF loader. ">scene::DMF_TEXTURE_PATH</a>. It is also possible to flip the alpha texture by setting <a class="el" href="namespaceirr_1_1scene.html#acdc1ddd0bfeb4118a5d8f3ea953717f6" title="Name of the parameter for choose to flip or not tga files. ">scene::DMF_FLIP_ALPHA_TEXTURES</a> to true and to set the material transparent reference value by setting <a class="el" href="namespaceirr_1_1scene.html#afd6e025453e80983de80371dc56718ef" title="Name of the parameter for setting reference value of alpha in transparent materials. ">scene::DMF_ALPHA_CHANNEL_REF</a> to a float between 0 and<ol type="1">
<li>The loader is based on Salvatore Russo's .dmf loader, I just changed some parts of it. Thanks to Salvatore for his work and for allowing me to use his code in Irrlicht and put it under Irrlicht's license. For newer and more enchanced versions of the loader, take a look at delgine.com.   </li>
</ol>
</td></tr>
<tr>
<td>DirectX (.x) </td><td>Platform independent importer (so not D3D-only) for .x files. Most 3D packages can export these natively and there are several tools for them available, e.g. the Maya exporter included in the DX SDK. .x files can include skeletal animations and Irrlicht is able to play and display them, users can manipulate the joints via the ISkinnedMesh interface. Currently, Irrlicht only supports uncompressed .x files.  </td></tr>
<tr>
<td>Half-Life model (.mdl) </td><td>This loader opens Half-life 1 models, it was contributed by Fabio Concas and adapted by Thomas Alten.  </td></tr>
<tr>
<td>LightWave (.lwo) </td><td>Native to NewTek's LightWave 3D, the LWO format is well known and supported by many exporters. This loader will import LWO2 models including lightmaps, bumpmaps and reflection textures.  </td></tr>
<tr>
<td>Maya (.obj) </td><td>Most 3D software can create .obj files which contain static geometry without material data. The material files .mtl are also supported. This importer for Irrlicht can load them directly.   </td></tr>
<tr>
<td>Milkshape (.ms3d) </td><td>.MS3D files contain models and sometimes skeletal animations from the Milkshape 3D modeling and animation software. Like the other skeletal mesh loaders, oints are exposed via the ISkinnedMesh animated mesh type.  </td></tr>
<tr>
<td>My3D (.my3d) </td><td>.my3D is a flexible 3D file format. The My3DTools contains plug-ins to export .my3D files from several 3D packages. With this built-in importer, Irrlicht can read and display those files directly. This loader was written by Zhuck Dimitry who also created the whole My3DTools package. If you are using this loader, please note that you can set the path of the textures before loading .my3d files. You can do this using SceneManager-&gt;getParameters()-&gt;setAttribute(<a class="el" href="namespaceirr_1_1scene.html#a54eb9ea68ba13b4689444f8d34e338b9" title="Name of the parameter for changing the texture path of the built-in my3d loader. ">scene::MY3D_TEXTURE_PATH</a>, &quot;path/to/your/textures&quot;);   </td></tr>
<tr>
<td>OCT (.oct) </td><td>The oct file format contains 3D geometry and lightmaps and can be loaded directly by Irrlicht. OCT files<br />
 can be created by FSRad, Paul Nette's radiosity processor or exported from Blender using OCTTools which can be found in the exporters/OCTTools directory of the SDK. Thanks to Murphy McCauley for creating all this.  </td></tr>
<tr>
<td>OGRE Meshes (.mesh) </td><td>Ogre .mesh files contain 3D data for the OGRE 3D engine. Irrlicht can read and display them directly with this importer. To define materials for the mesh, copy a .material file named like the corresponding .mesh file where the .mesh file is. (For example ogrehead.material for ogrehead.mesh). Thanks to Christian Stehno who wrote and contributed this loader.  </td></tr>
<tr>
<td>Pulsar LMTools (.lmts) </td><td>LMTools is a set of tools (Windows &amp; Linux) for creating lightmaps. Irrlicht can directly read .lmts files thanks to<br />
 the importer created by Jonas Petersen. If you are using this loader, please note that you can set the path of the textures before loading .lmts files. You can do this using SceneManager-&gt;getParameters()-&gt;setAttribute(<a class="el" href="namespaceirr_1_1scene.html#a1d81a2ac8866dfa4a0ff3bdece327f75" title="Name of the parameter for changing the texture path of the built-in lmts loader. ">scene::LMTS_TEXTURE_PATH</a>, &quot;path/to/your/textures&quot;); Notes for<br />
 this version of the loader:<br />
<ul>
<li>It does not recognise/support user data in the *.lmts files.<br />
</li>
<li>The TGAs generated by LMTools don't work in Irrlicht for some reason (the textures are upside down). Opening and resaving them in a graphics app will solve the problem.  </li>
</ul>
</td></tr>
<tr>
<td>Stanford Triangle (.ply) </td><td>Invented by Stanford University and known as the native format of the infamous "Stanford Bunny" model, this is a popular static mesh format used by 3D scanning hardware and software. This loader supports extremely large models in both ASCII and binary format, but only has rudimentary material support in the form of vertex colors and texture coordinates.  </td></tr>
<tr>
<td>Stereolithography (.stl) </td><td>The STL format is used for rapid prototyping and computer-aided manufacturing, thus has no support for materials.  </td></tr>
</table>
<p>To load and display a mesh quickly, just do this: </p><div class="fragment"><div class="line">SceneManager-&gt;addAnimatedMeshSceneNode(</div><div class="line">   SceneManager-&gt;getMesh(<span class="stringliteral">&quot;yourmesh.3ds&quot;</span>));</div></div><!-- fragment --><p> If you would like to implement and add your own file format loader to Irrlicht, see <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a808972cc001db86c0576c38b3b3fbbf7" title="Adds an external mesh loader for extending the engine with new file formats. ">addExternalMeshLoader()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Filename of the mesh to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Null if failed, otherwise pointer to the mesh. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a733c4e8040702ec9fe486ee15a5089a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMesh.html">ICPUMesh</a>* irr::scene::ISceneManager::getMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to an animateable mesh. Loads the file if not loaded already. </p>
<p>Works just as getMesh(const char* filename). If you want to remove a loaded mesh from the cache again, use removeMesh(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>File handle of the mesh to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if failed and pointer to the mesh if successful. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5ffbb676d3c68becfb565cf72e2afa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshCache.html">IMeshCache</a>&lt;<a class="el" href="classirr_1_1scene_1_1IMesh.html">ICPUMesh</a>&gt;* irr::scene::ISceneManager::getMeshCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get interface to the mesh cache which is shared beween all existing scene managers. </p>
<p>With this interface, it is possible to manually add new loaded meshes (if <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aca1b12117220849983243ee2f73a8f4d" title="Get pointer to an animateable mesh. Loads the file if not loaded already. ">ISceneManager::getMesh()</a> is not sufficient), to remove them and to iterate through already loaded meshes. </p>

</div>
</div>
<a class="anchor" id="a9fd2e6e1f82298b9b95e96d2b36ddc33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshLoader.html">IMeshLoader</a>* irr::scene::ISceneManager::getMeshLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the given mesh loader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the loader to retrieve. This parameter is an 0-based array index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified loader, 0 if the index is incorrect. </dd></dl>

</div>
</div>
<a class="anchor" id="a05138d6b5f99fced0061794fb5c42318"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshManipulator.html">IMeshManipulator</a>* irr::scene::ISceneManager::getMeshManipulator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to the mesh manipulator. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the mesh manipulator This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f7075320f1a3bf2838f29c23f78635f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::getRootSceneNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the root scene node. </p>
<p>This is the scene node which is parent of all scene nodes. The root scene node is a special scene node which only exists to manage all scene nodes. It will not be rendered and cannot be removed from the scene. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the root scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a96d8272b74bd0adc9138f17e832dc887"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorFactory.html">ISceneNodeAnimatorFactory</a>* irr::scene::ISceneManager::getSceneNodeAnimatorFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get scene node animator factory by index. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the requested scene node animator factory, or 0 if it does not exist. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="ac912b9effd5ce46f5dc038e0568e614c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNodeFactory.html">ISceneNodeFactory</a>* irr::scene::ISceneManager::getSceneNodeFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a scene node factory by index. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the requested scene node factory, or 0 if it does not exist. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f92b38444d719c4d2314242884e4951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a> irr::scene::ISceneManager::getSceneNodeRenderPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current render pass. </p>
<p>All scene nodes are being rendered in a specific order. First lights, cameras, sky boxes, solid geometry, and then transparent stuff. During the rendering process, scene nodes may want to know what the scene manager is rendering currently, because for example they registered for rendering twice, once for transparent geometry and once for solid. When knowing what rendering pass currently is active they can render the correct part of their geometry. </p>

</div>
</div>
<a class="anchor" id="afde082160205a8faab44cd5b61e3745c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IVideoDriver.html">video::IVideoDriver</a>* irr::scene::ISceneManager::getVideoDriver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the video driver. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the video Driver. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one. ">IReferenceCounted::drop()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a819bea16578056eea049d4bfe0545575"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneManager::isCulled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if node is culled in current view frustum. </p>
<p>Please note that depending on the used culling method this check can be rather coarse, or slow. A positive result is correct, though, i.e. if this method returns true the node is positively not visible. The node might still be invisible even if this method returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The scene node which is checked for culling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if node is not visible in the current scene, else false. </dd></dl>

</div>
</div>
<a class="anchor" id="ac68aa8d654884f19ad52fa28f11db424"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool irr::scene::ISceneManager::postEventFromUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1SEvent.html">SEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Posts an input event to the environment. </p>
<p>Usually you do not have to use this method, it is used by the internal engine. </p>

</div>
</div>
<a class="anchor" id="aaf17bdde6d4e9ef61a76f3b43100ecb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> irr::scene::ISceneManager::registerNodeForRendering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a>&#160;</td>
          <td class="paramname"><em>pass</em> = <code><a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67fa5ceee6e4bc2fab42c663b32018e276e8">ESNRP_AUTOMATIC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a node for rendering it at a specific time. </p>
<p>This method should only be used by SceneNodes when they get a <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac9795bfcb88dcaf8cba6ea3296e5d8d0" title="This method is called just before the rendering process of the whole scene. ">ISceneNode::OnRegisterSceneNode()</a> call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to register for drawing. Usually scene nodes would set 'this' as parameter here because they want to be drawn. </td></tr>
    <tr><td class="paramname">pass</td><td>Specifies when the node wants to be drawn in relation to the other nodes. For example, if the node is a shadow, it usually wants to be drawn after all other nodes and will use ESNRP_SHADOW for this. See <a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f" title="Enumeration for render passes. ">scene::E_SCENE_NODE_RENDER_PASS</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scene will be rendered ( passed culling ) </dd></dl>

</div>
</div>
<a class="anchor" id="af48c93cc41f986f08ed964cc575ee7a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::registerSceneNodeAnimatorFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNodeAnimatorFactory.html">ISceneNodeAnimatorFactory</a> *&#160;</td>
          <td class="paramname"><em>factoryToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scene node animator factory to the scene manager. </p>
<p>Use this to extend the scene manager with new scene node animator types which it should be able to create automaticly, for example when loading data from xml files. </p>

</div>
</div>
<a class="anchor" id="a75ac9315def74ae5e26a2d6a2f5a38e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::registerSceneNodeFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNodeFactory.html">ISceneNodeFactory</a> *&#160;</td>
          <td class="paramname"><em>factoryToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scene node factory to the scene manager. </p>
<p>Use this to extend the scene manager with new scene node types which it should be able to create automaticly, for example when loading data from xml files. </p>

</div>
</div>
<a class="anchor" id="a5d19b7a6803a0a021082fc2b86043b3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::setActiveCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the currently active camera. </p>
<p>The previous active camera will be deactivated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera</td><td>The new camera which should be active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0065307bf3ff12fdc5b7bb624987a1c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::setLightManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ILightManager.html">ILightManager</a> *&#160;</td>
          <td class="paramname"><em>lightManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a custom callbacks manager which gets callbacks during scene rendering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightManager</td><td>the new callbacks manager. You may pass 0 to remove the current callbacks manager and restore the default behavior. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="ISceneManager_8h_source.html">ISceneManager.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
