<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Irrlicht 2.0: irr::core::pseudoarray&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Irrlicht 2.0
   </div>
   <div id="projectbrief">FastOpenSource3DEnginebasedonOpenGL4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceirr.html">irr</a></li><li class="navelem"><a class="el" href="namespaceirr_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classirr_1_1core_1_1pseudoarray.html">pseudoarray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classirr_1_1core_1_1pseudoarray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">irr::core::pseudoarray&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c1e832bac5efcf695e7fb140c167062"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c1e832bac5efcf695e7fb140c167062"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a1c1e832bac5efcf695e7fb140c167062">pseudoarray</a> (T *mappedRange, const size_t &amp;maxSize, const size_t &amp;currentSize=0)</td></tr>
<tr class="memdesc:a1c1e832bac5efcf695e7fb140c167062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for empty array. <br /></td></tr>
<tr class="separator:a1c1e832bac5efcf695e7fb140c167062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06422a66e1948e9d25a432b9b62d221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af06422a66e1948e9d25a432b9b62d221"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#af06422a66e1948e9d25a432b9b62d221">pseudoarray</a> (const <a class="el" href="classirr_1_1core_1_1pseudoarray.html">pseudoarray</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:af06422a66e1948e9d25a432b9b62d221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:af06422a66e1948e9d25a432b9b62d221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64254a230836a5cf6ebc68917333613e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a64254a230836a5cf6ebc68917333613e">push_back</a> (const T &amp;element)</td></tr>
<tr class="memdesc:a64254a230836a5cf6ebc68917333613e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element at back of array.  <a href="#a64254a230836a5cf6ebc68917333613e">More...</a><br /></td></tr>
<tr class="separator:a64254a230836a5cf6ebc68917333613e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0971acf89d90a44dc0b668ba5a8fda80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a0971acf89d90a44dc0b668ba5a8fda80">push_front</a> (const T &amp;element)</td></tr>
<tr class="memdesc:a0971acf89d90a44dc0b668ba5a8fda80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element at the front of the array.  <a href="#a0971acf89d90a44dc0b668ba5a8fda80">More...</a><br /></td></tr>
<tr class="separator:a0971acf89d90a44dc0b668ba5a8fda80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170e5bbb017e369f2bc35312c36bcd5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a170e5bbb017e369f2bc35312c36bcd5d">insert</a> (const T &amp;element, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index=0)</td></tr>
<tr class="memdesc:a170e5bbb017e369f2bc35312c36bcd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item into array at specified position.  <a href="#a170e5bbb017e369f2bc35312c36bcd5d">More...</a><br /></td></tr>
<tr class="separator:a170e5bbb017e369f2bc35312c36bcd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4c1c83d532b76111e72d499fc10083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#ace4c1c83d532b76111e72d499fc10083">set_used</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> usedNow)</td></tr>
<tr class="memdesc:ace4c1c83d532b76111e72d499fc10083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the array and allocates new elements if necessary.  <a href="#ace4c1c83d532b76111e72d499fc10083">More...</a><br /></td></tr>
<tr class="separator:ace4c1c83d532b76111e72d499fc10083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88ccc4ac554cf2e15f50a2b6ce342e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad88ccc4ac554cf2e15f50a2b6ce342e3"></a>
const <a class="el" href="classirr_1_1core_1_1pseudoarray.html">pseudoarray</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#ad88ccc4ac554cf2e15f50a2b6ce342e3">operator=</a> (const <a class="el" href="classirr_1_1core_1_1pseudoarray.html">pseudoarray</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ad88ccc4ac554cf2e15f50a2b6ce342e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:ad88ccc4ac554cf2e15f50a2b6ce342e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd345edb852a782d19905c6d016551db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd345edb852a782d19905c6d016551db"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#acd345edb852a782d19905c6d016551db">operator[]</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index)</td></tr>
<tr class="memdesc:acd345edb852a782d19905c6d016551db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access operator. <br /></td></tr>
<tr class="separator:acd345edb852a782d19905c6d016551db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b31efb6c9beda9d7ea610b1587bbb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2b31efb6c9beda9d7ea610b1587bbb9"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#af2b31efb6c9beda9d7ea610b1587bbb9">operator[]</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index) const </td></tr>
<tr class="memdesc:af2b31efb6c9beda9d7ea610b1587bbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct const access operator. <br /></td></tr>
<tr class="separator:af2b31efb6c9beda9d7ea610b1587bbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcc83d4d8f7db9d129a3539be4b8ccf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbcc83d4d8f7db9d129a3539be4b8ccf"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#acbcc83d4d8f7db9d129a3539be4b8ccf">getLast</a> ()</td></tr>
<tr class="memdesc:acbcc83d4d8f7db9d129a3539be4b8ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets last element. <br /></td></tr>
<tr class="separator:acbcc83d4d8f7db9d129a3539be4b8ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b2faadd7b74e8d4d3bb74ee47ec005"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3b2faadd7b74e8d4d3bb74ee47ec005"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#aa3b2faadd7b74e8d4d3bb74ee47ec005">getLast</a> () const </td></tr>
<tr class="memdesc:aa3b2faadd7b74e8d4d3bb74ee47ec005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets last element. <br /></td></tr>
<tr class="separator:aa3b2faadd7b74e8d4d3bb74ee47ec005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe861bbf5267706cf4e08e4da448a4ad"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#afe861bbf5267706cf4e08e4da448a4ad">pointer</a> ()</td></tr>
<tr class="memdesc:afe861bbf5267706cf4e08e4da448a4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the array.  <a href="#afe861bbf5267706cf4e08e4da448a4ad">More...</a><br /></td></tr>
<tr class="separator:afe861bbf5267706cf4e08e4da448a4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9d7b336b821a604dd4563ab47225b"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#aafe9d7b336b821a604dd4563ab47225b">const_pointer</a> () const </td></tr>
<tr class="memdesc:aafe9d7b336b821a604dd4563ab47225b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a const pointer to the array.  <a href="#aafe9d7b336b821a604dd4563ab47225b">More...</a><br /></td></tr>
<tr class="separator:aafe9d7b336b821a604dd4563ab47225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28729f59bf9e55e413a38f697014a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#ab28729f59bf9e55e413a38f697014a1c">size</a> () const </td></tr>
<tr class="memdesc:ab28729f59bf9e55e413a38f697014a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of occupied elements of the array.  <a href="#ab28729f59bf9e55e413a38f697014a1c">More...</a><br /></td></tr>
<tr class="separator:ab28729f59bf9e55e413a38f697014a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed6fb7c047af0fc07397976c3cedef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#abeed6fb7c047af0fc07397976c3cedef">allocated_size</a> () const </td></tr>
<tr class="memdesc:abeed6fb7c047af0fc07397976c3cedef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get amount of memory allocated.  <a href="#abeed6fb7c047af0fc07397976c3cedef">More...</a><br /></td></tr>
<tr class="separator:abeed6fb7c047af0fc07397976c3cedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ccbee4785125805d83f3b12bc10336"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#aa5ccbee4785125805d83f3b12bc10336">empty</a> () const </td></tr>
<tr class="memdesc:aa5ccbee4785125805d83f3b12bc10336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if array is empty.  <a href="#aa5ccbee4785125805d83f3b12bc10336">More...</a><br /></td></tr>
<tr class="separator:aa5ccbee4785125805d83f3b12bc10336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e98df807c706fe41de8e3ab3253287e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a7e98df807c706fe41de8e3ab3253287e">sort</a> ()</td></tr>
<tr class="memdesc:a7e98df807c706fe41de8e3ab3253287e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the array using heapsort.  <a href="#a7e98df807c706fe41de8e3ab3253287e">More...</a><br /></td></tr>
<tr class="separator:a7e98df807c706fe41de8e3ab3253287e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae027c281626d25f49f7042dde9d4085f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#ae027c281626d25f49f7042dde9d4085f">binary_search</a> (const T &amp;element)</td></tr>
<tr class="memdesc:ae027c281626d25f49f7042dde9d4085f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search for an element, returns -1 if not found.  <a href="#ae027c281626d25f49f7042dde9d4085f">More...</a><br /></td></tr>
<tr class="separator:ae027c281626d25f49f7042dde9d4085f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9db8ae9f0aa06d9bdfa36addc45102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#abe9db8ae9f0aa06d9bdfa36addc45102">binary_search</a> (const T &amp;element) const </td></tr>
<tr class="memdesc:abe9db8ae9f0aa06d9bdfa36addc45102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search for an element if possible, returns -1 if not found.  <a href="#abe9db8ae9f0aa06d9bdfa36addc45102">More...</a><br /></td></tr>
<tr class="separator:abe9db8ae9f0aa06d9bdfa36addc45102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fa9de8befb5ce24e6e3c86692fdf72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a06fa9de8befb5ce24e6e3c86692fdf72">binary_search</a> (const T &amp;element, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> left, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> right) const </td></tr>
<tr class="memdesc:a06fa9de8befb5ce24e6e3c86692fdf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search for an element, returns -1 if not found.  <a href="#a06fa9de8befb5ce24e6e3c86692fdf72">More...</a><br /></td></tr>
<tr class="separator:a06fa9de8befb5ce24e6e3c86692fdf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0fc3ea4723e044e48b1479513a9014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a5c0fc3ea4723e044e48b1479513a9014">binary_search_multi</a> (const T &amp;element, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &amp;last)</td></tr>
<tr class="separator:a5c0fc3ea4723e044e48b1479513a9014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad731721c59cc25dfaf9619c5acb087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a3ad731721c59cc25dfaf9619c5acb087">linear_search</a> (const T &amp;element) const </td></tr>
<tr class="memdesc:a3ad731721c59cc25dfaf9619c5acb087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element in linear time, which is very slow.  <a href="#a3ad731721c59cc25dfaf9619c5acb087">More...</a><br /></td></tr>
<tr class="separator:a3ad731721c59cc25dfaf9619c5acb087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c85c2d9932d53c0c9efbeae53e1d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a04c85c2d9932d53c0c9efbeae53e1d59">linear_reverse_search</a> (const T &amp;element) const </td></tr>
<tr class="memdesc:a04c85c2d9932d53c0c9efbeae53e1d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element in linear time, which is very slow.  <a href="#a04c85c2d9932d53c0c9efbeae53e1d59">More...</a><br /></td></tr>
<tr class="separator:a04c85c2d9932d53c0c9efbeae53e1d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ba03bacae91dff41b49e18d63022c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a90ba03bacae91dff41b49e18d63022c4">erase</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index)</td></tr>
<tr class="memdesc:a90ba03bacae91dff41b49e18d63022c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an element from the array.  <a href="#a90ba03bacae91dff41b49e18d63022c4">More...</a><br /></td></tr>
<tr class="separator:a90ba03bacae91dff41b49e18d63022c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d70917aca97eba691c8468f78e8ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#a42d70917aca97eba691c8468f78e8ba4">erase</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> count)</td></tr>
<tr class="memdesc:a42d70917aca97eba691c8468f78e8ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases some elements from the array.  <a href="#a42d70917aca97eba691c8468f78e8ba4">More...</a><br /></td></tr>
<tr class="separator:a42d70917aca97eba691c8468f78e8ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c4e02d718fc0749afe54c924cb03f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c4e02d718fc0749afe54c924cb03f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1pseudoarray.html#af8c4e02d718fc0749afe54c924cb03f1">set_sorted</a> (bool _is_sorted)</td></tr>
<tr class="memdesc:af8c4e02d718fc0749afe54c924cb03f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if the array is sorted. <br /></td></tr>
<tr class="separator:af8c4e02d718fc0749afe54c924cb03f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abeed6fb7c047af0fc07397976c3cedef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::allocated_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get amount of memory allocated. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of memory allocated. The amount of bytes allocated would be <a class="el" href="classirr_1_1core_1_1pseudoarray.html#abeed6fb7c047af0fc07397976c3cedef" title="Get amount of memory allocated. ">allocated_size()</a> * sizeof(ElementTypeUsed); </dd></dl>

</div>
</div>
<a class="anchor" id="ae027c281626d25f49f7042dde9d4085f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::binary_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a binary search for an element, returns -1 if not found. </p>
<p>The array will be sorted before the binary search if it is not already sorted. Caution is advised! Be careful not to call this on unsorted const arrays, or the slower method will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="abe9db8ae9f0aa06d9bdfa36addc45102"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::binary_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a binary search for an element if possible, returns -1 if not found. </p>
<p>This method is for const arrays and so cannot call <a class="el" href="classirr_1_1core_1_1pseudoarray.html#a7e98df807c706fe41de8e3ab3253287e" title="Sorts the array using heapsort. ">sort()</a>, if the array is not sorted then linear_search will be used instead. Potentially very slow! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a06fa9de8befb5ce24e6e3c86692fdf72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::binary_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a binary search for an element, returns -1 if not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to search for. </td></tr>
    <tr><td class="paramname">left</td><td>First left index </td></tr>
    <tr><td class="paramname">right</td><td>Last right index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c0fc3ea4723e044e48b1479513a9014"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::binary_search_multi </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a binary search for an element, returns -1 if not found. it is used for searching a multiset The array will be sorted before the binary search if it is not already sorted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to search for. </td></tr>
    <tr><td class="paramname">&amp;last</td><td>return lastIndex of equal elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the first searched element if it was found, otherwise -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="aafe9d7b336b821a604dd4563ab47225b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::const_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a const pointer to the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the array. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5ccbee4785125805d83f3b12bc10336"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if array is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the array is empty false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a90ba03bacae91dff41b49e18d63022c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from the array. </p>
<p>May be slow, because all elements following after the erased element have to be copied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of element to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42d70917aca97eba691c8468f78e8ba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases some elements from the array. </p>
<p>May be slow, because all elements following after the erased element have to be copied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the first element to be erased. </td></tr>
    <tr><td class="paramname">count</td><td>Amount of elements to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a170e5bbb017e369f2bc35312c36bcd5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item into array at specified position. </p>
<p>Please use this only if you know what you are doing (possible performance loss). The preferred method of adding elements should be <a class="el" href="classirr_1_1core_1_1pseudoarray.html#a64254a230836a5cf6ebc68917333613e" title="Adds an element at back of array. ">push_back()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to be inserted </td></tr>
    <tr><td class="paramname">index</td><td>Where position to insert the new element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04c85c2d9932d53c0c9efbeae53e1d59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::linear_reverse_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element in linear time, which is very slow. </p>
<p>Use binary_search for faster finding. Only works if ==operator is implemented. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ad731721c59cc25dfaf9619c5acb087"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::linear_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element in linear time, which is very slow. </p>
<p>Use binary_search for faster finding. Only works if ==operator is implemented. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="afe861bbf5267706cf4e08e4da448a4ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a64254a230836a5cf6ebc68917333613e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element at back of array. </p>
<p>If the array is too small to add this new element it is made bigger. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to add at the back of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0971acf89d90a44dc0b668ba5a8fda80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element at the front of the array. </p>
<p>If the array is to small to add this new element, the array is made bigger. Please note that this is slow, because the whole array needs to be copied for this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to add at the back of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace4c1c83d532b76111e72d499fc10083"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::set_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&#160;</td>
          <td class="paramname"><em>usedNow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the array and allocates new elements if necessary. </p>
<p>Please note: This is only secure when using it with simple types, because no default constructor will be called for the added elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usedNow</td><td>Amount of elements now used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab28729f59bf9e55e413a38f697014a1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of occupied elements of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of elements in the array which are actually occupied. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e98df807c706fe41de8e3ab3253287e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1pseudoarray.html">irr::core::pseudoarray</a>&lt; T &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the array using heapsort. </p>
<p>There is no additional memory waste and the algorithm performs O(n*log n) in worst case. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="irrArray_8h_source.html">irrArray.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
