// Copyright (C) 2002-2012 Nikolaus Gebhardt
// This file is part of the "Irrlicht Engine".
// For conditions of distribution and use, see copyright notice in irrlicht.h

#ifndef __I_MESH_BUFFER_H_INCLUDED__
#define __I_MESH_BUFFER_H_INCLUDED__

#include "ITransformFeedback.h"
#include "SMaterial.h"
#include "aabbox3d.h"
#include "SVertexIndex.h"
#include "EPrimitiveTypes.h"
#include "ICPUBuffer.h"
#include "IGPUBuffer.h"
#include "SMaterial.h"
#include "vectorSIMD.h"
#include "coreutil.h"
#include "CBAWFile.h"
#include "assert.h"

namespace irr
{
namespace scene
{
	//! Available vertex attribute ids
	/** As of 2018 most OpenGL implementations support 16 attributes (some CAD GPUs more) */
    enum E_VERTEX_ATTRIBUTE_ID
    {
        EVAI_ATTR0=0,
        EVAI_ATTR1,
        EVAI_ATTR2,
        EVAI_ATTR3,
        EVAI_ATTR4,
        EVAI_ATTR5,
        EVAI_ATTR6,
        EVAI_ATTR7,
        EVAI_ATTR8,
        EVAI_ATTR9,
        EVAI_ATTR10,
        EVAI_ATTR11,
        EVAI_ATTR12,
        EVAI_ATTR13,
        EVAI_ATTR14,
        EVAI_ATTR15,
        EVAI_COUNT
    };

	//! Available components' sizes enumeration
    enum E_COMPONENTS_PER_ATTRIBUTE
    {
		//! Special ID for reverse XYZW order
        ECPA_REVERSED_OR_BGRA=0,
        ECPA_ONE,
        ECPA_TWO,
        ECPA_THREE,
        ECPA_FOUR,
        ECPA_COUNT
    };

	//! Available components' type
    enum E_COMPONENT_TYPE
    {
        ECT_FLOAT=0,
        ECT_HALF_FLOAT,
        ECT_DOUBLE_IN_FLOAT_OUT,
        ECT_UNSIGNED_INT_10F_11F_11F_REV,
        //INTEGER FORMS
        ECT_NORMALIZED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_BYTE,
        ECT_NORMALIZED_UNSIGNED_BYTE,
        ECT_NORMALIZED_SHORT,
        ECT_NORMALIZED_UNSIGNED_SHORT,
        ECT_NORMALIZED_INT,
        ECT_NORMALIZED_UNSIGNED_INT,
        ECT_INT_2_10_10_10_REV,
        ECT_UNSIGNED_INT_2_10_10_10_REV,
        ECT_BYTE,
        ECT_UNSIGNED_BYTE,
        ECT_SHORT,
        ECT_UNSIGNED_SHORT,
        ECT_INT,
        ECT_UNSIGNED_INT,
        ECT_INTEGER_INT_2_10_10_10_REV,
        ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV,
        ECT_INTEGER_BYTE,
        ECT_INTEGER_UNSIGNED_BYTE,
        ECT_INTEGER_SHORT,
        ECT_INTEGER_UNSIGNED_SHORT,
        ECT_INTEGER_INT,
        ECT_INTEGER_UNSIGNED_INT,
        //special
        ECT_DOUBLE_IN_DOUBLE_OUT, //only accepted by glVertexAttribLPointer
        ECT_COUNT
    };
/**
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.

GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.

GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.

GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
**/
    static size_t vertexAttrSize[ECT_COUNT][ECPA_COUNT] = {
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,8,16,24,32},
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4,0xdeadbeefu}, //ECT_UNSIGNED_INT_10F_11F_11F_REV
        //integers
        //normalized
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_INT_2_10_10_10_REV
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV
        {0xdeadbeefu,1,2,3,4}, //ECT_NORMALIZED_BYTE
        {4,1,2,3,4},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,4,8,12,16},
        //un normalized ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,4,8,12,16},
        //native ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,1,2,3,4},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,2,4,6,8},
        {0xdeadbeefu,4,8,12,16},
        {0xdeadbeefu,4,8,12,16},
        //special
        {0xdeadbeefu,8,16,24,32}
    };

	//! Checks whether given combination of attribute's type and component count is valid
	/** In OpenGL some formats are special like RGB30_A2 or RGB9_E5 which force the number of components and give no flexibility in the number of channels
	@param type Type of an atrribute.
	@param components Component count of an atrribute.
	@returns true if such combination is valid or false otherwise.
	*/
    inline bool validCombination(const E_COMPONENT_TYPE& type, const E_COMPONENTS_PER_ATTRIBUTE& components)
    {
        return vertexAttrSize[type][components]<0xdeadbeefu;
    }

	//! Checks whether given attribute type is a normalized one.
	/** @param type Type of an attribute.
	@returns true if given attribute type is normalized or false otherwise.
	*/
    inline bool isNormalized(const E_COMPONENT_TYPE& type)
    {
        return type>=ECT_NORMALIZED_INT_2_10_10_10_REV&&type<=ECT_NORMALIZED_UNSIGNED_INT;
    }



	template <class T>
	class IMeshDataFormatDesc : public virtual IReferenceCounted
	{
        protected:
			//! Read https://www.khronos.org/opengl/wiki/Vertex_Specification for understanding of attribute IDs, indices, attribute formats etc.
            E_COMPONENTS_PER_ATTRIBUTE compntsPerAttr[EVAI_COUNT];
            E_COMPONENT_TYPE attrType[EVAI_COUNT];
            size_t attrStride[EVAI_COUNT];
            size_t attrOffset[EVAI_COUNT];
            uint32_t attrDivisor[EVAI_COUNT];

            //vertices
            T* mappedAttrBuf[scene::EVAI_COUNT];
            //indices
            T* mappedIndexBuf;

            virtual ~IMeshDataFormatDesc()
            {
                for (size_t i=0; i<EVAI_COUNT; i++)
                {
                    if (mappedAttrBuf[i])
                        mappedAttrBuf[i]->drop();
                }

                if (getIndexBuffer())
                    getIndexBuffer()->drop();
            }
        public:
            //! Default constructor.
            IMeshDataFormatDesc()
            {
                for (size_t i=0; i<EVAI_COUNT; i++)
                {
                    compntsPerAttr[i] = ECPA_FOUR;
                    attrType[i] = ECT_FLOAT;
                    attrStride[i] = 16;
                    attrOffset[i] = 0;
                    attrDivisor[i] = 0;
                    mappedAttrBuf[i] = NULL;
                }
                mappedIndexBuf = NULL;
            }

            inline bool formatCanBeAppended(const IMeshDataFormatDesc<T>* other) const
            {
                bool retVal = true;
                for (size_t i=0; retVal&&i<EVAI_COUNT; i++)
                {
                    if (this->getMappedBuffer(static_cast<E_VERTEX_ATTRIBUTE_ID>(i)))
                    {
                        if (other->getMappedBuffer(static_cast<E_VERTEX_ATTRIBUTE_ID>(i)))
                            retVal = retVal&&compntsPerAttr[i]==other->compntsPerAttr[i]&&attrType[i]==other->attrType[i];
                        else
                            return false;
                    }
                    else
                    {
                        if (other->getMappedBuffer(static_cast<E_VERTEX_ATTRIBUTE_ID>(i)))
                            return false;
                        else
                            retVal = retVal&&compntsPerAttr[i]==other->compntsPerAttr[i]&&attrType[i]==other->attrType[i];
                    }
                }
                return retVal;
            }

            inline void mapIndexBuffer(T* ixbuf)
            {
        /*
        #ifdef _DEBUG
                if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset)) //not that easy to check
                {
                    os::Printer::log("MeshBuffer map index buffer overflow!\n",ELL_ERROR);
                    return;
                }
        #endif // _DEBUG
        */
                if (ixbuf)
                    ixbuf->grab();

                if (mappedIndexBuf)
                    mappedIndexBuf->drop();
                mappedIndexBuf = ixbuf;
            }

            inline const T* getIndexBuffer() const
            {
                return mappedIndexBuf;
            }


            virtual void mapVertexAttrBuffer(T* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0, uint32_t divisor=0) = 0;

            inline const T* getMappedBuffer(const scene::E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return mappedAttrBuf[attrId];
            }


            inline const E_COMPONENT_TYPE& getAttribType(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrType[attrId];
            }

            inline const E_COMPONENTS_PER_ATTRIBUTE& getAttribComponentCount(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return compntsPerAttr[attrId];
            }

            inline void setMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId, const size_t &offset)
            {
                assert(attrId<EVAI_COUNT);

                if (!mappedAttrBuf[attrId])
                    return;

                attrOffset[attrId] = offset;
            }

            inline const size_t& getMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrOffset[attrId];
            }

            inline const size_t& getMappedBufferStride(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrStride[attrId];
            }

            inline const uint32_t& getAttribDivisor(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrDivisor[attrId];
            }

            inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId)
            {
                swapVertexAttrBuffer(attrBuf, attrId, attrOffset[attrId], attrStride[attrId]);
            }

            inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId, const size_t& newOffset)
            {
                swapVertexAttrBuffer(attrBuf, attrId, newOffset, attrStride[attrId]);
            }

            inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId, const size_t& newOffset, const size_t& newStride)
            {
                if (!mappedAttrBuf[attrId] || !attrBuf)
                    return;

                attrBuf->grab();
                mappedAttrBuf[attrId]->drop();

                mappedAttrBuf[attrId] = attrBuf;
                attrOffset[attrId] = newOffset;
                attrStride[attrId] = newStride;
            }
	};


	class ICPUMeshDataFormatDesc : public IMeshDataFormatDesc<core::ICPUBuffer>, core::BlobSerializable
	{
        protected:
	        ~ICPUMeshDataFormatDesc()
	        {
	        }
	    public:
			virtual void* serializeToBlob(void* _stackPtr = NULL, const size_t& _stackSize = 0) const
			{
				return core::CorrespondingBlobTypeFor<IMeshDataFormatDesc<core::ICPUBuffer> >::type::createAndTryOnStack(static_cast<const IMeshDataFormatDesc<core::ICPUBuffer>*>(this), _stackPtr, _stackSize);
			}

            void mapVertexAttrBuffer(core::ICPUBuffer* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0, uint32_t divisor=0)
            {
                assert(attrId<EVAI_COUNT);
        #ifdef _DEBUG
                if (!validCombination(type,components))
                {
                    //os::Printer::log("MeshBuffer mapVertexAttrBuffer INVALID COMBINATION OF COMPONENT TYPE AND COUNT!\n",ELL_ERROR);
                    return;
                }
        #else
                    return;
        #endif // _DEBUG

                if (attrBuf)
                {
                    attrBuf->grab();

                    compntsPerAttr[attrId] = components;
                    attrType[attrId] = type;
                    attrStride[attrId] = stride!=0 ? stride:vertexAttrSize[type][components];
                    attrOffset[attrId] = offset;
                    attrDivisor[attrId] = divisor;
                }
                else
                {
                    compntsPerAttr[attrId] = ECPA_FOUR;
                    attrType[attrId] = ECT_FLOAT;
                    attrStride[attrId] = 16;
                    attrOffset[attrId] = 0;
                    attrDivisor[attrId] = 0;
                }

                if (mappedAttrBuf[attrId])
                    mappedAttrBuf[attrId]->drop();
                mappedAttrBuf[attrId] = attrBuf;
            }
	};

	class IGPUMeshDataFormatDesc : public IMeshDataFormatDesc<video::IGPUBuffer>
	{
	};




	template <class T>
	class IMeshBuffer : public virtual IReferenceCounted
	{
    protected:
	    virtual ~IMeshBuffer()
	    {
            if (leakDebugger)
                leakDebugger->deregisterObj(this);

            if (meshLayout)
                meshLayout->drop();
	    }

        video::SMaterial Material;
        core::aabbox3df boundingBox;
        IMeshDataFormatDesc<T>* meshLayout;
	    //indices
	    video::E_INDEX_TYPE indexType;
	    int32_t baseVertex;
        uint64_t indexCount;
        size_t indexBufOffset;
        //
        size_t instanceCount;
        uint32_t baseInstance;
        //primitives
        scene::E_PRIMITIVE_TYPE primitiveType;

        //debug
        core::LeakDebugger* leakDebugger;
	public:
		//! Constructor.
		/**
		@param layout Pointer to descriptor of mesh data object. Will be grabbed.
		@param dbgr Pointer to leak debugger object.
		*/
	    IMeshBuffer(IMeshDataFormatDesc<T>* layout=NULL, core::LeakDebugger* dbgr=NULL) : leakDebugger(dbgr)
	    {
            if (leakDebugger)
                leakDebugger->registerObj(this);

	        meshLayout = layout;
	        if (meshLayout)
                meshLayout->grab();

            indexType = video::EIT_UNKNOWN;
            baseVertex = 0;
            indexCount = 0;
            indexBufOffset = 0;

	        primitiveType = scene::EPT_TRIANGLES;

            instanceCount = 1;
            baseInstance = 0;
	    }

		//! Access data descriptor objects.
		/** @returns data descriptor object. */
	    inline IMeshDataFormatDesc<T>* getMeshDataAndFormat() {return meshLayout;}
		//! @copydoc getMeshDataAndFormat()
	    inline const IMeshDataFormatDesc<T>* getMeshDataAndFormat() const {return meshLayout;}
		//! Sets data descriptor object.
		/**
		Grabs the new object and drops the old one.
		@param layout new descriptor object.
		*/
	    inline void setMeshDataAndFormat(IMeshDataFormatDesc<T>* layout)
	    {
	        if (layout)
                layout->grab();

	        if (meshLayout)
                meshLayout->drop();
            meshLayout = layout;
	    }

		//! Get type of index data which is stored in this meshbuffer.
		/** \return Index type of this buffer. */
		inline const video::E_INDEX_TYPE& getIndexType() const {return indexType;}
		inline void setIndexType(const video::E_INDEX_TYPE& type) {indexType = type;}

		//! Sets offset in mapped index buffer.
		/** @param byteOffset Offset in bytes. */
		inline void setIndexBufferOffset(const size_t& byteOffset) {indexBufOffset = byteOffset;}
		//! Accesses offset in mapped index buffer.
		/** @returns Offset in bytes. */
		inline const size_t& getIndexBufferOffset() const {return indexBufOffset;}

		//! Get amount of indices in this meshbuffer.
		/** \return Number of indices in this buffer. */
		inline const uint64_t& getIndexCount() const {return indexCount;}
		//! Sets amount of indices.
		/** @returns Whether set amount exceeds mapped buffer's size. Regardless of result the amount is set. */
		inline bool setIndexCount(const uint64_t &newIndexCount)
		{
/*
#ifdef _DEBUG
            if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset))
            {
                os::Printer::log("MeshBuffer map vertex buffer overflow!\n",ELL_ERROR);
                return;
            }
#endif // _DEBUG
*/
            indexCount = newIndexCount;
            if (meshLayout)
            {
                const T* mappedIndexBuf = meshLayout->getIndexBuffer();
                if (mappedIndexBuf)
                {
                    switch (indexType)
                    {
                        case video::EIT_16BIT:
                            return indexCount*2+indexBufOffset<mappedIndexBuf->getSize();
                        case video::EIT_32BIT:
                            return indexCount*4+indexBufOffset<mappedIndexBuf->getSize();
                        default:
                            return false;
                    }
                }
            }

            return true;
		}

		//! Accesses base vertex number.
		/** @returns base vertex number. */
        inline const int32_t& getBaseVertex() const {return baseVertex;}
		//! Sets base vertex.
        inline void setBaseVertex(const int32_t& baseVx)
        {
            baseVertex = baseVx;
        }


		inline const scene::E_PRIMITIVE_TYPE& getPrimitiveType() const {return primitiveType;}
		inline void setPrimitiveType(const scene::E_PRIMITIVE_TYPE& type)
		{
		    primitiveType = type;
		}

		inline const size_t& getInstanceCount() const {return instanceCount;}
		inline void setInstanceCount(const size_t& count)
		{
		    instanceCount = count;
		}

		inline const uint32_t& getBaseInstance() const {return baseInstance;}
		inline void setBaseInstance(const uint32_t& base)
		{
		    baseInstance = base;
		}


		//! Get the axis aligned bounding box of this meshbuffer.
		/** \return Axis aligned bounding box of this buffer. */
		inline const core::aabbox3df& getBoundingBox() const {return boundingBox;}

		//! Set axis aligned bounding box
		/** \param box User defined axis aligned bounding box to use
		for this buffer. */
		inline void setBoundingBox(const core::aabbox3df& box)
		{
		    boundingBox = box;
		}

		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline const video::SMaterial& getMaterial() const
		{
			return Material;
		}


		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline video::SMaterial& getMaterial()
		{
			return Material;
		}
	};




	class ICPUMeshBuffer : public IMeshBuffer<core::ICPUBuffer>, core::BlobSerializable
	{
	    //vertices
	    E_VERTEX_ATTRIBUTE_ID posAttrId;
	public:
	    ICPUMeshBuffer(core::LeakDebugger* dbgr=NULL) : IMeshBuffer<core::ICPUBuffer>(NULL,dbgr), posAttrId(EVAI_ATTR0) {}

		virtual void* serializeToBlob(void* _stackPtr = NULL, const size_t& _stackSize = 0) const
		{
			return core::CorrespondingBlobTypeFor<ICPUMeshBuffer>::type::createAndTryOnStack(this, _stackPtr, _stackSize);
		}

		//! Returns id of position attribute.
        inline const E_VERTEX_ATTRIBUTE_ID& getPositionAttributeIx() const {return posAttrId;}
		//! Sets id of position atrribute.
        inline void setPositionAttributeIx(const E_VERTEX_ATTRIBUTE_ID& attrId)
        {
            if (attrId>=EVAI_COUNT)
#ifdef _DEBUG
            {
                //os::Printer::log("MeshBuffer setPositionAttributeIx attribute ID out of range!\n",ELL_ERROR);
                return;
            }
#else
                return;
#endif // _DEBUG

            posAttrId = attrId;
        }

		//! Get access to Indices.
		/** \return Pointer to indices array. */
		inline void* getIndices()
		{
		    if (!meshLayout)
                return NULL;
            if (!meshLayout->getIndexBuffer())
                return NULL;

		    return ((uint8_t*)meshLayout->getIndexBuffer()->getPointer())+indexBufOffset;
        }

		//! Get access to Indices.
		/** We only keep track of a position attribute, as every vertex needs to have at least a position to be displayed on the screen.
		Certain vertices may not have colors, normals, texture coords, etc. but a position is always present.
		\return Pointer to index array. */
        inline const void* getIndices() const
        {
		    if (!meshLayout)
                return NULL;
            if (!meshLayout->getIndexBuffer())
                return NULL;

		    return ((const uint8_t*)meshLayout->getIndexBuffer()->getPointer())+indexBufOffset;
        }

		//! Accesses given index of mapped position attribute buffer.
		/** @param ix Index number of vertex which is to be returned.
		@returns `ix`th vertex of mapped attribute buffer or (0, 0, 0, 1) vector if an error occured (e.g. no such vertex).
		@see @ref getAttribute()
		*/
        virtual core::vectorSIMDf getPosition(size_t ix) const
        {
            core::vectorSIMDf outPos(0.f,0.f,0.f,1.f);
            bool success = getAttribute(outPos,posAttrId,ix);
#ifdef _DEBUG
            if (!success)
            {
                //os::Printer::log("SOME DEBUG MESSAGE!\n",ELL_ERROR);
            }
#endif // _DEBUG
		    return outPos;
        }

		//! Accesses data of buffer of attribute of given id
		/** Basically it will get the start of the array at the same point as OpenGL will get upon a glDraw*.
		@param attrId Attribute id.
		@returns Pointer to corresponding buffer's data incremented by `baseVertex` and by `bufferOffset`
		@see @ref getBaseVertex() setBaseVertex() getAttribute()
		*/
        virtual uint8_t* getAttribPointer(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
		    if (!meshLayout)
                return NULL;

            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(attrId);
            if (attrId>=EVAI_COUNT||!mappedAttrBuf)
                return NULL;

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            if (!validCombination(attrType,components))
                return NULL;


            int64_t ix = baseVertex;
            ix *= meshLayout->getMappedBufferStride(attrId);
            ix += meshLayout->getMappedBufferOffset(attrId);
            if (ix<0||ix>=mappedAttrBuf->getSize())
                return NULL;

            return ((uint8_t*)mappedAttrBuf->getPointer())+ix;
        }

		//! Accesses vertex of given index of given vertex attribute. Index number is incremented by `baseVertex`. WARNING: NOT ALL FORMAT CONVERSIONS TO RGBA32F/XYZW32F ARE IMPLEMENTED!
		/** If component count of given attribute is less than 4, only first ones of output vector's members will be written.
		@param[out] output vectorSIMDf object to which index's value will be returned.
		@param[in] attrId Atrribute id.
		@param[in] ix Index which is to be accessed. Will be incremented by `baseVertex`.
		@returns true if successful or false if an error occured (e.g. `ix` out of range, no attribute specified/bound or given attribute's format conversion to vectorSIMDf unsupported).
		@see @ref getBaseVertex() setBaseVertex() getAttribute()
		*/
        virtual bool getAttribute(core::vectorSIMDf& output, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
            const uint8_t* vxPtr = const_cast<const uint8_t*>(getAttribPointer(attrId));
            if (!vxPtr)
                return false;
            vxPtr += ix*meshLayout->getMappedBufferStride(attrId);
            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(attrId);
            if (vxPtr-((uint8_t*)mappedAttrBuf->getPointer())>=mappedAttrBuf->getSize())
                return false;

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            //! ECPA_REVERSED_OR_BGRA not DONE CORRECTLY
            switch (attrType)
            {
                case ECT_FLOAT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((float*)vxPtr)[j];
                    return true;
                    break;
                case ECT_HALF_FLOAT:
                    {
#ifdef _DEBUG
                        //os::Printer::log("HALF FLOAT BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_DOUBLE_IN_FLOAT_OUT:
                case ECT_DOUBLE_IN_DOUBLE_OUT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((double*)vxPtr)[j];
                    return true;
                    break;
                case ECT_UNSIGNED_INT_10F_11F_11F_REV:
                    {
#ifdef _DEBUG
                        //os::Printer::log("UNSIGNED_INT_10F_11F_11F_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
                case ECT_INT_2_10_10_10_REV:
                case ECT_UNSIGNED_INT_2_10_10_10_REV:
                case ECT_INTEGER_INT_2_10_10_10_REV:
                case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
                    if (components!=ECPA_REVERSED_OR_BGRA)
                    {
                        output.pointer[0] = 0x3ffu&(((uint32_t*)vxPtr)[0]);
                        output.pointer[1] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>10);
                        output.pointer[2] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>20);
                        output.pointer[3] = ((uint32_t*)vxPtr)[0]>>30;
                    }
                    else
                    {/*
                        output.pointer[3] = 0x3ffu&(((uint32_t*)vxPtr)[0]);
                        output.pointer[0] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>10);
                        output.pointer[1] = 0x3ffu&(((uint32_t*)vxPtr)[0]>>20);
                        output.pointer[2] = ((uint32_t*)vxPtr)[0]>>30;*/
#ifdef _DEBUG
                        //os::Printer::log("PACKED INTEGER 2_10_10_10_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_NORMALIZED_BYTE:
                case ECT_NORMALIZED_UNSIGNED_BYTE:
                case ECT_BYTE:
                case ECT_UNSIGNED_BYTE:
                case ECT_INTEGER_BYTE:
                case ECT_INTEGER_UNSIGNED_BYTE:
                    if (components!=ECPA_REVERSED_OR_BGRA)
                    {
                        for (size_t j=0; j<components; j++)
                            output.pointer[j] = ((uint8_t*)vxPtr)[j];
                    }
                    else
                    {
#ifdef _DEBUG
                        //os::Printer::log("PACKED INTEGER 2_10_10_10_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    break;
                case ECT_NORMALIZED_SHORT:
                case ECT_NORMALIZED_UNSIGNED_SHORT:
                case ECT_SHORT:
                case ECT_UNSIGNED_SHORT:
                case ECT_INTEGER_SHORT:
                case ECT_INTEGER_UNSIGNED_SHORT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((uint16_t*)vxPtr)[j];
                    break;
                case ECT_NORMALIZED_INT:
                case ECT_NORMALIZED_UNSIGNED_INT:
                case ECT_INT:
                case ECT_UNSIGNED_INT:
                case ECT_INTEGER_INT:
                case ECT_INTEGER_UNSIGNED_INT:
                    for (size_t j=0; j<components; j++)
                        output.pointer[j] = ((uint32_t*)vxPtr)[j];
                    break;
                default:
                    return false;
            }

            core::vectorSIMDf subs[4][ECPA_COUNT] = {
                {core::vectorSIMDf(2.f,512.f,512.f,512.f),core::vectorSIMDf(512.f,0.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,2.f)},
                {core::vectorSIMDf(128.f,128.f,128.f,128.f),core::vectorSIMDf(128.f,0.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,128.f)},
                {core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f),core::vectorSIMDf(32768.f,0.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f)},
                {core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f),core::vectorSIMDf(2147483648.f,0.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f)}
            };
            switch (attrType)
            {
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_INT_2_10_10_10_REV:
                case ECT_INTEGER_INT_2_10_10_10_REV:
                    output -= subs[0][components];
                    break;
                case ECT_NORMALIZED_BYTE:
                case ECT_BYTE:
                case ECT_INTEGER_BYTE:
                    output -= subs[1][components];
                    break;
                case ECT_NORMALIZED_SHORT:
                case ECT_SHORT:
                case ECT_INTEGER_SHORT:
                    output -= subs[2][components];
                    break;
                case ECT_NORMALIZED_INT:
                case ECT_INT:
                case ECT_INTEGER_INT:
                    output -= subs[3][components];
                    break;
                default:
                    break;
            }

            core::vectorSIMDf divisors[8][ECPA_COUNT] = {
                {core::vectorSIMDf(1.f,511.f,511.f,511.f),core::vectorSIMDf(511.f,1.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f)},
                {core::vectorSIMDf(3.f,1023.f,1023.f,1023.f),core::vectorSIMDf(1023.f,1.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,3.f)},
                {core::vectorSIMDf(127.f,127.f,127.f,127.f),core::vectorSIMDf(127.f,1.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,127.f)},
                {core::vectorSIMDf(255.f,255.f,255.f,255.f),core::vectorSIMDf(255.f,1.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,255.f)},
                {core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f),core::vectorSIMDf(32767.f,1.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f)},
                {core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f),core::vectorSIMDf(65535.f,1.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f)},
                {core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f),core::vectorSIMDf(2147483647.f,1.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f)},
                {core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f),core::vectorSIMDf(4294967295.f,1.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f)}
            };
            switch (attrType)
            {
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                    output /= divisors[0][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
                    output /= divisors[1][components];
                    break;
                case ECT_NORMALIZED_BYTE:
                    output /= divisors[2][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_BYTE:
                    output /= divisors[3][components];
                    break;
                case ECT_NORMALIZED_SHORT:
                    output /= divisors[4][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_SHORT:
                    output /= divisors[5][components];
                    break;
                case ECT_NORMALIZED_INT:
                    output /= divisors[6][components];
                    break;
                case ECT_NORMALIZED_UNSIGNED_INT:
                    output /= divisors[7][components];
                    break;
                default:
                    break;
            }

            uint32_t outMasksBits[ECPA_COUNT][4] = {
                {0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu},
                {0xffffffffu,0,0,0},
                {0xffffffffu,0xffffffffu,0,0},
                {0xffffffffu,0xffffffffu,0xffffffffu,0},
                {0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu}
            };
            uint32_t outMasksBitsInv[ECPA_COUNT][4] = {
                {0,0,0,0},
                {0,0xffffffffu,0xffffffffu,0xffffffffu},
                {0,0,0xffffffffu,0xffffffffu},
                {0,0,0,0xffffffffu},
                {0,0,0,0}
            };
            switch (attrType)
            {
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_NORMALIZED_BYTE:
                case ECT_NORMALIZED_SHORT:
                case ECT_NORMALIZED_INT:
                    {
                        core::vectorSIMDf outputMask,outputMaskInv;
                        outputMask.set((float*)(outMasksBits[components]));
                        outputMaskInv.set((float*)(outMasksBitsInv[components]));
                        output = (max_(output,core::vectorSIMDf(-1.f,-1.f,-1.f,-1.f))&outputMask)|(outputMaskInv&output);
                    }
                    break;
                default:
                    break;
            }

            return true;
        }

		//! Sets value of vertex of given index of given attribute. WARNING: NOT ALL FORMAT CONVERSIONS FROM RGBA32F/XYZW32F (vectorSIMDf) ARE IMPLEMENTED!
		/** @param input Value which is to be set.
		@param attrId Atrribute id.
		@param ix Index of vertex which is to be set. Will be incremented by `baseVertex`.
		@returns true if successful or false if an error occured (e.g. no such index).
		@see @ref getBaseVertex() setBaseVertex() getAttribute()
		*/
        virtual bool setAttribute(core::vectorSIMDf input, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
            uint8_t* vxPtr = getAttribPointer(attrId);
            if (!vxPtr)
                return false;
            vxPtr += ix*meshLayout->getMappedBufferStride(attrId);

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            switch (attrType)
            {
                case ECT_FLOAT:
                    for (size_t j=0; j<components; j++)
                        ((float*)vxPtr)[j] = input.pointer[j];
                    return true;
                    break;
                case ECT_HALF_FLOAT:
                    {
#ifdef _DEBUG
                        //os::Printer::log("HALF FLOAT SET NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                    break;
                case ECT_DOUBLE_IN_FLOAT_OUT:
                case ECT_DOUBLE_IN_DOUBLE_OUT:
                    for (size_t j=0; j<components; j++)
                        ((double*)vxPtr)[j] = input.pointer[j];
                    return true;
                    break;
                case ECT_UNSIGNED_INT_10F_11F_11F_REV:
                    {
#ifdef _DEBUG
                        //os::Printer::log("UNSIGNED_INT_10F_11F_11F_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                    break;
                case ECT_NORMALIZED_INT_2_10_10_10_REV:
                case ECT_NORMALIZED_BYTE:
                case ECT_NORMALIZED_SHORT:
                case ECT_NORMALIZED_INT:
                    input += 1.f;
                    break;
                default:
                    {
                        // ECPA_REVERSED_OR_BGRA not DONE CORRECTLY
                        if (components==ECPA_REVERSED_OR_BGRA)
                            return false;
#ifdef _DEBUG
                        //os::Printer::log("SETTING INTEGER VERTEX ATTRIBUTE COMPONENTS FROM vectorSIMDf NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                        /*

            if normalized convert up,

            cast to int64_t

                        core::vectorSIMDf divisors[8][ECPA_COUNT] = {
                            {core::vectorSIMDf(1.f,511.f,511.f,511.f),core::vectorSIMDf(511.f,1.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f)},
                            {core::vectorSIMDf(3.f,1023.f,1023.f,1023.f),core::vectorSIMDf(1023.f,1.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,3.f)},
                            {core::vectorSIMDf(127.f,127.f,127.f,127.f),core::vectorSIMDf(127.f,1.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,127.f)},
                            {core::vectorSIMDf(255.f,255.f,255.f,255.f),core::vectorSIMDf(255.f,1.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,255.f)},
                            {core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f),core::vectorSIMDf(32767.f,1.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f)},
                            {core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f),core::vectorSIMDf(65535.f,1.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f)},
                            {core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f),core::vectorSIMDf(2147483647.f,1.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f)},
                            {core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f),core::vectorSIMDf(4294967295.f,1.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f)}
                        };
                        int64_t results[4];
                        switch (attrType)
                        {
                            case ECT_NORMALIZED_INT_2_10_10_10_REV:
                            case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
                            case ECT_NORMALIZED_BYTE:
                            case ECT_NORMALIZED_UNSIGNED_BYTE:
                            case ECT_NORMALIZED_SHORT:
                            case ECT_NORMALIZED_UNSIGNED_SHORT:
                            case ECT_NORMALIZED_INT:
                            case ECT_NORMALIZED_UNSIGNED_INT:
                                break;
                        }
                        for (size_t j=0; j<components; j++)
                            results[j] = input.pointer[j];*/
                    }
                    break;

            }

            return false;
        }

		//! @copydoc setAttribute(core::vectorSIMDf, const E_VERTEX_ATTRIBUTE_ID&, size_t)
        virtual bool setAttribute(uint32_t* input, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
            uint8_t* vxPtr = getAttribPointer(attrId);
            if (!vxPtr)
                return false;
            vxPtr += ix*meshLayout->getMappedBufferStride(attrId);

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            switch (attrType)
            {
                case ECT_UNSIGNED_INT_2_10_10_10_REV:
                case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
                    if (components==ECPA_FOUR)
                    {
                        reinterpret_cast<uint32_t*>(vxPtr)[0] = (input[0]&0x3ffu)|((input[1]&0x3ffu)<<10)|((input[2]&0x3ffu)<<20)|((input[3]&0x3u)<<30);
                    }/*
                    else if (components!=ECPA_REVERSED_OR_BGRA)
                    {
                        reinterpret_cast<uint32_t*>(vxPtr)[0] = (input[0]&0x3ffu)|((input[1]&0x3ffu)<<10)|((input[2]&0x3ffu)<<20)|((input[3]&0x3u)<<30);
                    }*/
                    else
                    {
#ifdef _DEBUG
                        //os::Printer::log("PACKED INTEGER 2_10_10_10_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                    break;
                case ECT_UNSIGNED_BYTE:
                case ECT_INTEGER_UNSIGNED_BYTE:
                    if (components!=ECPA_REVERSED_OR_BGRA)
                    {
                        for (size_t j=0; j<components; j++)
                            reinterpret_cast<uint8_t*>(vxPtr)[j] = input[j];
                    }
                    else
                    {
#ifdef _DEBUG
                        //os::Printer::log("PACKED INTEGER 2_10_10_10_REV BBOX COMPUTE NOT IMPLEMENTED YET!\n",ELL_ERROR);
#endif // _DEBUG
                        return false;
                    }
                    return true;
                    break;
                case ECT_UNSIGNED_SHORT:
                case ECT_INTEGER_UNSIGNED_SHORT:
                    for (size_t j=0; j<components; j++)
                        reinterpret_cast<uint16_t*>(vxPtr)[j] = input[j];
                    return true;
                    break;
                case ECT_UNSIGNED_INT:
                case ECT_INTEGER_UNSIGNED_INT:
                    for (size_t j=0; j<components; j++)
                        reinterpret_cast<uint32_t*>(vxPtr)[j] = input[j];
                    return true;
                    break;
                default:
                    return false;
                    break;

            }

            return false;
        }

		//! Recalculates the bounding box. Should be called if the mesh changed.
		virtual void recalculateBoundingBox()
		{
		    if (!meshLayout)
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(posAttrId);
            if (posAttrId>=EVAI_COUNT||!mappedAttrBuf)
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

		    if (!validCombination(meshLayout->getAttribType(posAttrId),meshLayout->getAttribComponentCount(posAttrId)))
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

            for (size_t j=0; j<indexCount; j++)
            {
                size_t ix;
                void* indices = getIndices();
                if (indices)
                {
                    switch(indexType)
                    {
                        case video::EIT_32BIT:
                            ix  = ((uint32_t*)indices)[j];
                            break;
                        case video::EIT_16BIT:
                            ix  = ((uint16_t*)indices)[j];
                            break;
                        default:
                            return;
                    }
                }
                else
                    ix = j;


                if (j)
                    boundingBox.addInternalPoint(getPosition(ix).getAsVector3df());
                else
                    boundingBox.reset(getPosition(ix).getAsVector3df());
            }
		}
	};

	class IGPUMeshBuffer : public IMeshBuffer<video::IGPUBuffer>
	{
            video::ITransformFeedback* attachedXFormFeedback;
            uint32_t attachedXFormFeedbackStream;
        protected:
            virtual ~IGPUMeshBuffer()
            {
                if (attachedXFormFeedback)
                    attachedXFormFeedback->drop();
            }
        public:
            IGPUMeshBuffer(core::LeakDebugger* dbgr=NULL) : IMeshBuffer<video::IGPUBuffer>(NULL,dbgr), attachedXFormFeedback(NULL), attachedXFormFeedbackStream(0) {}

            inline void setIndexCountFromXFormFeedback(video::ITransformFeedback* xformFeedback, const uint32_t & stream)
            {
                attachedXFormFeedbackStream = stream;


                if (xformFeedback==attachedXFormFeedback)
                    return;

                if (!xformFeedback)
                {
                    if (attachedXFormFeedback)
                        attachedXFormFeedback->drop();

                    attachedXFormFeedback = NULL;
                    return;
                }

                xformFeedback->grab();
                if (attachedXFormFeedback)
                    attachedXFormFeedback->drop();
                attachedXFormFeedback = xformFeedback;

                indexType = video::EIT_UNKNOWN;
                indexCount = 0;
            }

            inline video::ITransformFeedback* getXFormFeedback() const {return attachedXFormFeedback;}

            inline const uint32_t& getXFormFeedbackStream() const {return attachedXFormFeedbackStream;}

            bool isIndexCountGivenByXFormFeedback() const {return attachedXFormFeedback!=NULL;}
	};

#include "irrpack.h"
    class SkinnedVertexIntermediateData
    {
        public:
            SkinnedVertexIntermediateData()
            {
                memset(this,0,20);
            }
            uint8_t boneIDs[4];
            float boneWeights[4];
    } PACK_STRUCT;

    struct SkinnedVertexFinalData
    {
        public:
            uint8_t boneIDs[4];
            uint32_t boneWeights; //ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV
    } PACK_STRUCT;
#include "irrunpack.h"

} // end namespace scene
} // end namespace irr

#endif


