// Copyright (C) 2002-2012 Nikolaus Gebhardt
// This file is part of the "Irrlicht Engine".
// For conditions of distribution and use, see copyright notice in irrlicht.h

#ifndef __I_MESH_BUFFER_H_INCLUDED__
#define __I_MESH_BUFFER_H_INCLUDED__

#include <algorithm>

#include "ITransformFeedback.h"
#include "SMaterial.h"
#include "aabbox3d.h"
#include "SVertexIndex.h"
#include "EPrimitiveTypes.h"
#include "ICPUBuffer.h"
#include "IGPUBuffer.h"
#include "SMaterial.h"
#include "vectorSIMD.h"
#include "coreutil.h"
#include "CBAWFile.h"
#include "assert.h"

namespace irr
{
namespace scene
{
	//! Available vertex attribute ids
	/** As of 2018 most OpenGL implementations support 16 attributes (some CAD GPUs more) */
    enum E_VERTEX_ATTRIBUTE_ID
    {
        EVAI_ATTR0=0,
        EVAI_ATTR1,
        EVAI_ATTR2,
        EVAI_ATTR3,
        EVAI_ATTR4,
        EVAI_ATTR5,
        EVAI_ATTR6,
        EVAI_ATTR7,
        EVAI_ATTR8,
        EVAI_ATTR9,
        EVAI_ATTR10,
        EVAI_ATTR11,
        EVAI_ATTR12,
        EVAI_ATTR13,
        EVAI_ATTR14,
        EVAI_ATTR15,
        EVAI_COUNT
    };

	//! Available components' sizes enumeration
    enum E_COMPONENTS_PER_ATTRIBUTE
    {
		//! Special ID for reverse XYZW order
        ECPA_REVERSED_OR_BGRA=0,
        ECPA_ONE,
        ECPA_TWO,
        ECPA_THREE,
        ECPA_FOUR,
        ECPA_COUNT
    };

	//! Available components' type
    enum E_COMPONENT_TYPE
    {
        ECT_FLOAT=0,
        ECT_HALF_FLOAT,
        ECT_DOUBLE_IN_FLOAT_OUT,
        ECT_UNSIGNED_INT_10F_11F_11F_REV,
        //INTEGER FORMS
        ECT_NORMALIZED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_BYTE,
        ECT_NORMALIZED_UNSIGNED_BYTE,
        ECT_NORMALIZED_SHORT,
        ECT_NORMALIZED_UNSIGNED_SHORT,
        ECT_NORMALIZED_INT,
        ECT_NORMALIZED_UNSIGNED_INT,
        ECT_INT_2_10_10_10_REV,
        ECT_UNSIGNED_INT_2_10_10_10_REV,
        ECT_BYTE,
        ECT_UNSIGNED_BYTE,
        ECT_SHORT,
        ECT_UNSIGNED_SHORT,
        ECT_INT,
        ECT_UNSIGNED_INT,
        ECT_INTEGER_INT_2_10_10_10_REV,
        ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV,
        ECT_INTEGER_BYTE,
        ECT_INTEGER_UNSIGNED_BYTE,
        ECT_INTEGER_SHORT,
        ECT_INTEGER_UNSIGNED_SHORT,
        ECT_INTEGER_INT,
        ECT_INTEGER_UNSIGNED_INT,
        //special
        ECT_DOUBLE_IN_DOUBLE_OUT, //only accepted by glVertexAttribLPointer
        ECT_COUNT
    };
/**
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.

GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.

GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.

GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
**/
    static size_t vertexAttrSize[ECT_COUNT][ECPA_COUNT] = {
        {0xdeadbeefu,4,8,12,16}, // ECT_FLOAT
        {0xdeadbeefu,2,4,6,8}, // ECT_HALF_FLOAT
        {0xdeadbeefu,8,16,24,32}, // ECT_DOUBLE_IN_FLOAT_OUT
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4,0xdeadbeefu}, //ECT_UNSIGNED_INT_10F_11F_11F_REV
        //integers
        //normalized
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_INT_2_10_10_10_REV
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV
        {0xdeadbeefu,1,2,3,4}, //ECT_NORMALIZED_BYTE
        {4,1,2,3,4}, // ECT_NORMALIZED_UNSIGNED_BYTE
        {0xdeadbeefu,2,4,6,8}, // ECT_NORMALIZED_SHORT
        {0xdeadbeefu,2,4,6,8}, // ECT_NORMALIZED_UNSIGNED_SHORT
        {0xdeadbeefu,4,8,12,16}, // ECT_NORMALIZED_INT
        {0xdeadbeefu,4,8,12,16}, // ECT_NORMALIZED_UNSIGNED_INT
        //un normalized ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, // ECT_INT_2_10_10_10_REV
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, // ECT_UNSIGNED_INT_2_10_10_10_REV
        {0xdeadbeefu,1,2,3,4}, // ECT_BYTE
        {0xdeadbeefu,1,2,3,4}, // ECT_UNSIGNED_BYTE
        {0xdeadbeefu,2,4,6,8}, // ECT_SHORT
        {0xdeadbeefu,2,4,6,8}, // ECT_UNSIGNED_SHORT
        {0xdeadbeefu,4,8,12,16}, // ECT_INT
        {0xdeadbeefu,4,8,12,16}, // ECT_UNSIGNED_INT
        //native ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, // ECT_INTEGER_INT_2_10_10_10_REV
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, // ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV
        {0xdeadbeefu,1,2,3,4}, // ECT_INTEGER_BYTE
        {0xdeadbeefu,1,2,3,4}, // ECT_INTEGER_UNSIGNED_BYTE
        {0xdeadbeefu,2,4,6,8}, // ECT_INTEGER_SHORT
        {0xdeadbeefu,2,4,6,8}, // ECT_INTEGER_UNSIGNED_SHORT
        {0xdeadbeefu,4,8,12,16}, // ECT_INTEGER_INT
        {0xdeadbeefu,4,8,12,16}, // ECT_INTEGER_UNSIGNED_INT
        //special
        {0xdeadbeefu,8,16,24,32} // ECT_DOUBLE_IN_DOUBLE_OUT
    };

	//! Checks whether given combination of attribute's type and component count is valid
	/** In OpenGL some formats are special like RGB30_A2 or RGB9_E5 which force the number of components and give no flexibility in the number of channels
	@param type Type of an atrribute.
	@param components Component count of an atrribute.
	@returns true if such combination is valid or false otherwise.
	*/
    inline bool validCombination(const E_COMPONENT_TYPE& type, const E_COMPONENTS_PER_ATTRIBUTE& components)
    {
        return vertexAttrSize[type][components]<0xdeadbeefu;
    }

	//! Checks whether given attribute type is a normalized one.
	/** @param type Type of an attribute.
	@returns true if given attribute type is normalized or false otherwise.
	*/
    inline bool isNormalized(const E_COMPONENT_TYPE& type)
    {
        return type >= ECT_NORMALIZED_INT_2_10_10_10_REV && type <= ECT_NORMALIZED_UNSIGNED_INT;
    }

	//! Checks whether given attribute type is "weak integer", e.g. is an integer accessed as floating-point on shader-side.
	/** @param type Type of an attribute.
	@returns true if given attribute type is "weak integer" or false otherwise.
	*/
	inline bool isWeakInteger(const E_COMPONENT_TYPE& type)
	{
		if (isNormalized(type))
			return true;
		switch (type)
		{
			case ECT_INT_2_10_10_10_REV:
			case ECT_UNSIGNED_INT_2_10_10_10_REV:
			case ECT_BYTE:
			case ECT_UNSIGNED_BYTE:
			case ECT_SHORT:
			case ECT_UNSIGNED_SHORT:
			case ECT_INT:
			case ECT_UNSIGNED_INT:
				return true;
		}
		return false;
	}

	//! Checks whether given attribute type is an integer accessed as integer on shader-side.
	/** @param type Type of an attribute.
	@returns true if given attribute type is native integer or false otherwise.
	*/
	inline bool isNativeInteger(const E_COMPONENT_TYPE& type)
	{
		switch (type)
		{
		case ECT_INTEGER_INT_2_10_10_10_REV:
		case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_INTEGER_BYTE:
		case ECT_INTEGER_UNSIGNED_BYTE:
		case ECT_INTEGER_SHORT:
		case ECT_INTEGER_UNSIGNED_SHORT:
		case ECT_INTEGER_INT:
		case ECT_INTEGER_UNSIGNED_INT:
			return true;
		}
		return false;
	}

	//! Checks whether given attribute type is unsigned.
	/** @param type Type of an attribute.
	@returns true if given attribute type is unsigned or false otherwise.
	*/
	inline bool isUnsigned(const E_COMPONENT_TYPE& type)
	{
		switch (type)
		{
		case ECT_UNSIGNED_INT_10F_11F_11F_REV:
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_NORMALIZED_UNSIGNED_BYTE:
		case ECT_NORMALIZED_UNSIGNED_SHORT:
		case ECT_NORMALIZED_UNSIGNED_INT:
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_UNSIGNED_BYTE:
		case ECT_UNSIGNED_SHORT:
		case ECT_UNSIGNED_INT:
		case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_INTEGER_UNSIGNED_BYTE:
		case ECT_INTEGER_UNSIGNED_SHORT:
		case ECT_INTEGER_UNSIGNED_INT:
			return true;
		}
		return false;
	}

	//! Checks whether given attribute type is signed.
	/** @param type Type of an attribute.
	@returns true if given attribute type is signed or false otherwise.
	*/
	inline bool isSigned(const E_COMPONENT_TYPE& type)
	{
		return !isUnsigned(type);
	}

	//! Returns max representable value on given attribute type on given component. Only for attribute types available to get by ICPUMeshBuffer::getAttribute(core::vectorSIMDf&, const E_VERTEX_ATTRIBUTE_ID&, size_t) (all except *_INTEGER_* ones).
	/**
	@param _attrType Attribute type.
	@param _cmpnt Num of component (must be less than 4).
	@returns Max representable value or 0 if given type is not supported by this function (see maxValueOfTypeINT()) or given type does not support given amount of components.
	@see @ref maxValueOfTypeINT()
	*/
	inline float maxValueOfTypeFP(E_COMPONENT_TYPE _attrType, size_t _cmpnt)
	{
		if (isNormalized(_attrType))
			return 1.f;

		switch (_attrType)
		{
		case ECT_FLOAT:
		case ECT_DOUBLE_IN_FLOAT_OUT:
			return FLT_MAX;
		case ECT_HALF_FLOAT:
			return 65504.f;
		case ECT_UNSIGNED_INT_10F_11F_11F_REV:
			if (_cmpnt == 2)
				return 64512.f;
			else if (_cmpnt < 2)
				return 65024.f;
			break;
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return 3;
			else
				return 0x3ff;
		case ECT_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return 1.f;
			else
				return 0x3ff / 2;
		case ECT_BYTE:
			return SCHAR_MAX;
		case ECT_UNSIGNED_BYTE:
			return UCHAR_MAX;
		case ECT_SHORT:
			return SHRT_MAX;
		case ECT_UNSIGNED_SHORT:
			return USHRT_MAX;
		case ECT_NORMALIZED_INT:
		case ECT_INT:
			return INT_MAX;
		case ECT_UNSIGNED_INT:
			return UINT_MAX;
		}
		return 0.f;
	}

	//! Returns min representable value on given attribute type on given component. Only for attribute types available to get by ICPUMeshBuffer::getAttribute(core::vectorSIMDf&, const E_VERTEX_ATTRIBUTE_ID&, size_t) (all except *_INTEGER_* ones).
	/**
	@param _attrType Attribute type.
	@param _cmpnt Num of component (must be less than 4).
	@returns Min representable value or positive value if given type is not supported by this function (see minValueOfTypeINT()) or given type does not support given amount of components.
	@see @ref minValueOfTypeINT()
	*/
	inline float minValueOfTypeFP(E_COMPONENT_TYPE _attrType, size_t _cmpnt)
	{
		switch (_attrType)
		{
		case ECT_FLOAT:
		case ECT_DOUBLE_IN_FLOAT_OUT:
			return -FLT_MAX;
		case ECT_HALF_FLOAT:
			return -65504.f;
		case ECT_UNSIGNED_INT_10F_11F_11F_REV:
			if (_cmpnt < 2)
				return 0.f;
			break;
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
			return 0.f;
		case ECT_NORMALIZED_INT_2_10_10_10_REV:
			return -1.f;
		case ECT_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return -2.f;
			else
				return -0x3ff/2 - 1;
		case ECT_NORMALIZED_BYTE:
			return -1.f;
		case ECT_BYTE:
			return SCHAR_MIN;
		case ECT_NORMALIZED_UNSIGNED_BYTE:
		case ECT_UNSIGNED_BYTE:
			return 0;
		case ECT_NORMALIZED_SHORT:
			return -1.f;
		case ECT_SHORT:
			return SHRT_MIN;
		case ECT_NORMALIZED_UNSIGNED_SHORT:
		case ECT_UNSIGNED_SHORT:
			return 0;
		case ECT_NORMALIZED_INT:
			return -1.f;
		case ECT_INT:
			return INT_MIN;
		case ECT_NORMALIZED_UNSIGNED_INT:
		case ECT_UNSIGNED_INT:
			return 0;
		}
		return 1.f;
	}

	//! Returns max representable value on given attribute type on given component. Only for attribute types available to get by ICPUMeshBuffer::getAttribute(uint32_t*, const E_VERTEX_ATTRIBUTE_ID&, size_t).
	/**
	@param _attrType Attribute type.
	@param _cmpnt Num of component (must be less than 4).
	@returns Max representable value or 0 if given type is not supported by this function (see maxValueOfTypeFP()) or given type does not support given amount of components.
	@see @ref maxValueOfTypeFP()
	*/
	inline uint32_t maxValueOfTypeINT(E_COMPONENT_TYPE _attrType, size_t _cmpnt)
	{
		switch (_attrType)
		{
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return 3;
			else
				return 0x3ff;
		case ECT_INT_2_10_10_10_REV:
		case ECT_INTEGER_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return 1;
			else
				return 0x3ff / 2;
		case ECT_BYTE:
		case ECT_INTEGER_BYTE:
			return SCHAR_MAX;
		case ECT_UNSIGNED_BYTE:
		case ECT_INTEGER_UNSIGNED_BYTE:
			return UCHAR_MAX;
		case ECT_SHORT:
		case ECT_INTEGER_SHORT:
			return SHRT_MAX;
		case ECT_UNSIGNED_SHORT:
		case ECT_INTEGER_UNSIGNED_SHORT:
			return USHRT_MAX;
		case ECT_INT:
		case ECT_INTEGER_INT:
			return INT_MAX;
		case ECT_UNSIGNED_INT:
		case ECT_INTEGER_UNSIGNED_INT:
			return UINT_MAX;
		}
		return 0;
	}

	//! Returns min representable value on given attribute type on given component. Only for attribute types available to get by ICPUMeshBuffer::getAttribute(uint32_t*, const E_VERTEX_ATTRIBUTE_ID&, size_t).
	/**
	@param _attrType Attribute type.
	@param _cmpnt Num of component (must be less than 4).
	@returns Min representable value or positive value if given type is not supported by this function (see minValueOfTypeFP()) or given type does not support given amount of components.
	@see @ref minValueOfTypeFP()
	*/
	inline int32_t minValueOfTypeINT(E_COMPONENT_TYPE _attrType, size_t _cmpnt)
	{
		switch (_attrType)
		{
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
			return 0;
		case ECT_INT_2_10_10_10_REV:
		case ECT_INTEGER_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return -2;
			else
				return -0x3ff/2 - 1;
		case ECT_BYTE:
		case ECT_INTEGER_BYTE:
			return SCHAR_MIN;
		case ECT_UNSIGNED_BYTE:
		case ECT_INTEGER_UNSIGNED_BYTE:
			return 0;
		case ECT_SHORT:
		case ECT_INTEGER_SHORT:
			return SHRT_MIN;
		case ECT_UNSIGNED_SHORT:
		case ECT_INTEGER_UNSIGNED_SHORT:
			return 0;
		case ECT_INT:
		case ECT_INTEGER_INT:
			return INT_MIN;
		case ECT_UNSIGNED_INT:
		case ECT_INTEGER_UNSIGNED_INT:
			return 0;
		}
		return 1;
	}

	//! Gets normalized, corresponding to given attribute type. Makes sense only for "weak integer" types.
	/**
	@param _type Given type.
	@returns Normalized corresponding to given type or ECT_COUNT for types without such.
	*/
	inline E_COMPONENT_TYPE getCorrespondingNormalizedType(E_COMPONENT_TYPE _type)
	{
		switch (_type)
		{
		case ECT_INT_2_10_10_10_REV:
			return ECT_NORMALIZED_INT_2_10_10_10_REV;
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
			return ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV;
		case ECT_BYTE:
			return ECT_NORMALIZED_BYTE;
		case ECT_UNSIGNED_BYTE:
			return ECT_NORMALIZED_UNSIGNED_BYTE;
		case ECT_SHORT:
			return ECT_NORMALIZED_SHORT;
		case ECT_UNSIGNED_SHORT:
			return ECT_NORMALIZED_UNSIGNED_SHORT;
		case ECT_INT:
			return ECT_NORMALIZED_INT;
		case ECT_UNSIGNED_INT:
			return ECT_NORMALIZED_UNSIGNED_INT;
		}
		return ECT_COUNT;
	}

	//! Gets not normalized, corresponding to given attribute type. Makes sense only for normalized types.
	/**
	@param _type Given type.
	@returns Not normalized corresponding to given type or ECT_COUNT for types without such.
	*/
	inline E_COMPONENT_TYPE getCorrespondingDenormalizedType(E_COMPONENT_TYPE _type)
	{
		switch (_type)
		{
		case ECT_NORMALIZED_INT_2_10_10_10_REV:
			return ECT_INT_2_10_10_10_REV;
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
			return ECT_UNSIGNED_INT_2_10_10_10_REV;
		case ECT_NORMALIZED_BYTE:
			return ECT_BYTE;
		case ECT_NORMALIZED_UNSIGNED_BYTE:
			return ECT_UNSIGNED_BYTE;
		case ECT_NORMALIZED_SHORT:
			return ECT_SHORT;
		case ECT_NORMALIZED_UNSIGNED_SHORT:
			return ECT_UNSIGNED_SHORT;
		case ECT_NORMALIZED_INT:
			return ECT_INT;
		case ECT_NORMALIZED_UNSIGNED_INT:
			return ECT_UNSIGNED_INT;
		}
		return ECT_COUNT;
	}

	inline core::vectorSIMDf denormalizeAttribute(E_COMPONENT_TYPE _srcType, const core::vectorSIMDf& _in)
	{
		switch (_srcType)
		{
		case ECT_NORMALIZED_INT_2_10_10_10_REV:
			return _in * core::vectorSIMDf(511.f, 511.f, 511.f, 1.f);
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
			return _in * core::vectorSIMDf(1023.f, 1023.f, 1023.f, 3.f);
		case ECT_NORMALIZED_BYTE:
			return _in * (float)SCHAR_MAX;
		case ECT_NORMALIZED_UNSIGNED_BYTE:
			return _in * (float)UCHAR_MAX;
		case ECT_NORMALIZED_SHORT:
			return _in * (float)SHRT_MAX;
		case ECT_NORMALIZED_UNSIGNED_SHORT:
			return _in * (float)USHRT_MAX;
		case ECT_NORMALIZED_INT:
			return _in * (float)INT_MAX;
		case ECT_NORMALIZED_UNSIGNED_INT:
			return _in * (float)UINT_MAX;
		}
		return _in;
	}

	inline core::vectorSIMDf normalizeAttribute(E_COMPONENT_TYPE _dstType, const core::vectorSIMDf& _in)
	{
		switch (_dstType)
		{
		case ECT_NORMALIZED_INT_2_10_10_10_REV:
			return _in / core::vectorSIMDf(511.f, 511.f, 511.f, 1.f);
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
			return _in / core::vectorSIMDf(1023.f, 1023.f, 1023.f, 3.f);
		case ECT_NORMALIZED_BYTE:
			return _in / (float)SCHAR_MAX;
		case ECT_NORMALIZED_UNSIGNED_BYTE:
			return _in / (float)UCHAR_MAX;
		case ECT_NORMALIZED_SHORT:
			return _in / (float)SHRT_MAX;
		case ECT_NORMALIZED_UNSIGNED_SHORT:
			return _in / (float)USHRT_MAX;
		case ECT_NORMALIZED_INT:
			return _in / (float)INT_MAX;
		case ECT_NORMALIZED_UNSIGNED_INT:
			return _in / (float)UINT_MAX;
		}
		return _in;
	}

	template <class T>
	class IMeshDataFormatDesc : public virtual IReferenceCounted
	{
        protected:
			//! Read https://www.khronos.org/opengl/wiki/Vertex_Specification for understanding of attribute IDs, indices, attribute formats etc.
            E_COMPONENTS_PER_ATTRIBUTE compntsPerAttr[EVAI_COUNT];
            E_COMPONENT_TYPE attrType[EVAI_COUNT];
            size_t attrStride[EVAI_COUNT];
            size_t attrOffset[EVAI_COUNT];
            uint32_t attrDivisor[EVAI_COUNT];

            //vertices
            T* mappedAttrBuf[scene::EVAI_COUNT];
            //indices
            T* mappedIndexBuf;

            virtual ~IMeshDataFormatDesc()
            {
                for (size_t i=0; i<EVAI_COUNT; i++)
                {
                    if (mappedAttrBuf[i])
                        mappedAttrBuf[i]->drop();
                }

                if (getIndexBuffer())
                    getIndexBuffer()->drop();
            }
        public:
            //! Default constructor.
            IMeshDataFormatDesc()
            {
                for (size_t i=0; i<EVAI_COUNT; i++)
                {
                    compntsPerAttr[i] = ECPA_FOUR;
                    attrType[i] = ECT_FLOAT;
                    attrStride[i] = 16;
                    attrOffset[i] = 0;
                    attrDivisor[i] = 0;
                    mappedAttrBuf[i] = NULL;
                }
                mappedIndexBuf = NULL;
            }

            inline bool formatCanBeAppended(const IMeshDataFormatDesc<T>* other) const
            {
                bool retVal = true;
                for (size_t i=0; retVal&&i<EVAI_COUNT; i++)
                {
                    if (this->getMappedBuffer(static_cast<E_VERTEX_ATTRIBUTE_ID>(i)))
                    {
                        if (other->getMappedBuffer(static_cast<E_VERTEX_ATTRIBUTE_ID>(i)))
                            retVal = retVal&&compntsPerAttr[i]==other->compntsPerAttr[i]&&attrType[i]==other->attrType[i];
                        else
                            return false;
                    }
                    else
                    {
                        if (other->getMappedBuffer(static_cast<E_VERTEX_ATTRIBUTE_ID>(i)))
                            return false;
                        else
                            retVal = retVal&&compntsPerAttr[i]==other->compntsPerAttr[i]&&attrType[i]==other->attrType[i];
                    }
                }
                return retVal;
            }

            inline void mapIndexBuffer(T* ixbuf)
            {
        /*
        #ifdef _DEBUG
                if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset)) //not that easy to check
                {
                    os::Printer::log("MeshBuffer map index buffer overflow!\n",ELL_ERROR);
                    return;
                }
        #endif // _DEBUG
        */
                if (ixbuf)
                    ixbuf->grab();

                if (mappedIndexBuf)
                    mappedIndexBuf->drop();
                mappedIndexBuf = ixbuf;
            }

            inline const T* getIndexBuffer() const
            {
                return mappedIndexBuf;
            }


            //! remember that the divisor needs to be <=0x1u<<_IRR_VAO_MAX_ATTRIB_DIVISOR_BITS
            virtual void mapVertexAttrBuffer(T* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0, uint32_t divisor=0) = 0;

            inline const T* getMappedBuffer(const scene::E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return mappedAttrBuf[attrId];
            }


            inline const E_COMPONENT_TYPE& getAttribType(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrType[attrId];
            }

            inline const E_COMPONENTS_PER_ATTRIBUTE& getAttribComponentCount(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return compntsPerAttr[attrId];
            }

            inline void setMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId, const size_t &offset)
            {
                assert(attrId<EVAI_COUNT);

                if (!mappedAttrBuf[attrId])
                    return;

                attrOffset[attrId] = offset;
            }

            inline const size_t& getMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrOffset[attrId];
            }

            inline const size_t& getMappedBufferStride(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrStride[attrId];
            }

            inline const uint32_t& getAttribDivisor(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrDivisor[attrId];
            }

            inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId)
            {
                swapVertexAttrBuffer(attrBuf, attrId, attrOffset[attrId], attrStride[attrId]);
            }

            inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId, const size_t& newOffset)
            {
                swapVertexAttrBuffer(attrBuf, attrId, newOffset, attrStride[attrId]);
            }

            inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId, const size_t& newOffset, const size_t& newStride)
            {
                if (!mappedAttrBuf[attrId] || !attrBuf)
                    return;

                attrBuf->grab();
                mappedAttrBuf[attrId]->drop();

                mappedAttrBuf[attrId] = attrBuf;
                attrOffset[attrId] = newOffset;
                attrStride[attrId] = newStride;
            }
	};


	class ICPUMeshDataFormatDesc : public IMeshDataFormatDesc<core::ICPUBuffer>, core::BlobSerializable
	{
        protected:
	        ~ICPUMeshDataFormatDesc()
	        {
	        }
	    public:
			virtual void* serializeToBlob(void* _stackPtr = NULL, const size_t& _stackSize = 0) const
			{
				return core::CorrespondingBlobTypeFor<IMeshDataFormatDesc<core::ICPUBuffer> >::type::createAndTryOnStack(static_cast<const IMeshDataFormatDesc<core::ICPUBuffer>*>(this), _stackPtr, _stackSize);
			}

            //! remember that the divisor needs to be <=0x1u<<_IRR_VAO_MAX_ATTRIB_DIVISOR_BITS
            void mapVertexAttrBuffer(core::ICPUBuffer* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0, uint32_t divisor=0)
            {
                assert(attrId<EVAI_COUNT);
        #ifdef _DEBUG
                if (!validCombination(type,components))
                {
                    //os::Printer::log("MeshBuffer mapVertexAttrBuffer INVALID COMBINATION OF COMPONENT TYPE AND COUNT!\n",ELL_ERROR);
                    return;
                }
        #endif // _DEBUG

                if (attrBuf)
                {
                    attrBuf->grab();

                    compntsPerAttr[attrId] = components;
                    attrType[attrId] = type;
                    attrStride[attrId] = stride!=0 ? stride:vertexAttrSize[type][components];
                    attrOffset[attrId] = offset;
                    attrDivisor[attrId] = divisor;
                }
                else
                {
                    compntsPerAttr[attrId] = ECPA_FOUR;
                    attrType[attrId] = ECT_FLOAT;
                    attrStride[attrId] = 16;
                    attrOffset[attrId] = 0;
                    attrDivisor[attrId] = 0;
                }

                if (mappedAttrBuf[attrId])
                    mappedAttrBuf[attrId]->drop();
                mappedAttrBuf[attrId] = attrBuf;
            }
	};

	class IGPUMeshDataFormatDesc : public IMeshDataFormatDesc<video::IGPUBuffer>
	{
	};




	template <class T>
	class IMeshBuffer : public virtual IReferenceCounted
	{
    protected:
	    virtual ~IMeshBuffer()
	    {
            if (leakDebugger)
                leakDebugger->deregisterObj(this);

            if (meshLayout)
                meshLayout->drop();
	    }

        video::SMaterial Material;
        core::aabbox3df boundingBox;
        IMeshDataFormatDesc<T>* meshLayout;
	    //indices
	    video::E_INDEX_TYPE indexType;
	    int32_t baseVertex;
        uint64_t indexCount;
        size_t indexBufOffset;
        //
        size_t instanceCount;
        uint32_t baseInstance;
        //primitives
        scene::E_PRIMITIVE_TYPE primitiveType;

        //debug
        core::LeakDebugger* leakDebugger;
	public:
		//! Constructor.
		/**
		@param layout Pointer to descriptor of mesh data object. Will be grabbed.
		@param dbgr Pointer to leak debugger object.
		*/
	    IMeshBuffer(IMeshDataFormatDesc<T>* layout=NULL, core::LeakDebugger* dbgr=NULL) : leakDebugger(dbgr)
	    {
            if (leakDebugger)
                leakDebugger->registerObj(this);

	        meshLayout = layout;
	        if (meshLayout)
                meshLayout->grab();

            indexType = video::EIT_UNKNOWN;
            baseVertex = 0;
            indexCount = 0;
            indexBufOffset = 0;

	        primitiveType = scene::EPT_TRIANGLES;

            instanceCount = 1;
            baseInstance = 0;
	    }

		//! Access data descriptor objects.
		/** @returns data descriptor object. */
	    inline IMeshDataFormatDesc<T>* getMeshDataAndFormat() {return meshLayout;}
		//! @copydoc getMeshDataAndFormat()
	    inline const IMeshDataFormatDesc<T>* getMeshDataAndFormat() const {return meshLayout;}
		//! Sets data descriptor object.
		/**
		Grabs the new object and drops the old one.
		@param layout new descriptor object.
		*/
	    inline void setMeshDataAndFormat(IMeshDataFormatDesc<T>* layout)
	    {
	        if (layout)
                layout->grab();

	        if (meshLayout)
                meshLayout->drop();
            meshLayout = layout;
	    }

		//! Get type of index data which is stored in this meshbuffer.
		/** \return Index type of this buffer. */
		inline const video::E_INDEX_TYPE& getIndexType() const {return indexType;}
		inline void setIndexType(const video::E_INDEX_TYPE& type) {indexType = type;}

		//! Sets offset in mapped index buffer.
		/** @param byteOffset Offset in bytes. */
		inline void setIndexBufferOffset(const size_t& byteOffset) {indexBufOffset = byteOffset;}
		//! Accesses offset in mapped index buffer.
		/** @returns Offset in bytes. */
		inline const size_t& getIndexBufferOffset() const {return indexBufOffset;}

		//! Get amount of indices in this meshbuffer.
		/** \return Number of indices in this buffer. */
		inline const uint64_t& getIndexCount() const {return indexCount;}
		//! Sets amount of indices.
		/** @returns Whether set amount exceeds mapped buffer's size. Regardless of result the amount is set. */
		inline bool setIndexCount(const uint64_t &newIndexCount)
		{
/*
#ifdef _DEBUG
            if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset))
            {
                os::Printer::log("MeshBuffer map vertex buffer overflow!\n",ELL_ERROR);
                return;
            }
#endif // _DEBUG
*/
            indexCount = newIndexCount;
            if (meshLayout)
            {
                const T* mappedIndexBuf = meshLayout->getIndexBuffer();
                if (mappedIndexBuf)
                {
                    switch (indexType)
                    {
                        case video::EIT_16BIT:
                            return indexCount*2+indexBufOffset<mappedIndexBuf->getSize();
                        case video::EIT_32BIT:
                            return indexCount*4+indexBufOffset<mappedIndexBuf->getSize();
                        default:
                            return false;
                    }
                }
            }

            return true;
		}

		//! Accesses base vertex number.
		/** @returns base vertex number. */
        inline const int32_t& getBaseVertex() const {return baseVertex;}
		//! Sets base vertex.
        inline void setBaseVertex(const int32_t& baseVx)
        {
            baseVertex = baseVx;
        }


		inline const scene::E_PRIMITIVE_TYPE& getPrimitiveType() const {return primitiveType;}
		inline void setPrimitiveType(const scene::E_PRIMITIVE_TYPE& type)
		{
		    primitiveType = type;
		}

		inline const size_t& getInstanceCount() const {return instanceCount;}
		inline void setInstanceCount(const size_t& count)
		{
		    instanceCount = count;
		}

		inline const uint32_t& getBaseInstance() const {return baseInstance;}
		inline void setBaseInstance(const uint32_t& base)
		{
		    baseInstance = base;
		}


		//! Get the axis aligned bounding box of this meshbuffer.
		/** \return Axis aligned bounding box of this buffer. */
		inline const core::aabbox3df& getBoundingBox() const {return boundingBox;}

		//! Set axis aligned bounding box
		/** \param box User defined axis aligned bounding box to use
		for this buffer. */
		inline void setBoundingBox(const core::aabbox3df& box)
		{
		    boundingBox = box;
		}

		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline const video::SMaterial& getMaterial() const
		{
			return Material;
		}


		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline video::SMaterial& getMaterial()
		{
			return Material;
		}
	};




	class ICPUMeshBuffer : public IMeshBuffer<core::ICPUBuffer>, core::BlobSerializable
	{
	    //vertices
	    E_VERTEX_ATTRIBUTE_ID posAttrId;
	public:
	    ICPUMeshBuffer(core::LeakDebugger* dbgr=NULL) : IMeshBuffer<core::ICPUBuffer>(NULL,dbgr), posAttrId(EVAI_ATTR0) {}

		virtual void* serializeToBlob(void* _stackPtr = NULL, const size_t& _stackSize = 0) const
		{
			return core::CorrespondingBlobTypeFor<ICPUMeshBuffer>::type::createAndTryOnStack(this, _stackPtr, _stackSize);
		}

		size_t calcVertexSize() const 
		{
			if (!meshLayout)
				return 0u;

			size_t size = 0u;
			for (size_t i = 0; i < EVAI_COUNT; ++i)
				if (meshLayout->getMappedBuffer((E_VERTEX_ATTRIBUTE_ID)i))
					size += vertexAttrSize[meshLayout->getAttribType((E_VERTEX_ATTRIBUTE_ID)i)][meshLayout->getAttribComponentCount((E_VERTEX_ATTRIBUTE_ID)i)];
			return size;
		}

		size_t calcVertexCount() const
		{
			size_t vertexCount = 0u;
			if (meshLayout && meshLayout->getIndexBuffer())
			{
				if (getIndexType() == video::EIT_16BIT)
				{
					for (size_t i = 0; i<getIndexCount(); i++)
					{
						size_t index = reinterpret_cast<const uint16_t*>(getIndices())[i];
						if (index>vertexCount)
							vertexCount = index;
					}
					if (getIndexCount())
						vertexCount++;
				}
				else if (getIndexType() == video::EIT_32BIT)
				{
					for (size_t i = 0; i<getIndexCount(); i++)
					{
						size_t index = reinterpret_cast<const uint32_t*>(getIndices())[i];
						if (index>vertexCount)
							vertexCount = index;
					}
					if (getIndexCount())
						vertexCount++;
				}
				else
					vertexCount = getIndexCount();
			}
			else
				vertexCount = getIndexCount();

			return vertexCount;
		}

		//! Returns id of position attribute.
        inline const E_VERTEX_ATTRIBUTE_ID& getPositionAttributeIx() const {return posAttrId;}
		//! Sets id of position atrribute.
        inline void setPositionAttributeIx(const E_VERTEX_ATTRIBUTE_ID& attrId)
        {
            if (attrId>=EVAI_COUNT)
            {
#ifdef _DEBUG
                //os::Printer::log("MeshBuffer setPositionAttributeIx attribute ID out of range!\n",ELL_ERROR);
#endif // _DEBUG
                return;
            }

            posAttrId = attrId;
        }

		//! Get access to Indices.
		/** \return Pointer to indices array. */
		inline void* getIndices()
		{
		    if (!meshLayout)
                return NULL;
            if (!meshLayout->getIndexBuffer())
                return NULL;

		    return ((uint8_t*)meshLayout->getIndexBuffer()->getPointer())+indexBufOffset;
        }

		//! Get access to Indices.
		/** We only keep track of a position attribute, as every vertex needs to have at least a position to be displayed on the screen.
		Certain vertices may not have colors, normals, texture coords, etc. but a position is always present.
		\return Pointer to index array. */
        inline const void* getIndices() const
        {
		    if (!meshLayout)
                return NULL;
            if (!meshLayout->getIndexBuffer())
                return NULL;

		    return ((const uint8_t*)meshLayout->getIndexBuffer()->getPointer())+indexBufOffset;
        }

		//! Accesses given index of mapped position attribute buffer.
		/** @param ix Index number of vertex which is to be returned.
		@returns `ix`th vertex of mapped attribute buffer or (0, 0, 0, 1) vector if an error occured (e.g. no such vertex).
		@see @ref getAttribute()
		*/
        virtual core::vectorSIMDf getPosition(size_t ix) const
        {
            core::vectorSIMDf outPos(0.f,0.f,0.f,1.f);
            bool success = getAttribute(outPos,posAttrId,ix);
#ifdef _DEBUG
            if (!success)
            {
                //os::Printer::log("SOME DEBUG MESSAGE!\n",ELL_ERROR);
            }
#endif // _DEBUG
		    return outPos;
        }

		//! Accesses data of buffer of attribute of given id
		/** Basically it will get the start of the array at the same point as OpenGL will get upon a glDraw*. 
		@param attrId Attribute id.
		@returns Pointer to corresponding buffer's data incremented by `baseVertex` and by `bufferOffset`
		@see @ref getBaseVertex() setBaseVertex() getAttribute()
		*/
        virtual uint8_t* getAttribPointer(const E_VERTEX_ATTRIBUTE_ID& attrId) const
        {
		    if (!meshLayout)
                return NULL;

            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(attrId);
            if (attrId>=EVAI_COUNT||!mappedAttrBuf)
                return NULL;

            E_COMPONENT_TYPE attrType = meshLayout->getAttribType(attrId);
            E_COMPONENTS_PER_ATTRIBUTE components = meshLayout->getAttribComponentCount(attrId);
            if (!validCombination(attrType,components))
                return NULL;


            int64_t ix = baseVertex;
            ix *= meshLayout->getMappedBufferStride(attrId);
            ix += meshLayout->getMappedBufferOffset(attrId);
            if (ix<0||ix>=mappedAttrBuf->getSize())
                return NULL;

            return ((uint8_t*)mappedAttrBuf->getPointer())+ix;
        }

		static bool getAttribute(core::vectorSIMDf& output, const void* src, E_COMPONENT_TYPE type, E_COMPONENTS_PER_ATTRIBUTE cpa)
		{
			if (!src)
				return false;

			const uint8_t* vxPtr = (const uint8_t*)(src);
			if (!vxPtr)
				return false;

			E_COMPONENT_TYPE attrType = type;
			E_COMPONENTS_PER_ATTRIBUTE components = cpa;

			switch (attrType)
			{
			case ECT_FLOAT:
				for (size_t j = 0; j<components; j++)
					output.pointer[j] = ((float*)vxPtr)[j];
				return true;
				break;
			case ECT_HALF_FLOAT:
				for (size_t j = 0; j < components; ++j)
					output.pointer[j] = core::Float16Compressor::decompress(((uint16_t*)vxPtr)[j]);
				return true;
				break;
			case ECT_DOUBLE_IN_FLOAT_OUT:
			case ECT_DOUBLE_IN_DOUBLE_OUT:
				for (size_t j = 0; j<components; j++)
					output.pointer[j] = ((double*)vxPtr)[j];
				return true;
				break;
			case ECT_UNSIGNED_INT_10F_11F_11F_REV:
			{
				if (components != ECPA_THREE)
					return false;

				uint32_t fp = ((uint32_t*)vxPtr)[0];
				for (size_t j = 0; j < 3; ++j)
				{
					if (j < 2)
					{
						output.pointer[j] = core::unpack11bitFloat(fp);
						fp >>= 11;
					}
					else
						output.pointer[j] = core::unpack10bitFloat(fp);
				}
			}
			break;
			case ECT_NORMALIZED_INT_2_10_10_10_REV:
			case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
			case ECT_INT_2_10_10_10_REV:
			case ECT_UNSIGNED_INT_2_10_10_10_REV:
				if (components == ECPA_FOUR)
				{
					output.pointer[0] = 0x3ffu & (((uint32_t*)vxPtr)[0]);
					output.pointer[1] = 0x3ffu & (((uint32_t*)vxPtr)[0] >> 10);
					output.pointer[2] = 0x3ffu & (((uint32_t*)vxPtr)[0] >> 20);
					output.pointer[3] = ((uint32_t*)vxPtr)[0] >> 30;
				}
				else if ((attrType == ECT_NORMALIZED_INT_2_10_10_10_REV || attrType == ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV) && components == ECPA_REVERSED_OR_BGRA)
				{
					output.pointer[2] = 0x3ffu & (((uint32_t*)vxPtr)[0]);
					output.pointer[1] = 0x3ffu & (((uint32_t*)vxPtr)[0] >> 10);
					output.pointer[0] = 0x3ffu & (((uint32_t*)vxPtr)[0] >> 20);
					output.pointer[3] = ((uint32_t*)vxPtr)[0] >> 30;
				}
				break;
			case ECT_NORMALIZED_BYTE:
			case ECT_NORMALIZED_UNSIGNED_BYTE:
			case ECT_BYTE:
			case ECT_UNSIGNED_BYTE:
				if (components != ECPA_REVERSED_OR_BGRA)
				{
					for (size_t j = 0; j < components; j++)
						output.pointer[j] = ((uint8_t*)vxPtr)[j];
				}
				else if (attrType == ECT_NORMALIZED_UNSIGNED_BYTE)
				{
					uint8_t* const src = (uint8_t*)vxPtr;
					output.pointer[2] = src[0];
					output.pointer[1] = src[1];
					output.pointer[0] = src[2];
					output.pointer[3] = src[3];
				}
				break;
			case ECT_NORMALIZED_SHORT:
			case ECT_NORMALIZED_UNSIGNED_SHORT:
			case ECT_SHORT:
			case ECT_UNSIGNED_SHORT:
				for (size_t j = 0; j<components; j++)
					output.pointer[j] = ((uint16_t*)vxPtr)[j];
				break;
			case ECT_NORMALIZED_INT:
			case ECT_NORMALIZED_UNSIGNED_INT:
			case ECT_INT:
			case ECT_UNSIGNED_INT:
				for (size_t j = 0; j<components; j++)
					output.pointer[j] = ((uint32_t*)vxPtr)[j];
				break;
			default:
				return false;
			}

			const core::vectorSIMDf subs[4][ECPA_COUNT] = {
				{ core::vectorSIMDf(2.f,512.f,512.f,512.f),core::vectorSIMDf(512.f,0.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,2.f) },
				{ core::vectorSIMDf(128.f,128.f,128.f,128.f),core::vectorSIMDf(128.f,0.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,128.f) },
				{ core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f),core::vectorSIMDf(32768.f,0.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f) },
				{ core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f),core::vectorSIMDf(2147483648.f,0.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f) }
			};
			switch (attrType)
			{
			case ECT_NORMALIZED_INT_2_10_10_10_REV:
			case ECT_INT_2_10_10_10_REV:
				output -= subs[0][components];
				break;
			case ECT_NORMALIZED_BYTE:
			case ECT_BYTE:
				output -= subs[1][components];
				break;
			case ECT_NORMALIZED_SHORT:
			case ECT_SHORT:
				output -= subs[2][components];
				break;
			case ECT_NORMALIZED_INT:
			case ECT_INT:
				output -= subs[3][components];
				break;
			default:
				break;
			}

			const core::vectorSIMDf divisors[8][ECPA_COUNT] = {
				{ core::vectorSIMDf(1.f,511.f,511.f,511.f),core::vectorSIMDf(511.f,1.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f) },
				{ core::vectorSIMDf(3.f,1023.f,1023.f,1023.f),core::vectorSIMDf(1023.f,1.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,3.f) },
				{ core::vectorSIMDf(127.f,127.f,127.f,127.f),core::vectorSIMDf(127.f,1.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,127.f) },
				{ core::vectorSIMDf(255.f,255.f,255.f,255.f),core::vectorSIMDf(255.f,1.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,255.f) },
				{ core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f),core::vectorSIMDf(32767.f,1.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f) },
				{ core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f),core::vectorSIMDf(65535.f,1.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f) },
				{ core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f),core::vectorSIMDf(2147483647.f,1.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f) },
				{ core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f),core::vectorSIMDf(4294967295.f,1.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f) }
			};
			switch (attrType)
			{
			case ECT_NORMALIZED_INT_2_10_10_10_REV:
				output /= divisors[0][components];
				break;
			case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
				output /= divisors[1][components];
				break;
			case ECT_NORMALIZED_BYTE:
				output /= divisors[2][components];
				break;
			case ECT_NORMALIZED_UNSIGNED_BYTE:
				output /= divisors[3][components];
				break;
			case ECT_NORMALIZED_SHORT:
				output /= divisors[4][components];
				break;
			case ECT_NORMALIZED_UNSIGNED_SHORT:
				output /= divisors[5][components];
				break;
			case ECT_NORMALIZED_INT:
				output /= divisors[6][components];
				break;
			case ECT_NORMALIZED_UNSIGNED_INT:
				output /= divisors[7][components];
				break;
			default:
				break;
			}

			const uint32_t outMasksBits[ECPA_COUNT][4] = {
				{ 0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu },
				{ 0xffffffffu,0,0,0 },
				{ 0xffffffffu,0xffffffffu,0,0 },
				{ 0xffffffffu,0xffffffffu,0xffffffffu,0 },
				{ 0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu }
			};
			const uint32_t outMasksBitsInv[ECPA_COUNT][4] = {
				{ 0,0,0,0 },
				{ 0,0xffffffffu,0xffffffffu,0xffffffffu },
				{ 0,0,0xffffffffu,0xffffffffu },
				{ 0,0,0,0xffffffffu },
				{ 0,0,0,0 }
			};
			switch (attrType)
			{
			case ECT_NORMALIZED_INT_2_10_10_10_REV:
			case ECT_NORMALIZED_BYTE:
			case ECT_NORMALIZED_SHORT:
			case ECT_NORMALIZED_INT:
			{
				core::vectorSIMDf outputMask, outputMaskInv;
				outputMask.set((float*)(outMasksBits[components]));
				outputMaskInv.set((float*)(outMasksBitsInv[components]));
				output = (max_(output, core::vectorSIMDf(-1.f, -1.f, -1.f, -1.f))&outputMask) | (outputMaskInv&output);
			}
			break;
			default:
				break;
			}

			return true;
		}

		//! Accesses vertex of given index of given vertex attribute. Index number is incremented by `baseVertex`. WARNING: NOT ALL FORMAT CONVERSIONS TO RGBA32F/XYZW32F ARE IMPLEMENTED!
		/** If component count of given attribute is less than 4, only first ones of output vector's members will be written.
		@param[out] output vectorSIMDf object to which index's value will be returned.
		@param[in] attrId Atrribute id.
		@param[in] ix Index which is to be accessed. Will be incremented by `baseVertex`.
		@returns true if successful or false if an error occured (e.g. `ix` out of range, no attribute specified/bound or given attribute's format conversion to vectorSIMDf unsupported).
		@see @ref getBaseVertex() setBaseVertex() getAttribute()
		*/
        virtual bool getAttribute(core::vectorSIMDf& output, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
			if (!meshLayout)
				return false;
			const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(attrId);
			if (!mappedAttrBuf)
				return false;

			uint8_t* src = getAttribPointer(attrId);
			src += ix*meshLayout->getMappedBufferStride(attrId);
			if (src >= ((const uint8_t*)(mappedAttrBuf->getPointer())) + mappedAttrBuf->getSize())
				return false;

			return getAttribute(output, src, meshLayout->getAttribType(attrId), meshLayout->getAttribComponentCount(attrId));
        }

		static bool getAttribute(uint32_t* output, const void* src, E_COMPONENT_TYPE type, E_COMPONENTS_PER_ATTRIBUTE cpa)
		{
			if (!src)
				return false;
			const uint8_t* vxPtr = (const uint8_t*)(src);

			E_COMPONENT_TYPE attrType = type;
			E_COMPONENTS_PER_ATTRIBUTE components = cpa;

			if (components == ECPA_REVERSED_OR_BGRA)
				return false;

			switch (attrType)
			{
			case ECT_INT_2_10_10_10_REV:
			case ECT_UNSIGNED_INT_2_10_10_10_REV:
			case ECT_INTEGER_INT_2_10_10_10_REV:
			case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
				output[0] = 0x3ffu & (((uint32_t*)vxPtr)[0]);
				output[1] = 0x3ffu & (((uint32_t*)vxPtr)[0] >> 10);
				output[2] = 0x3ffu & (((uint32_t*)vxPtr)[0] >> 20);
				output[3] = ((uint32_t*)vxPtr)[0] >> 30;
				break;
			case ECT_BYTE:
			case ECT_UNSIGNED_BYTE:
			case ECT_INTEGER_BYTE:
			case ECT_INTEGER_UNSIGNED_BYTE:
				for (size_t j = 0; j<components; j++)
					output[j] = ((uint8_t*)vxPtr)[j];
				break;
			case ECT_SHORT:
			case ECT_UNSIGNED_SHORT:
			case ECT_INTEGER_SHORT:
			case ECT_INTEGER_UNSIGNED_SHORT:
				for (size_t j = 0; j<components; j++)
					output[j] = ((uint16_t*)vxPtr)[j];
				break;
			case ECT_INT:
			case ECT_UNSIGNED_INT:
			case ECT_INTEGER_INT:
			case ECT_INTEGER_UNSIGNED_INT:
				for (size_t j = 0; j<components; j++)
					output[j] = ((uint32_t*)vxPtr)[j];
				break;
			default:
				return false;
			}
			return true;
		}

		//! Accesses vertex of given index of given vertex attribute. Index number is incremented by `baseVertex`. WARNING: NOT ALL FORMAT CONVERSIONS TO RGBA32F/XYZW32F ARE IMPLEMENTED!
		/** If component count of given attribute is less than 4, only first ones of output vector's members will be written.
		Attributes of integer types smaller than 32 bits are promoted to 32bit integer.
		@param[out] output Pointer to memory to which index's value will be returned.
		@param[in] attrId Atrribute id.
		@param[in] ix Index which is to be accessed. Will be incremented by `baseVertex`.
		@returns true if successful or false if an error occured (e.g. `ix` out of range, no attribute specified/bound or given attribute's format conversion to vectorSIMDf unsupported).
		@see @ref getBaseVertex() setBaseVertex() getAttribute()
		*/
		virtual bool getAttribute(uint32_t* output, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
		{
			if (!meshLayout)
				return false;
			const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(attrId);
			if (!mappedAttrBuf)
				return false;

			uint8_t* src = getAttribPointer(attrId);
			src += ix*meshLayout->getMappedBufferStride(attrId);
			if (src >= ((const uint8_t*)(mappedAttrBuf->getPointer())) + mappedAttrBuf->getSize())
				return false;

			return getAttribute(output, src, meshLayout->getAttribType(attrId), meshLayout->getAttribComponentCount(attrId));
		}

		static bool setAttribute(core::vectorSIMDf input, void* dst, E_COMPONENT_TYPE type, E_COMPONENTS_PER_ATTRIBUTE cpa)
		{
			if (!dst)
				return false;
			uint8_t* vxPtr = (uint8_t*)dst;

			E_COMPONENT_TYPE attrType = type;
			E_COMPONENTS_PER_ATTRIBUTE components = cpa;

			switch (attrType)
			{
			case ECT_FLOAT:
				for (size_t j = 0; j<components; j++)
					((float*)vxPtr)[j] = input.pointer[j];
				return true;
				break;
			case ECT_HALF_FLOAT:
				for (size_t j = 0; j < components; ++j)
					((uint16_t*)vxPtr)[j] = core::Float16Compressor::compress(input.pointer[j]);
				return true;
				break;
			case ECT_DOUBLE_IN_FLOAT_OUT:
			case ECT_DOUBLE_IN_DOUBLE_OUT:
				for (size_t j = 0; j<components; j++)
					((double*)vxPtr)[j] = input.pointer[j];
				return true;
				break;
			case ECT_UNSIGNED_INT_10F_11F_11F_REV:
				if (components != ECPA_THREE)
					return false;
				((uint32_t*)vxPtr)[0] =
					(core::to11bitFloat(input.pointer[0]) << 0) |
					(core::to11bitFloat(input.pointer[1]) << 11) |
					(core::to10bitFloat(input.pointer[2]) << 22);
				return true;
				break;
			case ECT_NORMALIZED_INT_2_10_10_10_REV:
			case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
			case ECT_NORMALIZED_BYTE:
			case ECT_NORMALIZED_UNSIGNED_BYTE:
			case ECT_NORMALIZED_SHORT:
			case ECT_NORMALIZED_UNSIGNED_SHORT:
			case ECT_NORMALIZED_INT:
			case ECT_NORMALIZED_UNSIGNED_INT:
			case ECT_INT_2_10_10_10_REV:
			case ECT_UNSIGNED_INT_2_10_10_10_REV:
			case ECT_BYTE:
			case ECT_UNSIGNED_BYTE:
			case ECT_SHORT:
			case ECT_UNSIGNED_SHORT:
			case ECT_INT:
			case ECT_UNSIGNED_INT:
			{
				const core::vectorSIMDf multipliers[8][ECPA_COUNT] = {
					{ core::vectorSIMDf(1.f,511.f,511.f,511.f),core::vectorSIMDf(511.f,1.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,1.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f),core::vectorSIMDf(511.f,511.f,511.f,1.f) },
					{ core::vectorSIMDf(3.f,1023.f,1023.f,1023.f),core::vectorSIMDf(1023.f,1.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,1.f),core::vectorSIMDf(1023.f,1023.f,1023.f,3.f) },
					{ core::vectorSIMDf(127.f,127.f,127.f,127.f),core::vectorSIMDf(127.f,1.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,1.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,1.f),core::vectorSIMDf(127.f,127.f,127.f,127.f) },
					{ core::vectorSIMDf(255.f,255.f,255.f,255.f),core::vectorSIMDf(255.f,1.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,1.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,1.f),core::vectorSIMDf(255.f,255.f,255.f,255.f) },
					{ core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f),core::vectorSIMDf(32767.f,1.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,1.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,1.f),core::vectorSIMDf(32767.f,32767.f,32767.f,32767.f) },
					{ core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f),core::vectorSIMDf(65535.f,1.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,1.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,1.f),core::vectorSIMDf(65535.f,65535.f,65535.f,65535.f) },
					{ core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f),core::vectorSIMDf(2147483647.f,1.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,1.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,1.f),core::vectorSIMDf(2147483647.f,2147483647.f,2147483647.f,2147483647.f) },
					{ core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f),core::vectorSIMDf(4294967295.f,1.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,1.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,1.f),core::vectorSIMDf(4294967295.f,4294967295.f,4294967295.f,4294967295.f) }
				};

				switch (attrType)
				{
				case ECT_NORMALIZED_INT_2_10_10_10_REV:
					input *= multipliers[0][components];
					break;
				case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
					input *= multipliers[1][components];
					break;
				case ECT_NORMALIZED_BYTE:
					input *= multipliers[2][components];
					break;
				case ECT_NORMALIZED_UNSIGNED_BYTE:
					input *= multipliers[3][components];
					break;
				case ECT_NORMALIZED_SHORT:
					input *= multipliers[4][components];
					break;
				case ECT_NORMALIZED_UNSIGNED_SHORT:
					input *= multipliers[5][components];
					break;
				case ECT_NORMALIZED_INT:
					input *= multipliers[6][components];
					break;
				case ECT_NORMALIZED_UNSIGNED_INT:
					input *= multipliers[7][components];
					break;
				}

				const core::vectorSIMDf adds[4][ECPA_COUNT] = {
					{ core::vectorSIMDf(2.f,512.f,512.f,512.f),core::vectorSIMDf(512.f,0.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,0.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,0.f),core::vectorSIMDf(512.f,512.f,512.f,2.f) },
					{ core::vectorSIMDf(128.f,128.f,128.f,128.f),core::vectorSIMDf(128.f,0.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,0.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,0.f),core::vectorSIMDf(128.f,128.f,128.f,128.f) },
					{ core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f),core::vectorSIMDf(32768.f,0.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,0.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,0.f),core::vectorSIMDf(32768.f,32768.f,32768.f,32768.f) },
					{ core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f),core::vectorSIMDf(2147483648.f,0.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,0.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,0.f),core::vectorSIMDf(2147483648.f,2147483648.f,2147483648.f,2147483648.f) }
				};

				switch (attrType)
				{
				case ECT_INT_2_10_10_10_REV:
				case ECT_NORMALIZED_INT_2_10_10_10_REV:
					input += adds[0][components];
					break;
				case ECT_BYTE:
				case ECT_NORMALIZED_BYTE:
					input += adds[1][components];
					break;
				case ECT_SHORT:
				case ECT_NORMALIZED_SHORT:
					input += adds[2][components];
					break;
				case ECT_INT:
				case ECT_NORMALIZED_INT:
					input += adds[3][components];
					break;
				}

				switch (attrType)
				{
				case ECT_INT_2_10_10_10_REV:
				case ECT_UNSIGNED_INT_2_10_10_10_REV:
				case ECT_NORMALIZED_INT_2_10_10_10_REV:
				case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
					if (components == ECPA_FOUR)
						reinterpret_cast<uint32_t*>(vxPtr)[0] = (uint32_t(input.pointer[0]) & 0x3ffu) | ((uint32_t(input.pointer[1]) & 0x3ffu) << 10) | ((uint32_t(input.pointer[2]) & 0x3ffu) << 20) | ((uint32_t(input.pointer[3]) & 0x3u) << 30);
					else if (components == ECPA_REVERSED_OR_BGRA)
						reinterpret_cast<uint32_t*>(vxPtr)[0] = (uint32_t(input.pointer[2]) & 0x3ffu) | ((uint32_t(input.pointer[1]) & 0x3ffu) << 10) | ((uint32_t(input.pointer[0]) & 0x3ffu) << 20) | ((uint32_t(input.pointer[3]) & 0x3u) << 30);
					return true;
					break;
				case ECT_BYTE:
				case ECT_UNSIGNED_BYTE:
				case ECT_NORMALIZED_BYTE:
				case ECT_NORMALIZED_UNSIGNED_BYTE:
					if (components != ECPA_REVERSED_OR_BGRA)
					{
						for (size_t j = 0; j<components; j++)
							reinterpret_cast<uint8_t*>(vxPtr)[j] = (uint8_t)input.pointer[j];
					}
					else if (attrType == ECT_NORMALIZED_UNSIGNED_BYTE)
					{
						uint8_t* const dst = (uint8_t*)vxPtr;
						dst[0] = (uint8_t)input.pointer[2];
						dst[1] = (uint8_t)input.pointer[1];
						dst[2] = (uint8_t)input.pointer[0];
						dst[3] = (uint8_t)input.pointer[3];
					}
					return true;
					break;
				case ECT_SHORT:
				case ECT_UNSIGNED_SHORT:
				case ECT_NORMALIZED_SHORT:
				case ECT_NORMALIZED_UNSIGNED_SHORT:
					for (size_t j = 0; j<components; j++)
						reinterpret_cast<uint16_t*>(vxPtr)[j] = (uint16_t)input.pointer[j];
					return true;
					break;
				case ECT_INT:
				case ECT_UNSIGNED_INT:
				case ECT_NORMALIZED_INT:
				case ECT_NORMALIZED_UNSIGNED_INT:
					for (size_t j = 0; j<components; j++)
						reinterpret_cast<uint32_t*>(vxPtr)[j] = (uint32_t)input.pointer[j];
					return true;
					break;
				default:
					return false;
					break;
				}
			} break; // end case
			}

			return false;
		}

		//! Sets value of vertex of given index of given attribute. WARNING: NOT ALL FORMAT CONVERSIONS FROM RGBA32F/XYZW32F (vectorSIMDf) ARE IMPLEMENTED!
		/** @param input Value which is to be set.
		@param attrId Atrribute id.
		@param ix Index of vertex which is to be set. Will be incremented by `baseVertex`.
		@returns true if successful or false if an error occured (e.g. no such index).
		@see @ref getBaseVertex() setBaseVertex() getAttribute()
		*/
        virtual bool setAttribute(core::vectorSIMDf input, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
			if (!meshLayout)
				return false;
			const core::ICPUBuffer* mappedBuffer = meshLayout->getMappedBuffer(attrId);
			if (!mappedBuffer)
				return false;

			uint8_t* dst = getAttribPointer(attrId);
			dst += ix*meshLayout->getMappedBufferStride(attrId);
			if (dst >= ((const uint8_t*)(mappedBuffer->getPointer())) + mappedBuffer->getSize())
				return false;

			return setAttribute(input, dst, meshLayout->getAttribType(attrId), meshLayout->getAttribComponentCount(attrId));
        }

		static bool setAttribute(const uint32_t* _input, void* dst, E_COMPONENT_TYPE type, E_COMPONENTS_PER_ATTRIBUTE cpa)
		{
			if (!dst)
				return false;
			uint8_t* vxPtr = (uint8_t*)dst;

			E_COMPONENT_TYPE attrType = type;
			E_COMPONENTS_PER_ATTRIBUTE components = cpa;

			if (components == ECPA_REVERSED_OR_BGRA)
				return false;

			uint32_t input[4];
			memcpy(input, _input, std::min((int)components, 4) * sizeof(*input));

			switch (attrType)
			{
			case ECT_UNSIGNED_INT_2_10_10_10_REV:
			case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
			case ECT_INT_2_10_10_10_REV:
			case ECT_INTEGER_INT_2_10_10_10_REV:
				if (components != ECPA_FOUR)
					return false;
				reinterpret_cast<uint32_t*>(vxPtr)[0] = (input[0] & 0x3ffu) | ((input[1] & 0x3ffu) << 10) | ((input[2] & 0x3ffu) << 20) | ((input[3] & 0x3u) << 30);
				return true;
				break;
			case ECT_UNSIGNED_BYTE:
			case ECT_INTEGER_UNSIGNED_BYTE:
			case ECT_BYTE:
			case ECT_INTEGER_BYTE:
				for (size_t j = 0; j < components; j++)
					reinterpret_cast<uint8_t*>(vxPtr)[j] = input[j];
				return true;
				break;
			case ECT_UNSIGNED_SHORT:
			case ECT_INTEGER_UNSIGNED_SHORT:
			case ECT_SHORT:
			case ECT_INTEGER_SHORT:
				for (size_t j = 0; j<components; j++)
					reinterpret_cast<uint16_t*>(vxPtr)[j] = input[j];
				return true;
				break;
			case ECT_UNSIGNED_INT:
			case ECT_INTEGER_UNSIGNED_INT:
			case ECT_INT:
			case ECT_INTEGER_INT:
				for (size_t j = 0; j<components; j++)
					reinterpret_cast<uint32_t*>(vxPtr)[j] = input[j];
				return true;
				break;
			default:
				return false;
				break;

			}

			return false;
		}

		//! @copydoc setAttribute(core::vectorSIMDf, const E_VERTEX_ATTRIBUTE_ID&, size_t)
        virtual bool setAttribute(const uint32_t* _input, const E_VERTEX_ATTRIBUTE_ID& attrId, size_t ix) const
        {
			if (!meshLayout)
				return false;
			const core::ICPUBuffer* mappedBuffer = meshLayout->getMappedBuffer(attrId);
			if (!mappedBuffer)
				return false;

			uint8_t* dst = getAttribPointer(attrId);
			dst += ix*meshLayout->getMappedBufferStride(attrId);
			if (dst >= ((const uint8_t*)(mappedBuffer->getPointer())) + mappedBuffer->getSize())
				return false;

			return setAttribute(_input, dst, meshLayout->getAttribType(attrId), meshLayout->getAttribComponentCount(attrId));
        }


		//! Recalculates the bounding box. Should be called if the mesh changed.
		virtual void recalculateBoundingBox()
		{
		    if (!meshLayout)
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

            const core::ICPUBuffer* mappedAttrBuf = meshLayout->getMappedBuffer(posAttrId);
            if (posAttrId>=EVAI_COUNT||!mappedAttrBuf)
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

		    if (!validCombination(meshLayout->getAttribType(posAttrId),meshLayout->getAttribComponentCount(posAttrId)))
            {
                boundingBox.reset(core::vector3df(0.f));
                return;
            }

            for (size_t j=0; j<indexCount; j++)
            {
                size_t ix;
                void* indices = getIndices();
                if (indices)
                {
                    switch(indexType)
                    {
                        case video::EIT_32BIT:
                            ix  = ((uint32_t*)indices)[j];
                            break;
                        case video::EIT_16BIT:
                            ix  = ((uint16_t*)indices)[j];
                            break;
                        default:
                            return;
                    }
                }
                else
                    ix = j;


                if (j)
                    boundingBox.addInternalPoint(getPosition(ix).getAsVector3df());
                else
                    boundingBox.reset(getPosition(ix).getAsVector3df());
            }
		}
	};

	class IGPUMeshBuffer : public IMeshBuffer<video::IGPUBuffer>
	{
            video::ITransformFeedback* attachedXFormFeedback;
            uint32_t attachedXFormFeedbackStream;
        protected:
            virtual ~IGPUMeshBuffer()
            {
                if (attachedXFormFeedback)
                    attachedXFormFeedback->drop();
            }
        public:
            IGPUMeshBuffer(core::LeakDebugger* dbgr=NULL) : IMeshBuffer<video::IGPUBuffer>(NULL,dbgr), attachedXFormFeedback(NULL), attachedXFormFeedbackStream(0) {}

            inline void setIndexCountFromXFormFeedback(video::ITransformFeedback* xformFeedback, const uint32_t & stream)
            {
                attachedXFormFeedbackStream = stream;


                if (xformFeedback==attachedXFormFeedback)
                    return;

                if (!xformFeedback)
                {
                    if (attachedXFormFeedback)
                        attachedXFormFeedback->drop();

                    attachedXFormFeedback = NULL;
                    return;
                }

                xformFeedback->grab();
                if (attachedXFormFeedback)
                    attachedXFormFeedback->drop();
                attachedXFormFeedback = xformFeedback;

                indexType = video::EIT_UNKNOWN;
                indexCount = 0;
            }

            inline video::ITransformFeedback* getXFormFeedback() const {return attachedXFormFeedback;}

            inline const uint32_t& getXFormFeedbackStream() const {return attachedXFormFeedbackStream;}

            bool isIndexCountGivenByXFormFeedback() const {return attachedXFormFeedback!=NULL;}
	};

#include "irrpack.h"
    class SkinnedVertexIntermediateData
    {
        public:
            SkinnedVertexIntermediateData()
            {
                memset(this,0,20);
            }
            uint8_t boneIDs[4];
            float boneWeights[4];
    } PACK_STRUCT;

    struct SkinnedVertexFinalData
    {
        public:
            uint8_t boneIDs[4];
            uint32_t boneWeights; //ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV
    } PACK_STRUCT;
#include "irrunpack.h"

} // end namespace scene
} // end namespace irr

#endif


